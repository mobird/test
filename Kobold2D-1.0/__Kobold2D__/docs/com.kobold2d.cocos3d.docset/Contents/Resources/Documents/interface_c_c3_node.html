<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3Node Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_node.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3Node Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3Node" --><!-- doxytag: inherits="CC3Identifiable" -->
<p><code>#include &lt;CC3Node.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Node:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_node__inherit__graph.png" border="0" usemap="#_c_c3_node_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_node_inherit__map" id="_c_c3_node_inherit__map">
<area shape="rect" id="node5" href="interface_c_c3_bone.html" title="CC3Bone is the building block of skeletons that control the deformation of a skin mesh..." alt="" coords="319,161,393,189"/><area shape="rect" id="node9" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="282,213,430,241"/><area shape="rect" id="node45" href="interface_c_c3_p_o_d_node.html" title="A CC3Node extracted from a POD file." alt="" coords="305,265,407,293"/><area shape="rect" id="node47" href="interface_c_c3_resource_node.html" title="A CC3ResourceNode is a CC3Node that that wraps an instance of a subclass of CC3Resource in the resour..." alt="" coords="294,317,418,345"/><area shape="rect" id="node51" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft&#45;body object that uses vertex skinning ..." alt="" coords="293,369,419,397"/><area shape="rect" id="node53" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction..." alt="" coords="291,421,421,449"/><area shape="rect" id="node65" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene." alt="" coords="316,473,396,501"/><area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,317,112,345"/><area shape="rect" id="node7" href="interface_c_c3_p_o_d_bone.html" title="A CC3Bone extracted from a POD file." alt="" coords="503,161,604,189"/><area shape="rect" id="node11" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh." alt="" coords="501,213,605,241"/><area shape="rect" id="node13" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world." alt="" coords="707,30,803,58"/><area shape="rect" id="node19" href="interface_c_c3_box_node.html" title="CC3BoxNode is a type of CC3MeshNode that is specialized to display simple box or cube meshes..." alt="" coords="706,82,803,110"/><area shape="rect" id="node21" href="interface_c_c3_line_node.html" title="CC3LineNode is a type of CC3MeshNode that is specialized to display lines." alt="" coords="705,134,804,162"/><area shape="rect" id="node29" href="interface_c_c3_plane_node.html" title="CC3PlaneNode is a type of CC3MeshNode that is specialized to display planes and simple rectanglular m..." alt="" coords="703,186,807,214"/><area shape="rect" id="node31" href="interface_c_c3_p_o_d_mesh_node.html" title="A CC3MeshNode whose content originates from POD resource data." alt="" coords="689,238,820,266"/><area shape="rect" id="node33" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles." alt="" coords="677,290,832,318"/><area shape="rect" id="node41" href="interface_c_c3_skin_mesh_node.html" title="CC3SkinMeshNode is a CC3MeshNode specialized to use vertex skinning to draw the contents of its mesh..." alt="" coords="690,342,819,370"/><area shape="rect" id="node15" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano..." alt="" coords="919,5,1049,33"/><area shape="rect" id="node17" href="interface_c_c3_particle_system_billboard.html" title="A CC3Billboard node customized to display and manage a cocos2d 2D CCParticleSystem." alt="" coords="896,57,1072,85"/><area shape="rect" id="node23" href="interface_c_c3_wireframe_bounding_box_node.html" title="CC3WireframeBoundingBoxNode is a type of CC3LineNode specialized for drawing a wireframe bounding box..." alt="" coords="880,134,1088,162"/><area shape="rect" id="node25" href="interface_c_c3_direction_marker_node.html" title="CC3DirectionMarkerNode is a type of CC3LineNode specialized for drawing a line from the pivot point o..." alt="" coords="1194,109,1358,137"/><area shape="rect" id="node27" href="interface_c_c3_wireframe_local_content_bounding_box_node.html" title="CC3WireframeLocalContentBoundingBoxNode is a CC3WireframeBoundingBoxNode that further specializes in ..." alt="" coords="1136,161,1416,189"/><area shape="rect" id="node35" href="interface_c_c3_mortal_point_particle_emitter.html" title="CC3MortalPointParticleEmitter emits particles of type CC3MortalPointParticle." alt="" coords="889,290,1079,318"/><area shape="rect" id="node37" href="interface_c_c3_point_particle_hose_emitter.html" title="CC3PointParticleHoseEmitter emits CC3UniformMotionParticle particles in a stream, as if from the nozz..." alt="" coords="1185,290,1367,318"/><area shape="rect" id="node39" href="interface_c_c3_variegated_point_particle_hose_emitter.html" title="CC3VariegatedPointParticleHoseEmitter is a type of CC3PointParticleHoseEmitter whose particles can ha..." alt="" coords="1464,290,1704,318"/><area shape="rect" id="node43" href="interface_c_c3_p_o_d_skin_mesh_node.html" title="A CC3SkinMeshNode extracted from a POD file." alt="" coords="906,342,1062,370"/><area shape="rect" id="node49" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource." alt="" coords="478,317,629,345"/><area shape="rect" id="node55" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world." alt="" coords="510,394,597,422"/><area shape="rect" id="node59" href="interface_c_c3_light.html" title="CC3Light represents the light in the 3D world." alt="" coords="516,446,591,474"/><area shape="rect" id="node63" href="interface_c_c3_light_tracker.html" title="CC3LightTracker is a specialized CC3TargettingNode that tracks a target and automatically updates its..." alt="" coords="495,498,611,526"/><area shape="rect" id="node57" href="interface_c_c3_p_o_d_camera.html" title="A CC3Camera whose content originates from POD resource data." alt="" coords="698,394,812,422"/><area shape="rect" id="node61" href="interface_c_c3_p_o_d_light.html" title="A CC3Light whose content originates from POD resource data." alt="" coords="704,446,805,474"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3Node:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_node__coll__graph.png" border="0" usemap="#_c_c3_node_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_node_coll__map" id="_c_c3_node_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/><area shape="rect" id="node4" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array." alt="" coords="137,6,236,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_node-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a14386e095b6fa995faf1544dd09c8b1d">addAndLocalizeChild:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae2e9f558c788f29f9107799cc6c1dde8">addAxesDirectionMarkers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac4d0746d13937340c19e38b1c04c3476">addChild:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa930b2bc24563bfd1f635f8d833ba618">addDirectionMarker</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5a5b607ec466a3fa89e5943c6f242cb9">addDirectionMarkerColored:inDirection:</a> (ccColor4F aColor,[inDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5b69b89f01d7c98c0303f1e03d976558">alignInvertedTextures</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6ba26fe792bf02227f68e7e22d3a56cb">alignTextures</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5e0c8eb0c20c5eee0c4cc4384846ce08">appendStructureDescriptionTo:withIndent:</a> (NSMutableString *desc,[withIndent] NSUInteger indentLevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a012a06e674832b208b83d0b2c14235b7">asCameraTracker</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab568988d7fd88958b233974a540ec3a7">asLightTracker</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a194e5a2dae03a9d9536273f34b141c47">asTargettingNode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0141caa285eb8aef6de547765bceacc7">asTracker</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#acaf3b104117af9ee7cfc8ed440bc5bbd">bindRestPose</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af97c6f748a3d85fd23a8a4c62e9decd8">buildTransformMatrixWithVisitor:</a> (<a class="el" href="interface_c_c3_node_transforming_visitor.html">CC3NodeTransformingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a65611a362386a198f5037c953c5a8f7e">checkDrawingOrder</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a112737ec0e32b70af8504b54dda5fe90">cleanup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7bda04af22d4853e65cbb1b2a7be0097">copy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aec0fbbf1cbbbf174ec68f2322856db97">copyWithName:</a> (NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa1be5eb9f0e3e3f2513b5050e4d585f8">createGLBuffers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0789463c8d3f49e650adbb3212353f2b">deleteGLBuffers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a82c485272397d436522a17cccaa8fdb3">disableAllAnimation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad73159b10aa52fe8089eb982bdbf5250">disableAnimation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a313faba92d4638b21ad6d02ba7ca6e95">doesIntersectFrustum:</a> (<a class="el" href="interface_c_c3_frustum.html">CC3Frustum</a> *aFrustum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4073440a0b8f9c18533cbc5121649657">doNotBufferVertexColors</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a17688b23c1dea97ed7b7419bf4d3b789">doNotBufferVertexIndices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1c776539f12809fbf268332920a7f21d">doNotBufferVertexLocations</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af3a1d834d261b862e7af1f7426c071d5">doNotBufferVertexNormals</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a388e8ab71dceb5b771695ce8785ac411">doNotBufferVertexTextureCoordinates</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a883c0a80269bd598483d19480b8276ec">drawWithVisitor:</a> (<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad3307a8e1d887ce258b8bd370d8799c5">enableAllAnimation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3e99eb2ee98ebcb169f77a76aac19a08">enableAnimation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4adf77b1b7e0ac1f8fcb45213714405d">establishAnimationFrameAt:</a> (ccTime t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aae71487c59c9183c237e11ce5910189e">flatten</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aebd507bc13477ca1919d7ce762727600">flattenInto:</a> (CCArray *anArray)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCAction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3b7859bf10890a905ba5f1a1e3a8e8ba">getActionByTag:</a> (int tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a42cd132329b6a2a98cf1456f3fe58275">getNodeNamed:</a> (NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a8f4927d3aca147fe0993ae4c29f6d9c1">getNodeTagged:</a> (GLuint aTag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#afde494ed8885dc8873dfd104e1622394">isDescendantOf:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a34fa1a364640216ee61ab9d25471b147">linkToPODNodes:</a> (CCArray *nodeArray)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#abe610fe825b7adc7c427df840a521712">markTransformDirty</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aadece09770edf39fcf3624e417ba92ed">nodePODStructAtIndex:fromPODResource:</a> (uint aPODIndex,[fromPODResource] <a class="el" href="interface_c_c3_p_o_d_resource.html">CC3PODResource</a> *aPODRez)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aea16e1b4f5d61972ae0997ae85d88835">numberOfRunningActions</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aefaf0265e8b2f99e9ab38cef8694805c">reattachBonesFrom:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aed659e8d9413127d5d8e9c82828888fc">rebuildBoundingVolume</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a88b275ed5a68b2d8a78712ff41d6acbc">releaseRedundantData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab638f5dbea673bc7b88dc311bf7ae470">remove</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0532b78d1036a404f8dd6d87b97d4e87">removeAllChildren</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#abae4e44bd04d192def8a432fe0bb397e">removeAllDirectionMarkers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aba8f89a7edb29eb961336837f4cf3dd5">removeChild:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aae6580702191d386d7495c6801a016ce">retainVertexColors</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af476409b656940fe8fd6e348b5b8b2be">retainVertexIndices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a99cdb8a721320e3b4aa237389eeb117a">retainVertexLocations</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a41dc7d2c118673a0690be00d450094ab">retainVertexNormals</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3f757942e44ce601a9d72eedca5a1f2a">retainVertexTextureCoordinates</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae31dc98fcd8cf5cfe08414ffd1d221e6">rotateBy:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aRotation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9d49f8a0bc739861bc44ca4ad1e9ffdc">rotateByAngle:aroundAxis:</a> (GLfloat anAngle,[aroundAxis] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> anAxis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa66db6ffa7347b7fbe8afa73c4e51f91">rotateByQuaternion:</a> (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> aQuaternion)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCAction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a88bc1389a0a31d1684f197ed50e24677">runAction:</a> (CCAction *action)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5491e5b27a1c2c241cbc0389a1c25ed8">stopAction:</a> (CCAction *action)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a77d78c07263fb63bac5870f613120ab2">stopActionByTag:</a> (int tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6b01f39758bd6f3f8e906b7a2fb0e6b3">stopAllActions</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab82ef9ad2019facf5e9abce84ab60407">touchDisableAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa67c8b5f44c53322c4eebc9f5254cf61">touchEnableAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a422d97fc205cb37b3386424a19d7fa83">transformAndDrawWithVisitor:</a> (<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a731c3aeca363031bbabe0d5a871d94cd">transformVisitorClass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac184ae5d67268b69539f89d90ac04676">translateBy:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3c74947cca4fdd39d89ea8cdf6e48dca">updateAfterTransform:</a> (<a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab33607fc5db4c079ebfb42d9da5acbea">updateBeforeTransform:</a> (<a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aad700ea837bfc1a3116d65b4d706dd1b">updateTransformMatrices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aca3ae47f66bacb1c171d37a5ee4458db">updateTransformMatrix</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae728eca9485726ddd19641aa6750fc07">wasRemoved</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ada3f710a973e5f1dbe55fb1f36cd830d">defaultScaleTolerance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGFloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aca18dcafe9eb909c1828835372e5dc38">descriptorFontSize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad9766013ea54fd0d093eb6c5eb622fb5">directionMarkerColor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad6d70878798bce4171f1d4350c44d8a5">node</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a41a17bdf54960dc689a3b70977f86219">nodeAtIndex:fromPODResource:</a> (int aPODIndex,[fromPODResource] <a class="el" href="interface_c_c3_p_o_d_resource.html">CC3PODResource</a> *aPODRez)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aee98350cf8efb119effb2bb42537b420">nodeWithName:</a> (NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a13a146da2a8401c683cc5cdd3524a577">nodeWithTag:</a> (GLuint aTag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae7eec38a17f61714d1924669e556b530">nodeWithTag:withName:</a> (GLuint aTag,[withName] NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1b88fcdbe55ee1f3225cea1857841a17">setDefaultScaleTolerance:</a> (GLfloat aTolerance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9d4305b124b27d89d50b859f9ebff784">setDescriptorFontSize:</a> (CGFloat fontSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4ba164580d0895194fbf3a5b859ecb60">setDirectionMarkerColor:</a> (ccColor4F aColor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae69fcaf11981b068bcdc8963639c7317">setWireframeBoxColor:</a> (ccColor4F aColor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a95bebe8af43ea7f80e5a6d8c1a333c09">wireframeBoxColor</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a428a278cabd7bfbdef6eb28e0a9f491d"></a><!-- doxytag: member="CC3Node::globalRotationMatrix" ref="a428a278cabd7bfbdef6eb28e0a9f491d" args="" -->
<a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>globalRotationMatrix</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c163ab8dda7d1008e8c1001e7b98d8"></a><!-- doxytag: member="CC3Node::isGlobalRotationDirty" ref="a98c163ab8dda7d1008e8c1001e7b98d8" args="" -->
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>isGlobalRotationDirty</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a3a18de2ec0bd81eea76494eae7531"></a><!-- doxytag: member="CC3Node::isTransformInvertedDirty" ref="ae9a3a18de2ec0bd81eea76494eae7531" args="" -->
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>isTransformInvertedDirty</b></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_camera.html">CC3Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6c93e6c1c60cf0757df9bd33cdc09fbb">activeCamera</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a87fc1dcd7533a6d9f29564116ab7d3fe">ambientColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1bf395d66179ab8f968d642dd4998eef">animation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccBlendFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af98fb62a333ea1cc0fdbe4d401c0e2aa">blendFunc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a1aa866559f901e646c7cb1798e1113ec">boundingBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#afc68b65e37320813d43dba734ec8e381">boundingVolume</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7733dc8471757b6109d86e7fb688cbf7">boundingVolumePadding</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9f8e8744313f6ffa67116db7f92fda9a">children</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor3B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a03aece3103f5751908dfda571a5a4145">color</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad5fcdcec31ea7f5020dbfc322a547a0d">containsAnimation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a8b5a7a014ef8c5297a0d2a5a74442316">depthFunction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_descriptor.html">CC3NodeDescriptor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae7dedd671475792c90a14ba94f867d6d">descriptorNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0bb07b8079bf75af208434b5360cc58b">diffuseColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a619d2afdf429d6cf4fba13008d7d6372">directionMarkers</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3aed7fbdc1d3807d2da7d46ec3aee096">dirtiestAncestor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a821370544c7d36e7cbb742988b936102">emissionColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af0ba63c550ccefcced28e809239f86c3">globalBoundingBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a2fdfd0ca5824487179b86d45b868c78b">globalLightLocation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad0ca6732d1834fb1ad348a190f810121">globalLocation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4b3a431575f6e933f31ba2a8d9fa54e0">globalRotation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a14e0823f5a3988cbd52c2bc566a5f492">globalScale</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae984cc3ad8b86f4a031fa569d7745161">hasLocalContent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab7dc69f8df858e108e70fc9f6258a347">hasSoftBodyContent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af22c9f1b5440020b97fb89f8e9a2c508">isAnimationEnabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a58a798d71f952da9502d312719c88f3f">isBasePODNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7e22bcc4bf0a37cd4a702db373663503">isMeshNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac178e6f33f03b599753ac1692bcf3dce">isOpaque</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a239f148f08d434791a2cb52420c20698">isRunning</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a33c2efcf095df0b3bf42cddc0a758663">isSkeletonRigid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a82daff61037ecddfdb9591119ba0fbc9">isTouchable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9e76cd512d10b989d7f01095a81f47c1">isTouchEnabled</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ac2ed8acc0f14fb7a9abf24d706873b83">isTransformDirty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a277e1309c2aa9c2c4dc313497c1ce7e2">isTransformRigid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#afd9e3b759aaa56641df88a70e1ec07dc">isUniformlyScaledGlobally</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a212fe1cdd0af61fb5fbbe74be761d876">isUniformlyScaledLocally</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a4fd02187b1ee7884b9d0d8a19e413ae9">location</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_node_8h.html#a4bed21b96ced6e7ff2d912800ab99bba">CC3NormalScaling</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a49f80cf856a152e5c5a9f08efe15b0b1">normalScalingMethod</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLubyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7c97161a1d0bd50fb265bd390fab9247">opacity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a63b5b31888815554d7949288fb5d73e3">parent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#afe17f2234ab3bfdf9c2b70ae5510c0a8">parentTransformMatrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_performance_statistics.html">CC3PerformanceStatistics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a968396edac85926dcd809809220f0489">performanceStatistics</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6c1fd95973bf8c59172b834e622d072c">podContentIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a28cdeee0efde2485eb0af957901831e5">podParentIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9b45149a327a4c6968b4ddf6c3a569b8">projectedLocation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a8d2860d65aa974fe26a45d9d2d6cb286">projectedPosition</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ad7ece51255c6b553667de83a46fc2107">quaternion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a78c1dc69cd157d76184a077803d57df9">rootAncestor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a40bf4400c59a1c7dbe3040e32de5c2c5">rotation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a7df49fd1ba5f759e58cf941e6f6c5192">rotationAngle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#abe5011c1eb664c356e4a3a37f04d36b3">rotationAxis</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_rotator.html">CC3Rotator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a68c7cf1e11c447397006bdb8adbec4aa">rotator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3046c4ba3c92d526869f704243db5207">scale</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#abc2307e74e42c5c2d872e4c91b07bced">scaleTolerance</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa09d8bfdfd1a67eb94f108a984197dd8">shouldAllowTouchableWhenInvisible</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a452f578797e63d9a8fabd8e3fdb7d772">shouldAutoremoveWhenEmpty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3a212b8b1aaa572d0901b29f554d6712">shouldCleanupWhenRemoved</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a0a02ef76817887e925c9dc04c0e9826e">shouldCullBackFaces</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a890865bb4d5cf77011e4e3de7f3d1e17">shouldCullFrontFaces</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a26a30412b0a1de08a1baae7db25d0790">shouldDisableDepthMask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae14b782b005ee61d7c12a66669100a1d">shouldDisableDepthTest</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ae4262f42e7d2a599cf5cdf2d7a2edb6c">shouldDrawAllDescriptors</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5fcb4583de836b376bd11880c67d7598">shouldDrawAllLocalContentWireframeBoxes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a791e5a2fb4e409d23125af2e9fc3b9a0">shouldDrawAllWireframeBoxes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a98878a97ed2aeaa6cd809cd9596e91b4">shouldDrawDescriptor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6296e007b77e700dc737c733454dfa16">shouldDrawWireframeBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a6833d96291530bec5cdcdc62fc7dad43">shouldInheritTouchability</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a899c01b0e0a806669d7827112a275ddc">shouldUseClockwiseFrontFaceWinding</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab17442122bf69cf1f949c241cb229fe3">shouldUseFixedBoundingVolume</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a3cbea6e6582b701b52b7a64d37ce6aa6">shouldUseLighting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#adcf527d032102ac1750699662c0c753d">shouldUseSmoothShading</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a12ec9c3ae66471ffdc3eec5612cf4b4e">specularColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">NSString *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#af4f64f9bff8e82bd227b87368bdd6ae5">structureDescription</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#aa18700eb982dbcff8acbf70ce0f97b6c">touchableNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a5a4a4b22e76c0461c5bd3d5a25241660">transformMatrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#abfe250c04fe124bb7939f2f35171186f">transformMatrixInverted</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a112d11012a4d25e53e1cf431ea5c8469">uniformScale</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#ab8d92d79ffd98917bdcce43917eb87d5">visible</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_wireframe_bounding_box_node.html">CC3WireframeBoundingBoxNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a9ad12e8a7b4202e8cd152c64a31b70aa">wireframeBoxNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_world.html">CC3World</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#a43cfe3d4e71b1eaf276a54d6a65de15e">world</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_node.html#acbb29f8d02c53f72f48d45c673d33ce4">zOrder</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> and its subclasses form the basis of all 3D artifacts in the 3D world, including visible meshes, structures, cameras, lights, resources, and the 3D world itself. </p>
<p>Nodes can be moved, rotated and scaled. Rotation can be specified via either Euler angles or quaternions.</p>
<p>Nodes can be assembled in a structural hierarchy of parents and children, and transformations that are applied to a node are also applied to its descendant nodes. Typically, the root of a structural node hierarchy is an instance of <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>.</p>
<p>Each node is automatically touched at two distinct times during animation frame handling. First, the updateBeforeTransform: and updateAfterTransform: methods are each invoked during scheduled model state updating, before and after the transformation matrix of the node is rebuilt, respectively. You should override udpateBeforeTransform: method to make any changes to the node, or its child nodes.</p>
<p>You should override updateAfterTransform: only if you need to make use of the global properties of the node or its child nodes, such as globalLocation, globalRotation, or globalScale. These properties are valid only after the transformMatrix has been calculated, and are therefore not valid within the updateBeforeTransform: method. However, if you make any changes to the transform properties (location, rotation, scale) of a node within the updateAfterTransform: method, you must invoke the updateTransformMatrices method on that node in order to have the changes applied to the node's transformMatrix.</p>
<p>Note that you do NOT need to invoke the updateTransformMatrices method for any changes made in the updateBeforeTransform: method, since those changes will automatically be applied to the transformMatrix.</p>
<p>The second place a node is touched is, the transformAndDrawWithVisitor: method, which is automaticaly invoked during each frame rendering cycle. You should have no need to override this method.</p>
<p>To maximize throughput, the operations of updating model state should be kept separate from the operations of frame rendering, and the two should not be mixed. Subclasses should respect this design pattern when overriding behaviour. Drawing operations should not be included in state updating, and vice versa. Since OpenGL is a hardware-accelerated state-machine pipeline, this separation allows frame-drawing operations to be performed by the GPU at the same time that state update operations for the next frame are being handled by the CPU, and on some systems, permits frame drawing and model updating to be perfomed on separate threads.</p>
<p>CC3Nodes support the cocos2d CCAction class hierarchy. Nodes can be translated, rotated, and scaled in three dimensions, or made to point towards a direction (for cameras and lights), all under control of cocos2d CCActions. As with other CCActions, these actions can be combined into action sequences or repeating actions, or modified with cocos2d ease actions. See the class <a class="el" href="interface_c_c3_transform_to.html" title="CC3TransformTo is an abstract subclass of CCActionInterval that is the parent of subclasses that tran...">CC3TransformTo</a> and its subclasses for actions that operate on CC3Nodes.</p>
<p>When populating your world, you can easily create hordes of similar nodes using the copy and copyWithName: methods. Those methods effect deep copies to allow each copy to be manipulated independently, but will share underlying mesh data for efficient memory use. See the notes at the copy method for more details about copying nodes.</p>
<p>You can animate this class with animation data held in a subclass of <a class="el" href="interface_c_c3_node_animation.html" title="An instance of a subclass of CC3NodeAnimation manages the animation of nodes.">CC3NodeAnimation</a>. To animate this node using animation data, set the animation property to an instance of a subclass of the abstract <a class="el" href="interface_c_c3_node_animation.html" title="An instance of a subclass of CC3NodeAnimation manages the animation of nodes.">CC3NodeAnimation</a> class, populated with animation data, and then create an instance of a <a class="el" href="interface_c_c3_animate.html" title="A CCActionInterval that animates a CC3Node.">CC3Animate</a> action, and run it on this node.</p>
<p>Nodes can respond to iOS touch events. The property isTouchEnabled can be set to YES to allow a node to be selected by a touch event. If the shouldInheritTouchability property is also set to YES, then this touchable capability can also be inherited from a parent node. Selection of nodes based on touch events is handled by <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>. The nodeSelected:byTouchEvent:at: callback method of your customized <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> will be invoked to indicate which node has been touched.</p>
<p>The iOS and PVR hardware expects textures to have width and height values that are a power-of-two (POT). If you are using textures that do not have POT dimensions, they will be converted to POT by the texture loader. If the corresponding mesh was not created in your 3D editor with this taken into consideration, you might find that the texture does not completely cover the mesh as expected. If this situation arises, you can compensate with the alignTextures and alignInvertedTextures methods to realign the texture coordinate arrays with the textures.</p>
<p>You can cause a wireframe box to be drawn around the node and all its descendants by setting the shouldDrawWireframeBox property to YES. This can be particularly useful during development to locate the boundaries of a node, or to locate a node that is not drawing properly. You can set the default color of this wireframe using the class-side defaultWireframeBoxColor property.</p>
<p>To maximize GL throughput, all OpenGL ES 1.1 state is tracked by the singleton instance [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine]. <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> only sends state change calls to the GL engine if GL state really is changing. It is critical that all changes to GL state are made through the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton. When adding or overriding functionality in this framework, do NOT make gl* function calls directly if there is a corresponding state change tracker in the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton. Route the state change request through the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton instead. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a14386e095b6fa995faf1544dd09c8b1d"></a><!-- doxytag: member="CC3Node::addAndLocalizeChild:" ref="a14386e095b6fa995faf1544dd09c8b1d" args="(CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::addAndLocalizeChild: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the specified node as a direct child node to this node, and localizes the child node's location, rotation, and scale properties to this node. </p>
<p>This has the effect of leaving the global location, rotation and scale of the child node as they were, but re-homing the node to this parent. Visually, the node appears to stay in place, but will now move with the new parent, not with the old parent.</p>
<p>For instance, you might have an apple object whose overall intended global size and orientation you know, but you want that object to be added to a bowl, so that when you move the bowl, the apple moves with it. The bowl has likely been rotated and scaled, and raised onto a table, and you don't want your known apple to be transformed by the table and bowl when you add the apple to the bowl, You can use this method on the bowl object to add the apple, and reverse the table and bowl transforms for the apple, so that the apple will appear with its current size and orientation.</p>
<p>To do this, this method finds the appropriate location, rotation, and scale properties for the child node that will result in the globalLocation, globalRotation and globalScale properties remaining the same after it has been added to this parent node.</p>
<p>The child node is removed from its existing parent.</p>
<p>This method makes use of the transformMatrices of this node and the node being added. To ensure that both matrices are each up to date, this method invokes updateTransformMatrix method on both this node and the node being added. You can therefore invoke this method without having to consider whether the transformMatrix has been calculated already.</p>
<p>This method changes the transform properties of the node being added. If you are invoking this method from the updateBeforeTransform: of the node being added, this node, or any ancestor node (including your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>), the transformMatrix of the node being added (and its descendant nodes) will automatically be updated. However, if you are invoking this method from the updateAfterTransform: method, you should invoke the updateTransformMatrices method on the node being added after this method is finished, to ensure that the transform matrices are udpated. </p>

</div>
</div>
<a class="anchor" id="ae2e9f558c788f29f9107799cc6c1dde8"></a><!-- doxytag: member="CC3Node::addAxesDirectionMarkers" ref="ae2e9f558c788f29f9107799cc6c1dde8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::addAxesDirectionMarkers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds three visble direction marker lines, indicating the direction of the X, Y &amp; Z axes, in the local coordinate system of this node. </p>
<p>The lines extend from the pivot location of this node (the origin in this node's local coordinate system) to a location somewhat outside the node in the direction of each of the X, Y &amp; Z axes.</p>
<p>The lines are color-coded red, green and blue for the X, Y &amp; Z axes, respectively, as an easy (RGB &lt;=&gt; XYZ) mnemonic.</p>
<p>See the addDirectionMarkerColored:inDirection: method for more info. </p>

</div>
</div>
<a class="anchor" id="ac4d0746d13937340c19e38b1c04c3476"></a><!-- doxytag: member="CC3Node::addChild:" ref="ac4d0746d13937340c19e38b1c04c3476" args="(CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::addChild: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the specified node as a direct child node to this node. </p>
<p>The child node is automatically removed from its existing parent.</p>
<p>It is safe to invoke this method more than once for the same child node. This method does nothing if the child already has this node as its parent.</p>
<p>If you are invoking this method from the updateBeforeTransform: of the node being added, this node, or any ancestor node (including your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>), the transformMatrix of the node being added (and its descendant nodes) will automatically be updated. However, if you are invoking this method from the updateAfterTransform: method, you should invoke the updateTransformMatrices method on the node being added after this method is finished, to ensure that the transform matrices are udpated. </p>

</div>
</div>
<a class="anchor" id="aa930b2bc24563bfd1f635f8d833ba618"></a><!-- doxytag: member="CC3Node::addDirectionMarker" ref="aa930b2bc24563bfd1f635f8d833ba618" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::addDirectionMarker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a visble line, drawn in the color indicated by the directionMarkerColor class-side property, from the pivot location of this node (the origin in this node's local coordinate system) to a location somewhat outside the node in the direction kCC3VectorUnitZNegative, pointing down the negative Z-axis (which is the default direction in OpenGL). </p>
<p>For subclasses that use targetting, the line will point in the forwardDirection, which is the direction of the target location.</p>
<p>See the addDirectionMarkerColored:inDirection: method for more info. </p>

</div>
</div>
<a class="anchor" id="a5a5b607ec466a3fa89e5943c6f242cb9"></a><!-- doxytag: member="CC3Node::addDirectionMarkerColored:inDirection:" ref="a5a5b607ec466a3fa89e5943c6f242cb9" args="(ccColor4F aColor,[inDirection] CC3Vector aDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::addDirectionMarkerColored:inDirection: </td>
          <td>(</td>
          <td class="paramtype">ccColor4F&#160;</td>
          <td class="paramname"><em>aColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[inDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a visble line, drawn in the specified color, from the pivot location of this node (the origin in this node's local coordinate system) to a location somewhat outside the node in the specified direction. </p>
<p>The extent that the line will protrude from this node is proportional to the size of this node, as determined by the <a class="el" href="interface_c_c3_direction_marker_node.html" title="CC3DirectionMarkerNode is a type of CC3LineNode specialized for drawing a line from the pivot point o...">CC3DirectionMarkerNode</a> class-side directionMarkerScale property.</p>
<p>The line is drawn by creating and adding a <a class="el" href="interface_c_c3_direction_marker_node.html" title="CC3DirectionMarkerNode is a type of CC3LineNode specialized for drawing a line from the pivot point o...">CC3DirectionMarkerNode</a> as a child node to this node. The length of the child node is set from the boundingBox property of this node, so that the line protrudes somewhat from this node.</p>
<p>You can add more than one direction marker, and assign different colors to each.</p>
<p>This feature can be useful during development in helping to determine the rotational orientation of a 3D structural node.</p>
<p>By default, the child line node is not touchable, even if this node is touchable. If, for some reason you want the wireframe to be touchable, you can retrieve the direction marker nodes via the directionMarkers property, and set the isTouchEnabled property to YES. </p>

</div>
</div>
<a class="anchor" id="a5b69b89f01d7c98c0303f1e03d976558"></a><!-- doxytag: member="CC3Node::alignInvertedTextures" ref="a5b69b89f01d7c98c0303f1e03d976558" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::alignInvertedTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the texture coordinates held by a mesh in any descendant node with the textures held in the material of that mesh node. </p>
<p>The texture coordinates are aligned assuming that the texture is inverted in the Y-direction. Certain texture formats are inverted during loading, and this method can be used to compensate.</p>
<p>This method can be useful when the width and height of the textures in the material are not a power-of-two. Under iOS, when loading a texture that is not a power-of-two, the texture will be converted to a size whose width and height are a power-of-two. The result is a texture that can have empty space on the top and right sides. If the texture coordinates of the mesh do not take this into consideration, the result will be that only the lower left of the mesh will be covered by the texture.</p>
<p>When this occurs, invoking this method will adjust the texture coordinates of the mesh to map to the original width and height of the texturesa.</p>
<p>If the mesh is using multi-texturing, this method will adjust the texture coordinates array for each texture unit, using the corresponding texture for that texture unit in the specified material.</p>
<p>Care should be taken when using this method, as it affects all descendant nodes, and changes the actual vertex data. This method should only be invoked once on any mesh, and it may cause mapping conflicts if the same mesh is shared by other nodes that use different textures.</p>
<p>To adjust the texture coordinates of only a single mesh, invoke this method on that mesh node only, or invoke the alignWithInvertedTexturesIn: in the <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> within that mesh node. To adjust the texture coordinates of only a single texture coordinates array within a mesh, invoke the alignWithInvertedTexture: method on the appropriate instance of <a class="el" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices.">CC3VertexTextureCoordinates</a>. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a38e50d04d8d52734b33246590fdded38">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a6ba26fe792bf02227f68e7e22d3a56cb"></a><!-- doxytag: member="CC3Node::alignTextures" ref="a6ba26fe792bf02227f68e7e22d3a56cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::alignTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the texture coordinates held by a mesh in any descendant node with the textures held in the material of that mesh node. </p>
<p>This method can be useful when the width and height of the textures in the material are not a power-of-two. Under iOS, when loading a texture that is not a power-of-two, the texture will be converted to a size whose width and height are a power-of-two. The result is a texture that can have empty space on the top and right sides. If the texture coordinates of the mesh do not take this into consideration, the result will be that only the lower left of the mesh will be covered by the texture.</p>
<p>When this occurs, invoking this method will adjust the texture coordinates of the mesh to map to the original width and height of the textures.</p>
<p>If the mesh is using multi-texturing, this method will adjust the texture coordinates array for each texture unit, using the corresponding texture for that texture unit in the specified material.</p>
<p>Care should be taken when using this method, as it changes the actual vertex data. This method should only be invoked once on any mesh, and it may cause mapping conflicts if the same mesh is shared by other CC3MeshNodes that use different textures.</p>
<p>Care should be taken when using this method, as it affects all descendant nodes, and changes the actual vertex data. This method should only be invoked once on any mesh, and it may cause mapping conflicts if the same mesh is shared by other nodes that use different textures.</p>
<p>To adjust the texture coordinates of only a single mesh, invoke this method on that mesh node only, or invoke the alignWithTexturesIn: in the <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> within that mesh node. To adjust the texture coordinates of only a single texture coordinates array within a mesh, invoke the alignWithTexture: method on the appropriate instance of <a class="el" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices.">CC3VertexTextureCoordinates</a>. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a943e5c901a964ec7a421f7f38b7046de">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a5e0c8eb0c20c5eee0c4cc4384846ce08"></a><!-- doxytag: member="CC3Node::appendStructureDescriptionTo:withIndent:" ref="a5e0c8eb0c20c5eee0c4cc4384846ce08" args="(NSMutableString *desc,[withIndent] NSUInteger indentLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSString* CC3Node::appendStructureDescriptionTo:withIndent: </td>
          <td>(</td>
          <td class="paramtype">NSMutableString *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withIndent] NSUInteger&#160;</td>
          <td class="paramname"><em>indentLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the description of this node to the specified mutable string, on a new line and indented the specified number of levels. </p>
<p>Returns the specified mutable string, as a convenience. </p>

</div>
</div>
<a class="anchor" id="a012a06e674832b208b83d0b2c14235b7"></a><!-- doxytag: member="CC3Node::asCameraTracker" ref="a012a06e674832b208b83d0b2c14235b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>* <a class="el" href="interface_c_c3_node.html">CC3Node</a>(<a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>)::asCameraTracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps this node in an instance of <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a>, and returns the autoreleased <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a> instance. </p>
<p>This node appears as the lone child node of the returned targetting node.</p>
<p>Both the shouldTrackTarget and shouldAutotargetCamera properties of the returned targetting node are set to YES, indicating that the targetting node will automatically find the camera and always face it.</p>
<p>The shouldAutoremoveWhenEmpty property of the returned targetting node is set to YES, indicating that the targetting node will remove itself automatically from the node hierarchy when the last child node (likely this node) is removed from the targetting node. This assists in cleaning up nodes in the hierarchy by avoiding leaving empty wrapper nodes littering the hierarchy.</p>
<p>The <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a> instance will have the name "&lt;this node name&gt;-TargettingWrapper". </p>

</div>
</div>
<a class="anchor" id="ab568988d7fd88958b233974a540ec3a7"></a><!-- doxytag: member="CC3Node::asLightTracker" ref="ab568988d7fd88958b233974a540ec3a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>* <a class="el" href="interface_c_c3_node.html">CC3Node</a>(<a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>)::asLightTracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps this node in an instance of <a class="el" href="interface_c_c3_light_tracker.html" title="CC3LightTracker is a specialized CC3TargettingNode that tracks a target and automatically updates its...">CC3LightTracker</a>, and returns the autoreleased <a class="el" href="interface_c_c3_light_tracker.html" title="CC3LightTracker is a specialized CC3TargettingNode that tracks a target and automatically updates its...">CC3LightTracker</a> instance. </p>
<p>This node appears as the lone child node of the returned light tracker node.</p>
<p>The shouldTrackTarget property of the returned light tracker is set to YES, indicating and the tracker will always face whatever node is subsequently set in the target property.</p>
<p>The shouldAutoremoveWhenEmpty property of the returned targetting node is set to YES, indicating that the targetting node will remove itself automatically from the node hierarchy when the last child node (likely this node) is removed from the targetting node. This assists in cleaning up nodes in the hierarchy by avoiding leaving empty wrapper nodes littering the hierarchy.</p>
<p>The <a class="el" href="interface_c_c3_light_tracker.html" title="CC3LightTracker is a specialized CC3TargettingNode that tracks a target and automatically updates its...">CC3LightTracker</a> instance will have the name "&lt;this node name&gt;-LightTrackerWrapper". </p>

</div>
</div>
<a class="anchor" id="a194e5a2dae03a9d9536273f34b141c47"></a><!-- doxytag: member="CC3Node::asTargettingNode" ref="a194e5a2dae03a9d9536273f34b141c47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>* <a class="el" href="interface_c_c3_node.html">CC3Node</a>(<a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>)::asTargettingNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps this node in an instance of <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a>, and returns the autoreleased <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a> instance. </p>
<p>This node appears as the lone child node of the returned targetting node.</p>
<p>The <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a> instance will have the name "&lt;this node name&gt;-TargettingWrapper". </p>

</div>
</div>
<a class="anchor" id="a0141caa285eb8aef6de547765bceacc7"></a><!-- doxytag: member="CC3Node::asTracker" ref="a0141caa285eb8aef6de547765bceacc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>* <a class="el" href="interface_c_c3_node.html">CC3Node</a>(<a class="el" href="interface_c_c3_targetting_node.html">CC3TargettingNode</a>)::asTracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wraps this node in an instance of <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a>, and returns the autoreleased <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a> instance. </p>
<p>This node appears as the lone child node of the returned targetting node.</p>
<p>The shouldTrackTarget property of the returned targetting node is set to YES, indicating and the targetting node will always face whatever node is subsequently set in the target property.</p>
<p>The shouldAutoremoveWhenEmpty property of the returned targetting node is set to YES, indicating that the targetting node will remove itself automatically from the node hierarchy when the last child node (likely this node) is removed from the targetting node. This assists in cleaning up nodes in the hierarchy by avoiding leaving empty wrapper nodes littering the hierarchy.</p>
<p>The <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a> instance will have the name "&lt;this node name&gt;-TargettingWrapper". </p>

</div>
</div>
<a class="anchor" id="acaf3b104117af9ee7cfc8ed440bc5bbd"></a><!-- doxytag: member="CC3Node::bindRestPose" ref="acaf3b104117af9ee7cfc8ed440bc5bbd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_node.html">CC3Node</a>(Skinning)::bindRestPose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binds the rest pose of any skeletons contained within the descendants of this node. </p>
<p>This method must be invoked once the initial locations and rotations of each bone in the skeletons are set.</p>
<p>These initial bone orientations are those that align with the native structure of the vertices in the mesh, and collectively are known as the rest pose of the skeleton. Changes to the transform properties of the individual bone nodes, relative to the rest pose, will deform the mesh from its natural structure.</p>
<p>The bone transforms must be calculated locally from the perspective of the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> that contains a skeleton and skin mesh. This method should only be invoked on the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> or a structural ancestor of that node,</p>
<p>This implementation simply passes this invocation along to the children of this node. Subclasses contained in the soft-body node will add additional functionality. </p>

</div>
</div>
<a class="anchor" id="af97c6f748a3d85fd23a8a4c62e9decd8"></a><!-- doxytag: member="CC3Node::buildTransformMatrixWithVisitor:" ref="af97c6f748a3d85fd23a8a4c62e9decd8" args="(CC3NodeTransformingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::buildTransformMatrixWithVisitor: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_transforming_visitor.html">CC3NodeTransformingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Template method that recalculates the transform matrix of this node from the location, rotation and scale transformation properties, using the specified visitor. </p>
<p>This method is invoked automatically by the visitor. Usually the application never needs to invoke this method. </p>

</div>
</div>
<a class="anchor" id="a65611a362386a198f5037c953c5a8f7e"></a><!-- doxytag: member="CC3Node::checkDrawingOrder" ref="a65611a362386a198f5037c953c5a8f7e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::checkDrawingOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that the child nodes of this node are in the correct drawing order relative to other nodes. </p>
<p>This implementation forwards this request to all descendants. Those descendants with local content to draw will check their positions in the drawing sequence by passing this notification up the ancestor chain to the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>.</p>
<p>By default, nodes are automatically repositioned on each drawing frame to optimize the drawing order, so you should usually have no need to use this method.</p>
<p>However, in order to eliminate the overhead of checking each node during each drawing frame, you can disable this automatic behaviour by setting the allowSequenceUpdates property of specific drawing sequencers to NO.</p>
<p>In that case, if you modify the properties of a node or its content, such as mesh or material opacity, and your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> drawing sequencer uses that criteria to sort nodes, you can invoke this method to force the node to be repositioned in the correct drawing order.</p>
<p>You don't need to invoke this method when initially setting the properties. You only need to invoke this method if you modify the properties after the node has been added to the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, either by itself, or as part of a node assembly. </p>

<p>Implemented in <a class="el" href="interface_c_c3_local_content_node.html#ac8968cbf06cb1242f9dbbbaae139477f">CC3LocalContentNode</a>.</p>

</div>
</div>
<a class="anchor" id="a112737ec0e32b70af8504b54dda5fe90"></a><!-- doxytag: member="CC3Node::cleanup" ref="a112737ec0e32b70af8504b54dda5fe90" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops all running CCActions for this node and all descendant nodes. </p>
<p>Effectively invokes stopAllActions on this node and all descendant nodes. </p>

</div>
</div>
<a class="anchor" id="a7bda04af22d4853e65cbb1b2a7be0097"></a><!-- doxytag: member="CC3Node::copy" ref="a7bda04af22d4853e65cbb1b2a7be0097" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Node::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a newly allocated (retained) copy of this instance. </p>
<p>The new copy will have the same name as this node, but will have a unique tag.</p>
<p>The copying operation effects a deep copy. For any content that is held by reference (eg- objects), and subject to future modification, a copy is created, so that both this instance and the other instance can be treated independently. This includes child nodes, of which copies are created.</p>
<p>The following rules are applied when copying a node:</p>
<ul>
<li>The tag property is not copied. The tag is property is assigned and automatically generated unique tag value.</li>
<li>The copy will initially have no parent. It will automatically be set when this node is added as a child to a parent node.</li>
<li>Copies are created of all child nodes, using the copy method of each child. The child nodes of the new node will therefore have the same names as the child nodes of the original node.</li>
<li>Mesh data is copied by reference, not by value. Child nodes that support mesh data will assign it by reference when that child is copied. Mesh data is shared between both the original mesh node and copy node.</li>
</ul>
<p>Subclasses that extend content should honour the deep copy design pattern, making exceptions only for content that is both large and not subject to modifications, such as mesh data.</p>
<p>This method may often be used to duplicate a node many times, to create large number of similar instances to populate a game. To help you verify that you are correctly releasing and deallocating all these copies, you can use the instanceCount class method to get a current count of the total number of instances of all subclasses of <a class="el" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances...">CC3Identifiable</a>, When reviewing that number, remember that nodes are only one type of <a class="el" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances...">CC3Identifiable</a>, and other subclasses, such as materials, will contribute to this count. </p>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#ac177c497bf19de1f8208eb375edfef37">CC3Identifiable</a>.</p>

</div>
</div>
<a class="anchor" id="aec0fbbf1cbbbf174ec68f2322856db97"></a><!-- doxytag: member="CC3Node::copyWithName:" ref="aec0fbbf1cbbbf174ec68f2322856db97" args="(NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Node::copyWithName: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a newly allocated (retained) copy of this instance. </p>
<p>The new copy will have its name set to the specified name, and will have a unique tag.</p>
<p>The copying operation effects a deep copy. See the notes at the copy method for more details about copying nodes. </p>

<p>Implements <a class="el" href="interface_c_c3_identifiable.html#a2fc25bb52f8f0815c0985e02aeac0e35">CC3Identifiable</a>.</p>

</div>
</div>
<a class="anchor" id="aa1be5eb9f0e3e3f2513b5050e4d585f8"></a><!-- doxytag: member="CC3Node::createGLBuffers" ref="aa1be5eb9f0e3e3f2513b5050e4d585f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::createGLBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates OpenGL ES buffers to be used by the GL engine hardware. </p>
<p>Default behaviour is to invoke the same method on all child nodes. Subclasses that can make use of hardware buffering, notably mesh subclasses, will override and bind their data to GL hardware buffers.</p>
<p>Invoking this method is optional and is not performed automatically. If an application does not wish to use hardware buffering for some nodes, it can do so by avoiding the invocation of this method on those nodes. Typically, however, an applicaiton will simply invoke this method once during initialization of highest-level ancestor node (ususally a subclass of <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>). </p>

</div>
</div>
<a class="anchor" id="ada3f710a973e5f1dbe55fb1f36cd830d"></a><!-- doxytag: member="CC3Node::defaultScaleTolerance" ref="ada3f710a973e5f1dbe55fb1f36cd830d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Node::defaultScaleTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The default value used to set the initial value of the scaleTolerance property of new <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> instances. </p>
<p>The initial value of this property is zero, indicating that no tolerance is accepted. Each scaling component will only be considered to be unity if it is exactly equal to one, and scaling will only be considered to be uniform if all three components are exactly equal to each other. </p>

</div>
</div>
<a class="anchor" id="a0789463c8d3f49e650adbb3212353f2b"></a><!-- doxytag: member="CC3Node::deleteGLBuffers" ref="a0789463c8d3f49e650adbb3212353f2b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::deleteGLBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes any OpenGL buffers that were created by any child nodes via a prior invocation of createGLBuffers. </p>
<p>If the child nodes also retained the data locally, drawing will then revert to distinct GL draw calls, passing data through the GL API on each call, rather than via the bound buffers. </p>

</div>
</div>
<a class="anchor" id="aca18dcafe9eb909c1828835372e5dc38"></a><!-- doxytag: member="CC3Node::descriptorFontSize" ref="aca18dcafe9eb909c1828835372e5dc38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGFloat CC3Node::descriptorFontSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the font size that will be used when drawing the descriptor text when the shouldDrawDescriptor property is set to YES on any node. </p>
<p>The initial value of this class-side property is 14.0. </p>

</div>
</div>
<a class="anchor" id="ad9766013ea54fd0d093eb6c5eb622fb5"></a><!-- doxytag: member="CC3Node::directionMarkerColor" ref="ad9766013ea54fd0d093eb6c5eb622fb5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Node::directionMarkerColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the color that direction marker lines will be drawn in when created using the addDirectionMarker method. </p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new direction marker lines to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FRed. </p>

</div>
</div>
<a class="anchor" id="a82c485272397d436522a17cccaa8fdb3"></a><!-- doxytag: member="CC3Node::disableAllAnimation" ref="a82c485272397d436522a17cccaa8fdb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::disableAllAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables animation of this node, and all descendant nodes, from animation data held in the animation property of this node and each descendant node. </p>

</div>
</div>
<a class="anchor" id="ad73159b10aa52fe8089eb982bdbf5250"></a><!-- doxytag: member="CC3Node::disableAnimation" ref="ad73159b10aa52fe8089eb982bdbf5250" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::disableAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables animation of this node from animation data held in the animation property. </p>
<p>This will not disable animation of child nodes. </p>

</div>
</div>
<a class="anchor" id="a313faba92d4638b21ad6d02ba7ca6e95"></a><!-- doxytag: member="CC3Node::doesIntersectFrustum:" ref="a313faba92d4638b21ad6d02ba7ca6e95" args="(CC3Frustum *aFrustum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::doesIntersectFrustum: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_frustum.html">CC3Frustum</a> *&#160;</td>
          <td class="paramname"><em>aFrustum</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the local content of this node intersects the given frustum. </p>
<p>This check does not include checking children, only the local content.</p>
<p>This method is called during the drawing operations of each frame to determine whether this node should be culled from the visible nodes and not drawn. A return value of YES will cause the node to be drawn, a return value of NO will cause the node to be culled and not drawn.</p>
<p>Culling nodes that are not visible to the camera is an important performance enhancement. The node should strive to be as accurate as possible in returning whether it intersects the camera's frustum. Incorrectly returning YES will cause wasted processing within the GL engine. Incorrectly returning NO will cause a node that should at least be partially visible to not be drawn.</p>
<p>In this implementation, if this node has a boundingVolume, this method delegates to it. Otherwise, it simply returns YES. Subclasses may override to change this standard behaviour. </p>

</div>
</div>
<a class="anchor" id="a4073440a0b8f9c18533cbc5121649657"></a><!-- doxytag: member="CC3Node::doNotBufferVertexColors" ref="a4073440a0b8f9c18533cbc5121649657" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::doNotBufferVertexColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex color data of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex colors will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="a17688b23c1dea97ed7b7419bf4d3b789"></a><!-- doxytag: member="CC3Node::doNotBufferVertexIndices" ref="a17688b23c1dea97ed7b7419bf4d3b789" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::doNotBufferVertexIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex index data of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex indices will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="a1c776539f12809fbf268332920a7f21d"></a><!-- doxytag: member="CC3Node::doNotBufferVertexLocations" ref="a1c776539f12809fbf268332920a7f21d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::doNotBufferVertexLocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex location data of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex locations will not be buffered to a GL VBO. Any other vertex data, such as normals, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexLocations method. </p>

</div>
</div>
<a class="anchor" id="af3a1d834d261b862e7af1f7426c071d5"></a><!-- doxytag: member="CC3Node::doNotBufferVertexNormals" ref="af3a1d834d261b862e7af1f7426c071d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::doNotBufferVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex normal data of this node and all descendant nodes to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexNormals method. </p>

</div>
</div>
<a class="anchor" id="a388e8ab71dceb5b771695ce8785ac411"></a><!-- doxytag: member="CC3Node::doNotBufferVertexTextureCoordinates" ref="a388e8ab71dceb5b771695ce8785ac411" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::doNotBufferVertexTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate data of this node and all descendant nodes, for all texture units used by those nodes, to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex texture coordinates will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexTextureCoordinates method. </p>

</div>
</div>
<a class="anchor" id="a883c0a80269bd598483d19480b8276ec"></a><!-- doxytag: member="CC3Node::drawWithVisitor:" ref="a883c0a80269bd598483d19480b8276ec" args="(CC3NodeDrawingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::drawWithVisitor: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws the content of this node to the GL engine. </p>
<p>The specified visitor encapsulates the frustum of the currently active camera, and certain drawing options.</p>
<p>As described in the class documentation, in keeping with best practices, drawing and frame rendering should be kept separate from updating the model state. Therefore, when overriding this method in a subclass (or any of the template methods invoked by this method), do not update any model state. This method should perform only frame rendering operations.</p>
<p>This method is invoked automatically as part of the drawing operations initiated by the transformAndDrawWithVisitor: method. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a8a15c4a11e9d1075a623105fe81b96f9">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="ad3307a8e1d887ce258b8bd370d8799c5"></a><!-- doxytag: member="CC3Node::enableAllAnimation" ref="ad3307a8e1d887ce258b8bd370d8799c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::enableAllAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables animation of this node, and all descendant nodes, from animation data held in the animation property of this node and each descendant node. </p>

</div>
</div>
<a class="anchor" id="a3e99eb2ee98ebcb169f77a76aac19a08"></a><!-- doxytag: member="CC3Node::enableAnimation" ref="a3e99eb2ee98ebcb169f77a76aac19a08" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::enableAnimation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables animation of this node from animation data held in the animation property. </p>
<p>This will not enable animation of child nodes. </p>

</div>
</div>
<a class="anchor" id="a4adf77b1b7e0ac1f8fcb45213714405d"></a><!-- doxytag: member="CC3Node::establishAnimationFrameAt:" ref="a4adf77b1b7e0ac1f8fcb45213714405d" args="(ccTime t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::establishAnimationFrameAt: </td>
          <td>(</td>
          <td class="paramtype">ccTime&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the location, rotation and scale of this node based on the animation frame located at the specified time, which should be a value between zero and one, with zero indicating the first animation frame, and one indicating the last animation frame. </p>
<p>Only those properties of this node for which there is animation data will be changed.</p>
<p>This implementation delegates to the <a class="el" href="interface_c_c3_node_animation.html" title="An instance of a subclass of CC3NodeAnimation manages the animation of nodes.">CC3NodeAnimation</a> instance held in the animation property, then passes this notification along to child nodes to align them with the same animation frame. Linear interpolation of the frame data may be performed, based on the number of frames and the specified time.</p>
<p>If disableAnimation or disableAllAnimation has been invoked on this node, it will be excluded from animation, and this method will not have any affect on this node. However, this method will be propagated to child nodes.</p>
<p>This method is invoked automatically from an instance of <a class="el" href="interface_c_c3_animate.html" title="A CCActionInterval that animates a CC3Node.">CC3Animate</a> that is animating this node. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="aae71487c59c9183c237e11ce5910189e"></a><!-- doxytag: member="CC3Node::flatten" ref="aae71487c59c9183c237e11ce5910189e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCArray* CC3Node::flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an autoreleased array containing this node and all its descendants. </p>
<p>This is done by invoking flattenInto: with a newly-created array, and returning the array. </p>

</div>
</div>
<a class="anchor" id="aebd507bc13477ca1919d7ce762727600"></a><!-- doxytag: member="CC3Node::flattenInto:" ref="aebd507bc13477ca1919d7ce762727600" args="(CCArray *anArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::flattenInto: </td>
          <td>(</td>
          <td class="paramtype">CCArray *&#160;</td>
          <td class="paramname"><em>anArray</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds this node to the specified array, and then invokes this method on each child node. </p>
<p>The effect is to populate the array with this node and all its descendants. </p>

</div>
</div>
<a class="anchor" id="a3b7859bf10890a905ba5f1a1e3a8e8ba"></a><!-- doxytag: member="CC3Node::getActionByTag:" ref="a3b7859bf10890a905ba5f1a1e3a8e8ba" args="(int tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCAction* CC3Node::getActionByTag: </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets an action from the running action list given its tag. </p>

</div>
</div>
<a class="anchor" id="a42cd132329b6a2a98cf1456f3fe58275"></a><!-- doxytag: member="CC3Node::getNodeNamed:" ref="a42cd132329b6a2a98cf1456f3fe58275" args="(NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node.html">CC3Node</a>* CC3Node::getNodeNamed: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the first node found with the specified name, anywhere in the structural hierarchy of descendants of this node (not just direct children). </p>
<p>The hierarchy search is depth-first. </p>

</div>
</div>
<a class="anchor" id="a8f4927d3aca147fe0993ae4c29f6d9c1"></a><!-- doxytag: member="CC3Node::getNodeTagged:" ref="a8f4927d3aca147fe0993ae4c29f6d9c1" args="(GLuint aTag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node.html">CC3Node</a>* CC3Node::getNodeTagged: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the first node found with the specified tag, anywhere in the structural hierarchy of descendants of this node (not just direct children). </p>
<p>The hierarchy search is depth-first. </p>

</div>
</div>
<a class="anchor" id="afde494ed8885dc8873dfd104e1622394"></a><!-- doxytag: member="CC3Node::isDescendantOf:" ref="afde494ed8885dc8873dfd104e1622394" args="(CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isDescendantOf: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this node is a structural descendant (child, grandchild, etc) of the specified node. </p>

</div>
</div>
<a class="anchor" id="a34fa1a364640216ee61ab9d25471b147"></a><!-- doxytag: member="CC3Node::linkToPODNodes:" ref="a34fa1a364640216ee61ab9d25471b147" args="(CCArray *nodeArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_node.html">CC3Node</a>(PVRPOD)::linkToPODNodes: </td>
          <td>(</td>
          <td class="paramtype">CCArray *&#160;</td>
          <td class="paramname"><em>nodeArray</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create links to the nodes in the specified array. </p>
<p>This implementation attaches this node to its parent as identified by the podParentIndex property. Subclasses may override to perform other linking. </p>

</div>
</div>
<a class="anchor" id="abe610fe825b7adc7c427df840a521712"></a><!-- doxytag: member="CC3Node::markTransformDirty" ref="abe610fe825b7adc7c427df840a521712" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::markTransformDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that the transformation matrix is dirty and needs to be recalculated. </p>
<p>This method is invoked automatically as needed. Usually the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="ad6d70878798bce4171f1d4350c44d8a5"></a><!-- doxytag: member="CC3Node::node" ref="ad6d70878798bce4171f1d4350c44d8a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Node::node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a41a17bdf54960dc689a3b70977f86219"></a><!-- doxytag: member="CC3Node::nodeAtIndex:fromPODResource:" ref="a41a17bdf54960dc689a3b70977f86219" args="(int aPODIndex,[fromPODResource] CC3PODResource *aPODRez)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="interface_c_c3_node.html">CC3Node</a>(PVRPOD)::nodeAtIndex:fromPODResource: </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aPODIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromPODResource] <a class="el" href="interface_c_c3_p_o_d_resource.html">CC3PODResource</a> *&#160;</td>
          <td class="paramname"><em>aPODRez</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance from the data of this type at the specified index within the specified POD resource. </p>

</div>
</div>
<a class="anchor" id="aadece09770edf39fcf3624e417ba92ed"></a><!-- doxytag: member="CC3Node::nodePODStructAtIndex:fromPODResource:" ref="aadece09770edf39fcf3624e417ba92ed" args="(uint aPODIndex,[fromPODResource] CC3PODResource *aPODRez)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a> <a class="el" href="interface_c_c3_node.html">CC3Node</a>(PVRPOD)::nodePODStructAtIndex:fromPODResource: </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>aPODIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromPODResource] <a class="el" href="interface_c_c3_p_o_d_resource.html">CC3PODResource</a> *&#160;</td>
          <td class="paramname"><em>aPODRez</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the underlying SPODNode data structure from the specified resource, for the SPODNode at the specified index. </p>
<p>The returned pointer must be cast to SPODNode before accessing any internals of the data structure. </p>

</div>
</div>
<a class="anchor" id="aee98350cf8efb119effb2bb42537b420"></a><!-- doxytag: member="CC3Node::nodeWithName:" ref="aee98350cf8efb119effb2bb42537b420" args="(NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Node::nodeWithName: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified name and an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a13a146da2a8401c683cc5cdd3524a577"></a><!-- doxytag: member="CC3Node::nodeWithTag:" ref="a13a146da2a8401c683cc5cdd3524a577" args="(GLuint aTag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Node::nodeWithTag: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an unnamed autoreleased instance with the specified tag. </p>

</div>
</div>
<a class="anchor" id="ae7eec38a17f61714d1924669e556b530"></a><!-- doxytag: member="CC3Node::nodeWithTag:withName:" ref="ae7eec38a17f61714d1924669e556b530" args="(GLuint aTag,[withName] NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Node::nodeWithTag:withName: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withName] NSString *&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified tag and name. </p>

</div>
</div>
<a class="anchor" id="aea16e1b4f5d61972ae0997ae85d88835"></a><!-- doxytag: member="CC3Node::numberOfRunningActions" ref="aea16e1b4f5d61972ae0997ae85d88835" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CC3Node::numberOfRunningActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the numbers of actions that are running plus the ones that are scheduled to run (actions in actionsToAdd and actions arrays). </p>
<p>Composable actions are counted as 1 action. Example: If you are running 1 Sequence of 7 actions, it will return 1. If you are running 7 Sequences of 2 actions, it will return 7. </p>

</div>
</div>
<a class="anchor" id="aefaf0265e8b2f99e9ab38cef8694805c"></a><!-- doxytag: member="CC3Node::reattachBonesFrom:" ref="aefaf0265e8b2f99e9ab38cef8694805c" args="(CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_node.html">CC3Node</a>(Skinning)::reattachBonesFrom: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>After copying a skin mesh node, the newly created copy will still be influenced by the original skeleton. </p>
<p>The result is that both the original mesh and the copy will move and be deformed in tandem as the skeleton moves.</p>
<p>If you are creating a chorus line of dancing characters, this may be the effect you are after. However, if you are creating a squadron of similar, but independently moving characters, each skin mesh node copy should be controlled by a separate skeleton.</p>
<p>After creating a copy of the skeleton bone node assembly, you can use this method to attach the skin mesh node to the new skeleton. The node that is provided as the argument to this method is the root bone node of the skeleton, or a structural ancestor of the skeleton that does not also include the original skeleton as a descendant.</p>
<p>This method iterates through all the bones referenced by any descendant skin mesh nodes, and retrieves a bone with the same name from the structural descendants of the specified node.</p>
<p>When copying a <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> instance, this method is automatically invoked as part of the copying of the soft-body object, and you do not need to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="aed659e8d9413127d5d8e9c82828888fc"></a><!-- doxytag: member="CC3Node::rebuildBoundingVolume" ref="aed659e8d9413127d5d8e9c82828888fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::rebuildBoundingVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the shouldUseFixedBoundingVolume property is set to NO, this method forces the bounding volume to be rebuilt. </p>
<p>Otherwise, this method does nothing.</p>
<p>If this node has an underlying mesh, and you have changed the vertex locations in the mesh, you should invoke this method to ensure that the bounding volume is rebuilt to encompass the new vertex locations.</p>
<p>The bounding volume is automatically transformed as the node is transformed, so this method does NOT need to be invoked when the node is transformed (moved, rotated, or scaled). </p>

</div>
</div>
<a class="anchor" id="a88b275ed5a68b2d8a78712ff41d6acbc"></a><!-- doxytag: member="CC3Node::releaseRedundantData" ref="a88b275ed5a68b2d8a78712ff41d6acbc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::releaseRedundantData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Once the elements data has been buffered into a GL vertex buffer object (VBO) within the GL engine, via the createGLBuffer method, this method can be used to release the data in main memory that is now redundant from all meshes that have been buffered to the GL engine. </p>
<p>Invoking this method on a node will release from main memory any data within all descendant mesh nodes, that has successfully been copied to buffers in the GL engine. It is safe to invokde this method even if createGLBuffer has not been invoked, and even if VBO buffering was unsuccessful.</p>
<p>To exempt vertex data from release, invoke one or more of the following methods once on nodes for which data should be retained, before invoking this method:</p>
<ul>
<li>retainVertexLocations</li>
<li>retainVertexNormals</li>
<li>retainVertexColors</li>
<li>retainVertexTextureCoordinates</li>
<li>retainVertexIndices</li>
</ul>
<p>For example, sophisticated physics engines and collision detection algorithms may make use of vertex location data in main memory. Or a rippling texture animation might retain texture coordinate data in order to dyamically adjust the texture coordinate data.</p>
<p>Normally, you would invoke the retainVertex... methods on specific individual nodes, and then invoke this method on the parent node of a node assembly, or on the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>. </p>

</div>
</div>
<a class="anchor" id="ab638f5dbea673bc7b88dc311bf7ae470"></a><!-- doxytag: member="CC3Node::remove" ref="ab638f5dbea673bc7b88dc311bf7ae470" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method that removes this node from its structural hierarchy by simply invoking removeChild: on the parent of this node. </p>
<p>If the shouldCleanupWhenRemoved property of this node is set to YES, any CCActions running on this node will be stopped and removed. If the shouldCleanupWhenRemoved property of this node is set to NO, any CCActions running on that node will be paused, but not removed.</p>
<p>Stopping and removing CCActions is important because the actions running on a node retain links to the node. If the actions are simply paused, those links will be retained forever, potentially creating memory leaks of nodes that are invisibly retained by their actions.</p>
<p>By default, the shouldCleanupWhenRemoved property is set to YES, and all CCActions running on this node will be stopped and removed. If the shouldCleanupWhenRemoved is set to NO, it is up to you to clean up any running CCActions when you are done with this node. You can do this using either the stopAllActions or cleahup method.</p>
<p>During a node visitation run with a CCNodeVisitor, you should avoid using this method directly. The visitation process involves iterating through collections of child nodes, and removing a node during the iteration of a collection raises an error.</p>
<p>Instead, during a visitation run, you can use the requestRemovalOf: method on the visitor, which safely processes all removal requests once the full visitation run is complete. </p>

</div>
</div>
<a class="anchor" id="a0532b78d1036a404f8dd6d87b97d4e87"></a><!-- doxytag: member="CC3Node::removeAllChildren" ref="a0532b78d1036a404f8dd6d87b97d4e87" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all child nodes of this node. </p>

</div>
</div>
<a class="anchor" id="abae4e44bd04d192def8a432fe0bb397e"></a><!-- doxytag: member="CC3Node::removeAllDirectionMarkers" ref="abae4e44bd04d192def8a432fe0bb397e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::removeAllDirectionMarkers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all the direction marker child nodes that were previously added using the addDirectionMarkerColored:inDirection: and addDirectionMarker methods. </p>

</div>
</div>
<a class="anchor" id="aba8f89a7edb29eb961336837f4cf3dd5"></a><!-- doxytag: member="CC3Node::removeChild:" ref="aba8f89a7edb29eb961336837f4cf3dd5" args="(CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::removeChild: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified node as a direct child node to this node. </p>
<p>Does nothing if the specified node is not actually a child of this node.</p>
<p>If the shouldCleanupWhenRemoved property of the node being removed is set to YES, any CCActions running on that node will be stopped and removed. If the shouldCleanupWhenRemoved property of the node being removed is set to NO, any CCActions running on that node will be paused, but not removed.</p>
<p>Stopping and removing CCActions is important because the actions running on a node retain links to the node. If the actions are simply paused, those links will be retained forever, potentially creating memory leaks of nodes that are invisibly retained by their actions.</p>
<p>By default, the shouldCleanupWhenRemoved property is set to YES, and all CCActions running on the node being removed will be stopped and removed. If the shouldCleanupWhenRemoved is set to NO, it is up to you to clean up any running CCActions when you are done with the node. You can do this using either the stopAllActions or cleahup method.</p>
<p>If the shouldAutoremoveWhenEmpty property is YES, and the last child node is being removed, this node will invoke its own remove method to remove itself from the node hierarchy as well. See the notes for the shouldAutoremoveWhenEmpty property for more info on autoremoving when all child nodes have been removed. </p>

</div>
</div>
<a class="anchor" id="aae6580702191d386d7495c6801a016ce"></a><!-- doxytag: member="CC3Node::retainVertexColors" ref="aae6580702191d386d7495c6801a016ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::retainVertexColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex color data of this node and all descendant nodes to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex data after the data has been buffered to a GL VBO.</p>
<p>Only the vertex colors will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="af476409b656940fe8fd6e348b5b8b2be"></a><!-- doxytag: member="CC3Node::retainVertexIndices" ref="af476409b656940fe8fd6e348b5b8b2be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::retainVertexIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex index data of this node and all descendant nodes to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex data after the data has been buffered to a GL VBO.</p>
<p>Only the vertex indices will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a99cdb8a721320e3b4aa237389eeb117a"></a><!-- doxytag: member="CC3Node::retainVertexLocations" ref="a99cdb8a721320e3b4aa237389eeb117a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::retainVertexLocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex location data of this node and all descendant nodes to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex data after the data has been buffered to a GL VBO.</p>
<p>Only the vertex locations will be retained. Any other vertex data, such as normals, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a41dc7d2c118673a0690be00d450094ab"></a><!-- doxytag: member="CC3Node::retainVertexNormals" ref="a41dc7d2c118673a0690be00d450094ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::retainVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex normal data of this node and all descendant nodes to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex data after the data has been buffered to a GL VBO.</p>
<p>Only the vertex normals will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a3f757942e44ce601a9d72eedca5a1f2a"></a><!-- doxytag: member="CC3Node::retainVertexTextureCoordinates" ref="a3f757942e44ce601a9d72eedca5a1f2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::retainVertexTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate data of this node and all descendant nodes, for all texture units, used by this mesh to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Use this method if you require access to vertex data after the data has been buffered to a GL VBO.</p>
<p>Only the vertex texture coordinates will be retained. Any other vertex data, such as locations, or normals, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="ae31dc98fcd8cf5cfe08414ffd1d221e6"></a><!-- doxytag: member="CC3Node::rotateBy:" ref="ae31dc98fcd8cf5cfe08414ffd1d221e6" args="(CC3Vector aRotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::rotateBy: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aRotation</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this node from its current rotational state by the specified Euler angles in degrees. </p>
<p>The incoming Euler angles specify the amount of change in rotation, not the final rotational state. </p>

</div>
</div>
<a class="anchor" id="a9d49f8a0bc739861bc44ca4ad1e9ffdc"></a><!-- doxytag: member="CC3Node::rotateByAngle:aroundAxis:" ref="a9d49f8a0bc739861bc44ca4ad1e9ffdc" args="(GLfloat anAngle,[aroundAxis] CC3Vector anAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::rotateByAngle:aroundAxis: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>anAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[aroundAxis] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>anAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this node from its current rotational state by rotating around the specified axis by the specified angle in degrees. </p>
<p>The incoming axis and angle specify the amount of change in rotation, not the final rotational state.</p>
<p>Thanks to cocos3d user nt901 for contributing to the development of this feature </p>

</div>
</div>
<a class="anchor" id="aa66db6ffa7347b7fbe8afa73c4e51f91"></a><!-- doxytag: member="CC3Node::rotateByQuaternion:" ref="aa66db6ffa7347b7fbe8afa73c4e51f91" args="(CC3Vector4 aQuaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::rotateByQuaternion: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td>
          <td class="paramname"><em>aQuaternion</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this node from its current rotational state by the specified quaternion. </p>
<p>The incoming quaternion specifies the amount of change in rotation, not the final rotational state. </p>

</div>
</div>
<a class="anchor" id="a88bc1389a0a31d1684f197ed50e24677"></a><!-- doxytag: member="CC3Node::runAction:" ref="a88bc1389a0a31d1684f197ed50e24677" args="(CCAction *action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCAction* CC3Node::runAction: </td>
          <td>(</td>
          <td class="paramtype">CCAction *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executes an action, and returns the action that is executed. </p>
<p>The node becomes the action's target. </p>

</div>
</div>
<a class="anchor" id="a1b88fcdbe55ee1f3225cea1857841a17"></a><!-- doxytag: member="CC3Node::setDefaultScaleTolerance:" ref="a1b88fcdbe55ee1f3225cea1857841a17" args="(GLfloat aTolerance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::setDefaultScaleTolerance: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>aTolerance</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the default value used to set the initial value of the property of new <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> instances. </p>
<p>The initial value of this property is zero, indicating that no tolerance is accepted. Each scaling component will only be considered to be unity if it is exactly equal to one, and scaling will only be considered to be uniform if all three components are exactly equal to each other. </p>

</div>
</div>
<a class="anchor" id="a9d4305b124b27d89d50b859f9ebff784"></a><!-- doxytag: member="CC3Node::setDescriptorFontSize:" ref="a9d4305b124b27d89d50b859f9ebff784" args="(CGFloat fontSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::setDescriptorFontSize: </td>
          <td>(</td>
          <td class="paramtype">CGFloat&#160;</td>
          <td class="paramname"><em>fontSize</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the font size that will be used when drawing the descriptor text when the shouldDrawDescriptor property is set to YES on any node. </p>
<p>The initial value of this class-side property is 14.0. </p>

</div>
</div>
<a class="anchor" id="a4ba164580d0895194fbf3a5b859ecb60"></a><!-- doxytag: member="CC3Node::setDirectionMarkerColor:" ref="a4ba164580d0895194fbf3a5b859ecb60" args="(ccColor4F aColor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::setDirectionMarkerColor: </td>
          <td>(</td>
          <td class="paramtype">ccColor4F&#160;</td>
          <td class="paramname"><em>aColor</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color that direction marker lines will be drawn in when created using the addDirectionMarker method. </p>
<p>Changing this property will affect the color of any new direction marker lines created. It does not affect any existing direction marker lines.</p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new direction marker lines to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FRed. </p>

</div>
</div>
<a class="anchor" id="ae69fcaf11981b068bcdc8963639c7317"></a><!-- doxytag: member="CC3Node::setWireframeBoxColor:" ref="ae69fcaf11981b068bcdc8963639c7317" args="(ccColor4F aColor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::setWireframeBoxColor: </td>
          <td>(</td>
          <td class="paramtype">ccColor4F&#160;</td>
          <td class="paramname"><em>aColor</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color that wireframes will be drawn in when created using the shouldDrawWireframeBox property. </p>
<p>Changing this property will affect the color of any new wireframe bounding boxes created. It does not affect any instances that already have a wireframe bounding box established.</p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new wireframe bounding boxes to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FYellow. </p>

</div>
</div>
<a class="anchor" id="a5491e5b27a1c2c241cbc0389a1c25ed8"></a><!-- doxytag: member="CC3Node::stopAction:" ref="a5491e5b27a1c2c241cbc0389a1c25ed8" args="(CCAction *action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::stopAction: </td>
          <td>(</td>
          <td class="paramtype">CCAction *&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an action from the running action list. </p>

</div>
</div>
<a class="anchor" id="a77d78c07263fb63bac5870f613120ab2"></a><!-- doxytag: member="CC3Node::stopActionByTag:" ref="a77d78c07263fb63bac5870f613120ab2" args="(int tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::stopActionByTag: </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an action from the running action list given its tag. </p>

</div>
</div>
<a class="anchor" id="a6b01f39758bd6f3f8e906b7a2fb0e6b3"></a><!-- doxytag: member="CC3Node::stopAllActions" ref="a6b01f39758bd6f3f8e906b7a2fb0e6b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::stopAllActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all actions from the running action list. </p>

</div>
</div>
<a class="anchor" id="ab82ef9ad2019facf5e9abce84ab60407"></a><!-- doxytag: member="CC3Node::touchDisableAll" ref="ab82ef9ad2019facf5e9abce84ab60407" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::touchDisableAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the isTouchEnabled property to NO on this node and all descendant nodes. </p>
<p>This is a convenience method that will make this node and all its decendants unresponsive to touches. For more info see the notes for the isTouchEnabled and touchableNode properties. </p>

</div>
</div>
<a class="anchor" id="aa67c8b5f44c53322c4eebc9f5254cf61"></a><!-- doxytag: member="CC3Node::touchEnableAll" ref="aa67c8b5f44c53322c4eebc9f5254cf61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::touchEnableAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the isTouchEnabled property to YES on this node and all descendant nodes. </p>
<p>This is a convenience method that will make all descendants individually touchable and selectable, which is not usually what is wanted. Usually, you would set isTouchEnabled on specific parent nodes that are of interest to select a sub-assembly as a whole. However, making all components individually selectable can sometimes be desired, and is useful for testing.</p>
<p>For more info see the notes for the isTouchEnabled and touchableNode properties.</p>
<p>This is a convenience method that can find use in testing, where it might be of interest to be able to individually select small components of a larger assembly. </p>

</div>
</div>
<a class="anchor" id="a422d97fc205cb37b3386424a19d7fa83"></a><!-- doxytag: member="CC3Node::transformAndDrawWithVisitor:" ref="a422d97fc205cb37b3386424a19d7fa83" args="(CC3NodeDrawingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::transformAndDrawWithVisitor: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Template method that applies this node's transform matrix to the GL matrix stack and draws this node using the specified visitor. </p>
<p>This method is invoked by the drawing visitor when it visits the node, if all of the following conditions are met by this node:</p>
<ul>
<li>ths node is visible (as indicated by the visible property)</li>
<li>has content to draw (as indicated by the hasLocalContent property)</li>
<li>intersects the camera's frustum (which is checked by invoking the method doesIntersectFrustum: of this node with the frustum from the visitor).</li>
</ul>
<p>If all of these tests pass, drawing is required, and this method transforms and draws the local content of this node.</p>
<p>This method is automatically invoked from the visitor. The application should never have need to used this method. </p>

</div>
</div>
<a class="anchor" id="a731c3aeca363031bbabe0d5a871d94cd"></a><!-- doxytag: member="CC3Node::transformVisitorClass" ref="a731c3aeca363031bbabe0d5a871d94cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Node::transformVisitorClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the class of visitor that will automatically be instantiated when visiting this node to transform, without updating. </p>
<p>The returned class must be a subclass of <a class="el" href="interface_c_c3_node_transforming_visitor.html" title="CC3NodeTransformingVisitor is a CC3NodeVisitor that is passed to a node when it is visited during tra...">CC3NodeTransformingVisitor</a>. This implementation returns <a class="el" href="interface_c_c3_node_transforming_visitor.html" title="CC3NodeTransformingVisitor is a CC3NodeVisitor that is passed to a node when it is visited during tra...">CC3NodeTransformingVisitor</a>. Subclasses may override to customize the behaviour of the updating visits. </p>

</div>
</div>
<a class="anchor" id="ac184ae5d67268b69539f89d90ac04676"></a><!-- doxytag: member="CC3Node::translateBy:" ref="ac184ae5d67268b69539f89d90ac04676" args="(CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::translateBy: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates the location of this node by the specified vector. </p>
<p>The incoming vector specify the amount of change in location, not the final location. </p>

</div>
</div>
<a class="anchor" id="a3c74947cca4fdd39d89ea8cdf6e48dca"></a><!-- doxytag: member="CC3Node::updateAfterTransform:" ref="a3c74947cca4fdd39d89ea8cdf6e48dca" args="(CC3NodeUpdatingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::updateAfterTransform: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This template method is invoked periodically whenever the 3D nodes are to be updated. </p>
<p>This method provides this node with an opportunity to perform update activities after the transformMatrix of the node has been recalculated. The similar and complimentary method updateBeforeTransform: is automatically invoked before the transformMatrix has been recalculated.</p>
<p>The global transform properties of a node (globalLocation, globalRotation, globalScale) will have accurate values when this method is run, since they are only valid after the transformMatrix has been updated. If you need to make use of the global properties of a node (such as for collision detection), override this method.</p>
<p>Since the transformMatrix has already been updated when this method is invoked, if you override this method and make any changes to the transform properties (location, rotation, scale) of any node, you should invoke the updateTransformMatrices method of that node, to have its transformMatrix, and those of its child nodes, recalculated.</p>
<p>This abstract template implementation does nothing. Subclasses that need access to their global transform properties will override accordingly. Subclasses that override do not need to invoke this superclass implementation. Nor do subclasses need to invoke this method on their child nodes. That is performed automatically.</p>
<p>The specified visitor encapsulates the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance, to allow this node to interact with other nodes in its world.</p>
<p>The visitor also encapsulates the deltaTime, which is the interval, in seconds, since the previous update. This value can be used to create realistic real-time motion that is independent of specific frame or update rates. Depending on the setting of the maxUpdateInterval property of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance, the value of dt may be clamped to an upper limit before being passed to this method. See the description of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> maxUpdateInterval property for more information about clamping the update interval.</p>
<p>If you wish to remove this node during an update visitation, avoid invoking the remove method on the node from this method. The visitation process involves iterating through collections of child nodes, and removing a node during the iteration of a collection raises an error. Instead, you can use the requestRemovalOf: method on the visitor, which safely processes all removal requests once the full visitation run is complete.</p>
<p>As described in the class documentation, in keeping with best practices, updating the model state should be kept separate from frame rendering. Therefore, when overriding this method in a subclass, do not perform any drawing or rending operations. This method should perform model updates only.</p>
<p>This method is invoked automatically at each scheduled update. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="ab33607fc5db4c079ebfb42d9da5acbea"></a><!-- doxytag: member="CC3Node::updateBeforeTransform:" ref="ab33607fc5db4c079ebfb42d9da5acbea" args="(CC3NodeUpdatingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::updateBeforeTransform: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This template method is invoked periodically whenever the 3D nodes are to be updated. </p>
<p>This method provides this node with an opportunity to perform update activities before any changes are applied to the transformMatrix of the node. The similar and complimentary method updateAfterTransform: is automatically invoked after the transformMatrix has been recalculated. If you need to make changes to the transform properties (location, rotation, scale) of the node, or any child nodes, you should override this method to perform those changes.</p>
<p>The global transform properties of a node (globalLocation, globalRotation, globalScale) will not have accurate values when this method is run, since they are only valid after the transformMatrix has been updated. If you need to make use of the global properties of a node (such as for collision detection), override the udpateAfterTransform: method instead, and access those properties there.</p>
<p>This abstract template implementation does nothing. Subclasses that act predictively, such as those undergoing trajectories or IPO curves can update their properties accordingly. Subclasses that override do not need to invoke this superclass implementation. Nor do subclasses need to invoke this method on their child nodes. That is performed automatically.</p>
<p>The specified visitor encapsulates the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance, to allow this node to interact with other nodes in its world.</p>
<p>The visitor also encapsulates the deltaTime, which is the interval, in seconds, since the previous update. This value can be used to create realistic real-time motion that is independent of specific frame or update rates. Depending on the setting of the maxUpdateInterval property of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance, the value of dt may be clamped to an upper limit before being passed to this method. See the description of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> maxUpdateInterval property for more information about clamping the update interval.</p>
<p>If you wish to remove this node during an update visitation, avoid invoking the remove method on the node from this method. The visitation process involves iterating through collections of child nodes, and removing a node during the iteration of a collection raises an error. Instead, you can use the requestRemovalOf: method on the visitor, which safely processes all removal requests once the full visitation run is complete.</p>
<p>As described in the class documentation, in keeping with best practices, updating the model state should be kept separate from frame rendering. Therefore, when overriding this method in a subclass, do not perform any drawing or rending operations. This method should perform model updates only.</p>
<p>This method is invoked automatically at each scheduled update. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="aad700ea837bfc1a3116d65b4d706dd1b"></a><!-- doxytag: member="CC3Node::updateTransformMatrices" ref="aad700ea837bfc1a3116d65b4d706dd1b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::updateTransformMatrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the transform properties (location, rotation, scale) to the transformMatrix of this node, and all descendant nodes. </p>
<p>To ensure that the transforms are accurately applied, this method also automatically ensures that the transform matrices of any ancestor nodes are also updated, if needed, before updating this node and its descendants.</p>
<p>Equivalent behaviour is invoked automatically during scheduled update processing between the invocations of the updateBeforeTransform: and updateAfterTransform: methods.</p>
<p>Changes that you make to the transform properties within the updateBeforeTransform: method will automatically be applied to the transformMatrix of the node. Because of this, it's best to make any changes to the transform properties in that method.</p>
<p>However, if you need to make changes to the transform properties in the updateAfterTransform: method of a node, after you have made all your changes to the node properties, you should then invoke this method on the node, in order to have those changes applied to the transformMatrix.</p>
<p>Similarly, if you have updated the transform properties of this node asynchronously through an event callback, and want those changes to be immediately reflected in the transform matrices, you can use this method to do so. </p>

</div>
</div>
<a class="anchor" id="aca3ae47f66bacb1c171d37a5ee4458db"></a><!-- doxytag: member="CC3Node::updateTransformMatrix" ref="aca3ae47f66bacb1c171d37a5ee4458db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::updateTransformMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the transform properties (location, rotation, scale) to the transformMatrix of this node, but NOT to any descendant nodes. </p>
<p>To ensure that the transforms are accurately applied, this method also automatically ensures that the transform matrices of any ancestor nodes are also updated, if needed, before updating this node and its descendants.</p>
<p>Use this method only when you know that you only need the transformMatrix of the specific node updated, and not the matrices of the decendants of that node, or if you will manually update the transformMatrices of the descendant nodes. If in doubt, use the updateTransformMatrices method instead. </p>

</div>
</div>
<a class="anchor" id="ae728eca9485726ddd19641aa6750fc07"></a><!-- doxytag: member="CC3Node::wasRemoved" ref="ae728eca9485726ddd19641aa6750fc07" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Node::wasRemoved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Template method that is invoked automatically when this node is removed from its parent node. </p>
<p>This implementation sets the isRunning property to NO. It also checks the value of the shouldCleanupWhenRemoved property and, if it is set to YES, stops and removes any CCActions running on this node. </p>

</div>
</div>
<a class="anchor" id="a95bebe8af43ea7f80e5a6d8c1a333c09"></a><!-- doxytag: member="CC3Node::wireframeBoxColor" ref="a95bebe8af43ea7f80e5a6d8c1a333c09" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Node::wireframeBoxColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the color that wireframe bounding boxes will be drawn in when created using the shouldDrawWireframeBox property. </p>
<p>Setting this property to kCCC4FBlackTransparent will cause the color of any new wireframe bounding boxes to be set to the value of the color property of the node instead.</p>
<p>The initial value of this class property is kCCC4FYellow. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a6c93e6c1c60cf0757df9bd33cdc09fbb"></a><!-- doxytag: member="CC3Node::activeCamera" ref="a6c93e6c1c60cf0757df9bd33cdc09fbb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_camera.html">CC3Camera</a>* CC3Node::activeCamera<code> [read, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this node has been added to the 3D world, either directly, or as part of a node assembly, returns the activeCamera property of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance, as accessed via the world property, otherwise returns nil. </p>
<p>Reading this property traverses up the node hierarchy. If this property is accessed frequently, it is recommended that it be cached. </p>

<p>Implemented in <a class="el" href="interface_c_c3_world.html#a60c88e4c67cd30393e5d5612dd4259c6">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="a87fc1dcd7533a6d9f29564116ab7d3fe"></a><!-- doxytag: member="CC3Node::ambientColor" ref="a87fc1dcd7533a6d9f29564116ab7d3fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Node::ambientColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ambient color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes.</p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a9386e779eac298341f6516010931b514">CC3MeshNode</a>, and <a class="el" href="interface_c_c3_light.html#a3ab57af7eba4f8816712b6c87365051a">CC3Light</a>.</p>

</div>
</div>
<a class="anchor" id="a1bf395d66179ab8f968d642dd4998eef"></a><!-- doxytag: member="CC3Node::animation" ref="a1bf395d66179ab8f968d642dd4998eef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_animation.html">CC3NodeAnimation</a> * CC3Node::animation<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The animation content of this node, which manages animating the node under the direction of a <a class="el" href="interface_c_c3_animate.html" title="A CCActionInterval that animates a CC3Node.">CC3Animate</a> action. </p>
<p>To animate this node, set this property to an instance of a subclass of the abstract <a class="el" href="interface_c_c3_node_animation.html" title="An instance of a subclass of CC3NodeAnimation manages the animation of nodes.">CC3NodeAnimation</a> class, populated with animation data, and then create an instance of a <a class="el" href="interface_c_c3_animate.html" title="A CCActionInterval that animates a CC3Node.">CC3Animate</a> action, and run it on this node. </p>

</div>
</div>
<a class="anchor" id="af98fb62a333ea1cc0fdbe4d401c0e2aa"></a><!-- doxytag: member="CC3Node::blendFunc" ref="af98fb62a333ea1cc0fdbe4d401c0e2aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccBlendFunc CC3Node::blendFunc<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCBlendProtocol blendFunc property. </p>
<p>This is a convenience property that gets and sets the same property of the material of all descendant nodes</p>
<p>Querying this property returns the value of the same property from the first descendant node that supports materials, or {GL_ONE, GL_ZERO} if no descendant nodes support materials. Setting this property sets the same property on the materials in all descendant nodes. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a0014822499c656bc65edffcc1ddeb032">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a1aa866559f901e646c7cb1798e1113ec"></a><!-- doxytag: member="CC3Node::boundingBox" ref="a1aa866559f901e646c7cb1798e1113ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a> CC3Node::boundingBox<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the smallest axis-aligned bounding box that surrounds any local content of this node, plus all descendants of this node. </p>
<p>The returned bounding box is specfied in the local coordinate system of this node.</p>
<p>Returns kCC3BoundingBoxNull if this node has no local content or descendants.</p>
<p>Since the bounding box of a node can change based on the locations, rotations, or scales of any descendant node, this property is measured dynamically on each access, by traversing all descendant nodes. This is a computationally expensive method. </p>

</div>
</div>
<a class="anchor" id="afc68b65e37320813d43dba734ec8e381"></a><!-- doxytag: member="CC3Node::boundingVolume" ref="afc68b65e37320813d43dba734ec8e381" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a> * CC3Node::boundingVolume<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The bounding volume of this node. </p>
<p>This may be used by culling during drawing operations, or by physics simulations. Different shapes of boundaries are available, permitting tradeoffs between accuracy and computational processing time.</p>
<p>By default, nodes do not have a bounding volume. Subclasses may set a suitable bounding volume. </p>

</div>
</div>
<a class="anchor" id="a7733dc8471757b6109d86e7fb688cbf7"></a><!-- doxytag: member="CC3Node::boundingVolumePadding" ref="a7733dc8471757b6109d86e7fb688cbf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Node::boundingVolumePadding<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Padding that is added to all edges of the bounding volume, when the bounding volume is automatically calculated, to ensure that all content is within the bounding volume. </p>
<p>The initial value of this property is zero. </p>

</div>
</div>
<a class="anchor" id="a9f8e8744313f6ffa67116db7f92fda9a"></a><!-- doxytag: member="CC3Node::children" ref="a9f8e8744313f6ffa67116db7f92fda9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCArray * CC3Node::children<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The child nodes of this node, in a node structural hierarchy. </p>

</div>
</div>
<a class="anchor" id="a03aece3103f5751908dfda571a5a4145"></a><!-- doxytag: member="CC3Node::color" ref="a03aece3103f5751908dfda571a5a4145" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor3B CC3Node::color<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCRGBAProtocol color property. </p>
<p>Setting this property sets the same property on all child nodes.</p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a06c3e0690e2999a93919ba2d28e29193">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="ad5fcdcec31ea7f5020dbfc322a547a0d"></a><!-- doxytag: member="CC3Node::containsAnimation" ref="ad5fcdcec31ea7f5020dbfc322a547a0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::containsAnimation<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node, or any of its descendants, contains an instance of an animation. </p>

</div>
</div>
<a class="anchor" id="a8b5a7a014ef8c5297a0d2a5a74442316"></a><!-- doxytag: member="CC3Node::depthFunction" ref="a8b5a7a014ef8c5297a0d2a5a74442316" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum CC3Node::depthFunction<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The depth function used by the GL engine when comparing the Z-distance of this node against previously drawn content. </p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>This property must be set to one of the following values:</p>
<ul>
<li>GL_LESS - the content of this node will be drawn if it is closer to the camera than previously drawn content.</li>
<li>GL_LEQUAL - the content of this node will be drawn if it is at least as close to the camera as previously drawn content.</li>
<li>GL_EQUAL - the content of this node will be drawn if it is exactly as close to the camera as previously drawn content.</li>
<li>GL_GEQUAL - the content of this node will be drawn if it is at least as far away from the camera as previously drawn content.</li>
<li>GL_GREATER - the content of this node will be drawn if it is farther away from the camera than previously drawn content.</li>
<li>GL_NOTEQUAL - the content of this node will be drawn if it is not exactly as close to the camera as previously drawn content.</li>
<li>GL_ALWAYS - the content of this node will always be drawn</li>
<li>GL_NEVER - the content of this node will not be drawn</li>
</ul>
<p>The initial value of this property is GL_LEQUAL. In most cases, to draw an accurate scene, this value is the most suitable. However, some special cases, including some particle emitters, may benefit from the use of one of the other depth functions.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns the value of this property from the first descendant mesh node, or will return GL_NEVER if no mesh node are found in the descendants of this node. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#ab4521a811bbadf0fc5077d70e2b696f4">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="ae7dedd671475792c90a14ba94f867d6d"></a><!-- doxytag: member="CC3Node::descriptorNode" ref="ae7dedd671475792c90a14ba94f867d6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_descriptor.html">CC3NodeDescriptor</a>* CC3Node::descriptorNode<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the shouldDrawDescriptor is set to YES, returns the child node that draws the descriptor text on this node. </p>
<p>Otherwise, returns nil. </p>

</div>
</div>
<a class="anchor" id="a0bb07b8079bf75af208434b5360cc58b"></a><!-- doxytag: member="CC3Node::diffuseColor" ref="a0bb07b8079bf75af208434b5360cc58b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Node::diffuseColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The diffuse color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes.</p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a1c4476ee10e9dad251c00b0723ef7ba7">CC3MeshNode</a>, and <a class="el" href="interface_c_c3_light.html#a91b08c3c6f18db7e0dd1ce22e8a2f57f">CC3Light</a>.</p>

</div>
</div>
<a class="anchor" id="a619d2afdf429d6cf4fba13008d7d6372"></a><!-- doxytag: member="CC3Node::directionMarkers" ref="a619d2afdf429d6cf4fba13008d7d6372" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCArray* CC3Node::directionMarkers<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an array of all the direction marker child nodes that were previously added using the addDirectionMarkerColored:inDirection: and addDirectionMarker methods. </p>

</div>
</div>
<a class="anchor" id="a3aed7fbdc1d3807d2da7d46ec3aee096"></a><!-- doxytag: member="CC3Node::dirtiestAncestor" ref="a3aed7fbdc1d3807d2da7d46ec3aee096" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node.html">CC3Node</a>* CC3Node::dirtiestAncestor<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the heighest node in my ancestor hierarchy, including myself, that is dirty. </p>
<p>Returns nil if neither myself nor any of my ancestors are dirty.</p>
<p>This method can be useful when deciding at what level to update a hierarchy.</p>
<p>This method is invoked automatically by the updateTransformMatrices and updateTransformMatrix, so in most cases, you do not need to use this method directly. However, there may be special cases where you want to determine beforehand whether this node or its ancestors are dirty or not before running either of those methods. </p>

</div>
</div>
<a class="anchor" id="a821370544c7d36e7cbb742988b936102"></a><!-- doxytag: member="CC3Node::emissionColor" ref="a821370544c7d36e7cbb742988b936102" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Node::emissionColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The emission color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes.</p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a27945960af75a269569cb02f687e151b">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="af0ba63c550ccefcced28e809239f86c3"></a><!-- doxytag: member="CC3Node::globalBoundingBox" ref="af0ba63c550ccefcced28e809239f86c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a> CC3Node::globalBoundingBox<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the smallest axis-aligned bounding box that surrounds any local content of this node, plus all descendants of this node. </p>
<p>The returned bounding box is specfied in the global coordinate system of the 3D world.</p>
<p>Returns kCC3BoundingBoxNull if this node has no local content or descendants.</p>
<p>Since the bounding box of a node can change based on the locations, rotations, or scales of any descendant node, this property is measured dynamically on each access, by traversing all descendant nodes. This is a computationally expensive method. </p>

</div>
</div>
<a class="anchor" id="a2fdfd0ca5824487179b86d45b868c78b"></a><!-- doxytag: member="CC3Node::globalLightLocation" ref="a2fdfd0ca5824487179b86d45b868c78b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::globalLightLocation<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When a mesh node is textured with a DOT3 bump-map (normal map), this property indicates the location, in the global coordinate system, of the light that is illuminating the node. </p>
<p>When setting this property, this implementation sets the same property in all child nodes. Set the value of this property to the globalLocation of the light source. Bump-map textures may interact with only one light source.</p>
<p>This property only needs to be set, and will only have effect when set, on individual CC3MeshNodes whose material is configured for bump-mapping. This property is provided in <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> as a convenience to automatically traverse the node structural hierarchy to set this property in all descendant nodes.</p>
<p>When reading this property, this implementation returns the value of the same property from the first descendant node that is a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> and that contains a texture configured for bump-mapping. Otherwise, this implementation returns kCC3VectorZero. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a09ac6d16d320cecc66c0917979a92b3e">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="ad0ca6732d1834fb1ad348a190f810121"></a><!-- doxytag: member="CC3Node::globalLocation" ref="ad0ca6732d1834fb1ad348a190f810121" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::globalLocation<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The location of the node in 3D space, relative to the global origin. </p>
<p>This is calculated by using the transformMatrix to translate the local origin (0,0,0). </p>

</div>
</div>
<a class="anchor" id="a4b3a431575f6e933f31ba2a8d9fa54e0"></a><!-- doxytag: member="CC3Node::globalRotation" ref="a4b3a431575f6e933f31ba2a8d9fa54e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::globalRotation<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the overall rotation of the node in 3D space, relative to the global X, Y &amp; Z axes. </p>
<p>The returned value contains three Euler angles, specified in degrees, defining a global rotation of this node around the X, Y and Z axes. </p>

</div>
</div>
<a class="anchor" id="a14e0823f5a3988cbd52c2bc566a5f492"></a><!-- doxytag: member="CC3Node::globalScale" ref="a14e0823f5a3988cbd52c2bc566a5f492" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::globalScale<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The scale of the node in 3D space, relative to the global coordinate system, and accumulating the scaling of all ancestor nodes. </p>

</div>
</div>
<a class="anchor" id="ae984cc3ad8b86f4a031fa569d7745161"></a><!-- doxytag: member="CC3Node::hasLocalContent" ref="ae984cc3ad8b86f4a031fa569d7745161" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::hasLocalContent<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node has local content that will be drawn. </p>
<p>Default value is NO. Subclasses that do draw content will override to return YES. </p>

</div>
</div>
<a class="anchor" id="ab7dc69f8df858e108e70fc9f6258a347"></a><!-- doxytag: member="CC3Node::hasSoftBodyContent" ref="ab7dc69f8df858e108e70fc9f6258a347" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_node.html">CC3Node</a>(Skinning)::hasSoftBodyContent<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this structural node contains any descendant nodes that are used for soft-body vertex skinning. </p>
<p>This would include nodes of type <a class="el" href="interface_c_c3_skin_mesh_node.html" title="CC3SkinMeshNode is a CC3MeshNode specialized to use vertex skinning to draw the contents of its mesh...">CC3SkinMeshNode</a> or <a class="el" href="interface_c_c3_bone.html" title="CC3Bone is the building block of skeletons that control the deformation of a skin mesh...">CC3Bone</a>.</p>
<p>This property is a convenience used to identify nodes that should be grouped together structurally under a <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a>. </p>

</div>
</div>
<a class="anchor" id="af22c9f1b5440020b97fb89f8e9a2c508"></a><!-- doxytag: member="CC3Node::isAnimationEnabled" ref="af22c9f1b5440020b97fb89f8e9a2c508" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isAnimationEnabled<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether animation is enabled for this node. </p>
<p>This property only has effect if there the animation property is not nil.</p>
<p>The value of this property only applies to this node, not its child nodes. Child nodes that have this property set to YES will be animated even if this node has this property set to NO, and vice-versa.</p>
<p>Use the methods enableAllAnimation and disableAllAnimation to turn animation on or off for all the nodes in a node assembly.</p>
<p>The initial value of this property is YES. </p>

</div>
</div>
<a class="anchor" id="a58a798d71f952da9502d312719c88f3f"></a><!-- doxytag: member="CC3Node::isBasePODNode" ref="a58a798d71f952da9502d312719c88f3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_node.html">CC3Node</a>(PVRPOD)::isBasePODNode<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this POD is a base node, meaning that it has no parent. </p>

</div>
</div>
<a class="anchor" id="a7e22bcc4bf0a37cd4a702db373663503"></a><!-- doxytag: member="CC3Node::isMeshNode" ref="a7e22bcc4bf0a37cd4a702db373663503" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isMeshNode<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node has 3D mesh data to be drawn. </p>
<p>Default value is NO. Subclasses that do draw 3D meshes will override to return YES. </p>

</div>
</div>
<a class="anchor" id="ac178e6f33f03b599753ac1692bcf3dce"></a><!-- doxytag: member="CC3Node::isOpaque" ref="ac178e6f33f03b599753ac1692bcf3dce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isOpaque<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the content of this node and its descendants is opaque. </p>
<p>Returns NO if at least one descendant is not opaque, as determined by its isOpaque property. Returns YES if all descendants return YES from their isOpaque property.</p>
<p>Setting this property sets the same property in all descendants. See the notes for this property on <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> for more information on how this property interacts with the other material properties.</p>
<p>Setting this property should be thought of as a convenient way to switch between the two most common types of blending combinations. For finer control of blending, set specific blending properties on the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance directly, and avoid making changes to this property. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#ac754a405d9012e05421e24989865f7c4">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a239f148f08d434791a2cb52420c20698"></a><!-- doxytag: member="CC3Node::isRunning" ref="a239f148f08d434791a2cb52420c20698" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isRunning<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the dynamic behaviour of this node is enabled. </p>
<p>Setting this property affects both internal activities driven by the update process, and any CCActions controling this node. Setting this property to NO will effectively pause all update and CCAction behaviour on the node. Setting this property to YES will effectively resume the update and CCAction behaviour.</p>
<p>Setting this property sets the same property in all descendant nodes.</p>
<p>Be aware that when this property is set to NO, any CCActions are just paused, but not stopped, or removed. If you want to fully stop all CCActions on this node, use the stopAllActions method, or if you want to fully stop all CCActions on this node AND all descendant nodes, use the cleanup method. </p>

</div>
</div>
<a class="anchor" id="a33c2efcf095df0b3bf42cddc0a758663"></a><!-- doxytag: member="CC3Node::isSkeletonRigid" ref="a33c2efcf095df0b3bf42cddc0a758663" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_node.html">CC3Node</a>(Skinning)::isSkeletonRigid<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the bones in this skeleton, at and above this bone, are rigid. </p>
<p>For the skeleton above a particular bone to be rigid, that bone node, and all nodes above that bone must have unity scaling, or must be within the tolerance value specified in the property of unity scaling.</p>
<p>This implementation tests whether this node has unity scaling (within the tolerance set in the property), and then queries whether the parent node of this node is also rigid. This propagates upwards in the structural hierarchy to the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a>, at the root of the skeleton.</p>
<p>Since the inverse transforms of the bones are relative to the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a>, if all nodes up to the <a class="el" href="interface_c_c3_soft_body_node.html" title="CC3SoftBodyNode is the primary structural component for a soft-body object that uses vertex skinning ...">CC3SoftBodyNode</a> are rigid, then the skeleton is rigid. </p>

</div>
</div>
<a class="anchor" id="a82daff61037ecddfdb9591119ba0fbc9"></a><!-- doxytag: member="CC3Node::isTouchable" ref="a82daff61037ecddfdb9591119ba0fbc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isTouchable<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node will respond to UI touch events. </p>
<p>A node may often be touchable even if the isTouchEnabled flag is set to NO.</p>
<p>When the node is visible, this property returns YES under either of the following conditions:</p>
<ul>
<li>The isTouchEnabled property of this node is set to YES.</li>
<li>The shouldInheritTouchability property of this node is set to YES, AND the isTouchable property of the parent of this node returns YES.</li>
</ul>
<p>When the node is NOT visible, this property returns YES under either of the following conditions:</p>
<ul>
<li>The isTouchEnabled property of this node is set to YES AND the shouldAllowTouchableWhenInvisible is set to YES.</li>
<li>The shouldInheritTouchability property of this node is set to YES, AND the isTouchable property of the parent of this node returns YES. AND the shouldAllowTouchableWhenInvisible of this node is set to YES.</li>
</ul>
<p>This design simplifies identifying the node that is of interest when a touch event occurs. Thus, a car may be drawn as a node assembly of many descendant nodes (doors, wheels, body, etc). If isTouchEnabled is set for the car structural node, but not each wheel, it will be the parent car node that will be returned by the touchableNode property of the car structural node, or each wheel node. This allows the user to touch a wheel, but still have the car identified as the object of interest. </p>

</div>
</div>
<a class="anchor" id="a9e76cd512d10b989d7f01095a81f47c1"></a><!-- doxytag: member="CC3Node::isTouchEnabled" ref="a9e76cd512d10b989d7f01095a81f47c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isTouchEnabled<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates if this node, or any of its descendants, will respond to UI touch events. </p>
<p>This property also affects which node will be returned by the touchableNode property. If the isTouchEnabled property is explicitly set for a parent node, but not for a child node, both the parent and the child can be touchable, but it will be the parent that is returned by the touchableNode property of either the parent or child.</p>
<p>This design simplifies identifying the node that is of interest when a touch event occurs. Thus, a car may be drawn as a node assembly of many descendant nodes (doors, wheels, body, etc). If isTouchEnabled is set for the car structural node, but not each wheel, it will be the parent car node that will be returned by the touchableNode property of the car structural node, or each wheel node. This allows the user to touch a wheel, but still have the car identified as the object of interest.</p>
<p>Normally, only visible nodes can be touched. But this can be changed by setting the shouldAllowTouchableWhenInvisible property to YES.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="ac2ed8acc0f14fb7a9abf24d706873b83"></a><!-- doxytag: member="CC3Node::isTransformDirty" ref="ac2ed8acc0f14fb7a9abf24d706873b83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isTransformDirty<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether any of the transform properties, location, rotation, or scale have been changed, and so the transformMatrix of this needs to be recalculated. </p>
<p>This property is automatically set to YES when one of those properties have been changed, and is reset to NO once the transformMatrix has been recalculated.</p>
<p>Recalculation of the transformMatrix occurs automatically when the node is updated. </p>

</div>
</div>
<a class="anchor" id="a277e1309c2aa9c2c4dc313497c1ce7e2"></a><!-- doxytag: member="CC3Node::isTransformRigid" ref="a277e1309c2aa9c2c4dc313497c1ce7e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isTransformRigid<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the current transform applied to this node is rigid. </p>
<p>A rigid transform contains only rotation and translation transformations and does not include any scaling transformation. For the transform to be rigid, this node, and all ancestors of this node, must have unity scaling, or must be within the tolerance value specified in the property of unity scaling.</p>
<p>This implementation tests whether this node has unity scaling (within the tolerance set in the property), and then queries whether the parent node of this node is also rigid. This propagates upwards in the structural hierarchy, all the way to the root ancestor.</p>
<p>See the scaleTolerance property for more info on providing a tolerance to allow this evaluation to be fuzzy. </p>

</div>
</div>
<a class="anchor" id="afd9e3b759aaa56641df88a70e1ec07dc"></a><!-- doxytag: member="CC3Node::isUniformlyScaledGlobally" ref="afd9e3b759aaa56641df88a70e1ec07dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isUniformlyScaledGlobally<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether current global scaling (via the globalScale property) is uniform along all axes, within the tolerance value specified in the property, as tested against each ancestor independently. </p>
<p>This property takes into consideration the scaling of all ancestors. </p>

</div>
</div>
<a class="anchor" id="a212fe1cdd0af61fb5fbbe74be761d876"></a><!-- doxytag: member="CC3Node::isUniformlyScaledLocally" ref="a212fe1cdd0af61fb5fbbe74be761d876" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::isUniformlyScaledLocally<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether current local scaling (via the scale property) is uniform along all axes, within the tolerance value specified in the property. </p>
<p>This property does not take into consideration the scaling of any ancestors. </p>

</div>
</div>
<a class="anchor" id="a4fd02187b1ee7884b9d0d8a19e413ae9"></a><!-- doxytag: member="CC3Node::location" ref="a4fd02187b1ee7884b9d0d8a19e413ae9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::location<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The location of the node in 3D space, relative to the parent of this node. </p>
<p>The global location of the node is therefore a combination of the global location of the parent of this node and the value of this location property. </p>

</div>
</div>
<a class="anchor" id="a49f80cf856a152e5c5a9f08efe15b0b1"></a><!-- doxytag: member="CC3Node::normalScalingMethod" ref="a49f80cf856a152e5c5a9f08efe15b0b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_c3_node_8h.html#a4bed21b96ced6e7ff2d912800ab99bba">CC3NormalScaling</a> CC3Node::normalScalingMethod<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies the method to be used to scale vertex normals after they have been transformed during vertex drawing. </p>
<p>Normal vectors should have a unit length. Since normals are vectors in the local coordinate system of the node, they are transformed into world and eye coordinates during drawing.</p>
<p>During transformation, there are several factors that might distort the normal vector:</p>
<ul>
<li>If the normals started out not being of unit length, they will generally be transformed into vectors that are not of unit length.</li>
<li>If the transforms are not rigid, and include scaling, even normals that have unit length in object space will end up shorter or longer than unit length in eye space.</li>
<li>If the transform scaling is not uniform, the normals will shear, and end up shorter or longer than unit length.</li>
</ul>
<p>Normals that are not of unit length, or are sheared, will cause portions of the objects to appear lighter or darker after transformation, or will cause specular highlights to actually be dark, distorting the overall look of the material covering the mesh.</p>
<p>The GL engine can be instructed to compensate for these transforms by setting this property as follows:</p>
<ul>
<li>kCC3NormalScalingNone: No compensating scaling is performed on the normals after they have been transformed. This has the highest performance, but will not adjust the normals if they have been scaled. Use this option if you know that the normals will not be significantly scaled during transformation.</li>
</ul>
<ul>
<li>kCC3NormalScalingRescale: Uses the modelview matrix to scale all normals by the inverse of the node's overall scaling. This does have a processing cost, but is much faster than using kCC3NormalScalingNormalize. However, it is not as accurate if significantly non-uniform scaling has been applied to the node.</li>
</ul>
<ul>
<li>kCC3NormalScalingNormalize: Normalizes each norml vector independently. This is the most accurate method, but is also, by far, the most computationally expensive. Use this method only if selecting one of the other options does not give you the results that you expect.</li>
</ul>
<ul>
<li>kCC3NormalScalingAutomatic: Chooses the most appropriate method based on the scaling that has been applied to the node. If no scaling has been applied to the node, kCC3NormalScalingNone will be used. If only uniform scaling has been applied to the node, kCC3NormalScalingRescale will be used. If non-uniform scaling has been applied to the node, then kCC3NormalScalingNormalize will be used.</li>
</ul>
<p>The initial value of this property is kCC3NormalScalingAutomatic. You can generally leave this property at this default value unless you are not getting the results that you expect.</p>
<p>Setting this property sets the corresponding property in all descendant nodes, and affects the processing of normals in all vertex meshes contained in all descendant nodes.</p>
<p>Querying this property returns the value of this property from the first descendant mesh node, or will return kCC3NormalScalingNone if no mesh node are found in the descendants of this node. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a99927d686b53cd38f0adfff1dd694083">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a7c97161a1d0bd50fb265bd390fab9247"></a><!-- doxytag: member="CC3Node::opacity" ref="a7c97161a1d0bd50fb265bd390fab9247" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLubyte CC3Node::opacity<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCRGBAProtocol opacity property. </p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming.</p>
<p>Setting this property sets the same property in all descendants. See the notes for this property on <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> for more information on how this property interacts with the other material properties.</p>
<p>Setting this property should be thought of as a convenient way to switch between the two most common types of blending combinations. For finer control of blending, set specific blending properties on the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance directly, and avoid making changes to this property. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#af790e70c1f94c040dea7e7229c28b851">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a63b5b31888815554d7949288fb5d73e3"></a><!-- doxytag: member="CC3Node::parent" ref="a63b5b31888815554d7949288fb5d73e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node.html">CC3Node</a> * CC3Node::parent<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The parent node of this node, in a node structural hierarchy. </p>

</div>
</div>
<a class="anchor" id="afe17f2234ab3bfdf9c2b70ae5510c0a8"></a><!-- doxytag: member="CC3Node::parentTransformMatrix" ref="afe17f2234ab3bfdf9c2b70ae5510c0a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a>* CC3Node::parentTransformMatrix<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the transform matrix of the parent node. </p>
<p>Returns nil if there is no parent.</p>
<p>This template property is used by this class to base the transform of this node on the transform of its parent. A subclass may override to return nil if it determines that it wants to ignore the parent transform when calculating its own transform. </p>

</div>
</div>
<a class="anchor" id="a968396edac85926dcd809809220f0489"></a><!-- doxytag: member="CC3Node::performanceStatistics" ref="a968396edac85926dcd809809220f0489" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_performance_statistics.html">CC3PerformanceStatistics</a>* CC3Node::performanceStatistics<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Some node types (notably <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>) collect runtime performance statistics using an instance of <a class="el" href="interface_c_c3_performance_statistics.html" title="Collects statistics about the updating and drawing performance of the 3D world.">CC3PerformanceStatistics</a> accessed by this property. </p>
<p>By default, nodes do not collect statistics. This property always returns nil, and setting this property has no effect. Subclasses that performance support statistics collection will override to allow the property to be get and set. </p>

<p>Implemented in <a class="el" href="interface_c_c3_world.html#a75034883f24c2a436d2bc72bf0dca52e">CC3World</a>.</p>

</div>
</div>
<a class="anchor" id="a6c1fd95973bf8c59172b834e622d072c"></a><!-- doxytag: member="CC3Node::podContentIndex" ref="a6c1fd95973bf8c59172b834e622d072c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="interface_c_c3_node.html">CC3Node</a>(PVRPOD)::podContentIndex<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The index of the POD data that forms the type-specific content of this node. </p>
<p>This is distinct from the podIndex property, which is the index of the data for the node, which may be of any node type. Once the type is established, the type-specific content is indexed by the podContentIndex property.</p>
<p>This abstract implementation does not map this property to an instance variable Concrete subclasses must override to map to an actual instance variable. </p>

</div>
</div>
<a class="anchor" id="a28cdeee0efde2485eb0af957901831e5"></a><!-- doxytag: member="CC3Node::podParentIndex" ref="a28cdeee0efde2485eb0af957901831e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="interface_c_c3_node.html">CC3Node</a>(PVRPOD)::podParentIndex<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The index of the parent node of this node. </p>
<p>This will be -1 if this node has no parent.</p>
<p>This abstract implementation does not map this property to an instance variable Concrete subclasses must override to map to an actual instance variable. </p>

</div>
</div>
<a class="anchor" id="a9b45149a327a4c6968b4ddf6c3a569b8"></a><!-- doxytag: member="CC3Node::projectedLocation" ref="a9b45149a327a4c6968b4ddf6c3a569b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::projectedLocation<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current location of this node, as projected onto the 2D viewport coordinate space. </p>
<p>For most purposes, this is where this node will appear on the screen or window. The 2D position can be read from the X and Y components of the returned 3D location.</p>
<p>The initial value of this property is kCC3VectorZero. To set this property, pass this node as the argument to the projectNode: method of the active camera, which can be retrieved from the activeCamera property of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>. The application should usually not set this property directly. For more information, see the notes for the projectNode: method of <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a>.</p>
<p>The Z-component of the returned location indicates the distance from the camera to this node, with a positive value indicating that this node is in front of the camera, and a negative value indicating that it is behind the camera. If you are only interested in the case when this node is in front of the camera (potentially visible to the camera), check that the Z-component of the returned location is positive.</p>
<p>When several nodes overlap a 2D position on the screen, you can also use the Z-component of the projectedLocation property of each of the nodes to determine which node is closest the camera, and is therefore "on-top" visually. This can be useful when trying to select a 3D node from an iOS touch event position.</p>
<p>The returned value takes into account the orientation of the device (portrait, landscape). </p>

</div>
</div>
<a class="anchor" id="a8d2860d65aa974fe26a45d9d2d6cb286"></a><!-- doxytag: member="CC3Node::projectedPosition" ref="a8d2860d65aa974fe26a45d9d2d6cb286" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGPoint CC3Node::projectedPosition<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current position of this node, as projected onto the 2D viewport coordinate space, returned as a 2D point. </p>
<p>For most purposes, this is where this node will appear on the screen or window.</p>
<p>This value is derived from the X and Y coordinates of the projectedLocation property. If this node is behind the camera, both the X and Y coordinates of the returned point will have the value -CGFLOAT_MAX.</p>
<p>The initial value of this property is CGPointZero. To set this property, pass this node as the argument to the projectNode: method of the active camera, which can be retrieved from the activeCamera property of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>. For more information, see the notes for the projectNode: method of <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a>.</p>
<p>The returned value takes into account the orientation of the device (portrait, landscape). </p>

</div>
</div>
<a class="anchor" id="ad7ece51255c6b553667de83a46fc2107"></a><!-- doxytag: member="CC3Node::quaternion" ref="ad7ece51255c6b553667de83a46fc2107" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> CC3Node::quaternion<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rotation of the node in 3D space, relative to the parent of this node, expressed as a quaternion. </p>
<p>Rotational transformation can also be specified using the rotation property (Euler angles), or the rotationAxis and rotationAngle properties. Subsequently, this property can be read to return the corresponding quaternion. </p>

</div>
</div>
<a class="anchor" id="a78c1dc69cd157d76184a077803d57df9"></a><!-- doxytag: member="CC3Node::rootAncestor" ref="a78c1dc69cd157d76184a077803d57df9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node.html">CC3Node</a>* CC3Node::rootAncestor<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the root ancestor of this node, in the node structural hierarchy, or returns this node, if this node has no parent. </p>
<p>In almost all cases, this node returned will be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>. However, if this node and all of its ancestors have not been added to the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, then the returned node may be some other node.</p>
<p>Reading this property traverses up the node hierarchy. If this property is accessed frequently, it is recommended that it be cached. </p>

</div>
</div>
<a class="anchor" id="a40bf4400c59a1c7dbe3040e32de5c2c5"></a><!-- doxytag: member="CC3Node::rotation" ref="a40bf4400c59a1c7dbe3040e32de5c2c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::rotation<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rotational orientation of the node in 3D space, relative to the parent of this node. </p>
<p>The global rotation of the node is therefore a combination of the global rotation of the parent of this node and the value of this rotation property. This value contains three Euler angles, defining a rotation of this nodearound the X, Y and Z axes. Each angle is specified in degrees.</p>
<p>Rotation is performed in Y-X-Z order, which is the OpenGL default. Depending on the nature of the object you are trying to control, you can think of this order as yaw, then pitch, then roll, or heading, then inclination, then tilt,</p>
<p>When setting this value, each component is converted to modulo +/-360 degrees.</p>
<p>Rotational transformation can also be specified using the rotationAxis and rotationAngle properties, or the quaternion property. Subsequently, this property can be read to return the corresponding Euler angles. </p>

</div>
</div>
<a class="anchor" id="a7df49fd1ba5f759e58cf941e6f6c5192"></a><!-- doxytag: member="CC3Node::rotationAngle" ref="a7df49fd1ba5f759e58cf941e6f6c5192" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Node::rotationAngle<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The angular rotation around the axis specified in the rotationAxis property. </p>
<p>Rotational transformation can also be specified using the rotation property (Euler angles), or the quaternion property. Subsequently, this property can be read to return the corresponding angle of rotation.</p>
<p>When setting this value, it is converted to modulo +/-360 degrees. When reading this value after making changes using rotateByAngle:aroundAxis:, or using another rotation property, the value of this property will be clamped to +/-180 degrees.</p>
<p>For example, if current rotation is 170 degrees around the rotationAxis, invoking the rotateByAngle:aroundAxis: method using the same rotation axis and 20 degrees, reading this property will return -170 degrees, not 190 degrees. </p>

</div>
</div>
<a class="anchor" id="abe5011c1eb664c356e4a3a37f04d36b3"></a><!-- doxytag: member="CC3Node::rotationAxis" ref="abe5011c1eb664c356e4a3a37f04d36b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::rotationAxis<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The axis of rotation of the node in 3D space, relative to the parent of this node, expressed as a directional vector. </p>
<p>This axis can be used in conjunction with the rotationAngle property to describe the rotation as a single angular rotation around an arbitrary axis.</p>
<p>Under the identity rotation (no rotation), the rotationAngle is zero and the rotationAxis is undefined. Under that condition, this property will return the zero vector kCC3VectorZero.</p>
<p>Rotational transformation can also be specified using the rotation property (Euler angles), or the quaternion property. Subsequently, this property can be read to return the corresponding axis of rotation. </p>

</div>
</div>
<a class="anchor" id="a68c7cf1e11c447397006bdb8adbec4aa"></a><!-- doxytag: member="CC3Node::rotator" ref="a68c7cf1e11c447397006bdb8adbec4aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_rotator.html">CC3Rotator</a> * CC3Node::rotator<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the rotator that manages the local rotation of this node. </p>

</div>
</div>
<a class="anchor" id="a3046c4ba3c92d526869f704243db5207"></a><!-- doxytag: member="CC3Node::scale" ref="a3046c4ba3c92d526869f704243db5207" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Node::scale<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The scale of the node in each dimension, relative to the parent of this node. </p>

</div>
</div>
<a class="anchor" id="abc2307e74e42c5c2d872e4c91b07bced"></a><!-- doxytag: member="CC3Node::scaleTolerance" ref="abc2307e74e42c5c2d872e4c91b07bced" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Node::scaleTolerance<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates a tolerance value that is used when testing scale component values, including testing whether a component value is close to unity (one), or whether two component values are close to each other (uniformity). </p>
<p>Exact unity scaling is useful because an unscaled (rigid) transform matrix can be inverted much faster than a scaled transform matrix, by a factor of between one and two orders of magnitude. If it is known that the transform matrix includes no scaling (has unity scaling), then the matrix will be inverted as a rigid matrix, to make use of this performance gain during inversion.</p>
<p>In addition, exact uniform scaling is useful when determining the method used to rescaling vertex normals during mesh transformations. The methods used if the transform includes no scaling, or if the transform includes only uniform scaling, are significantly faster than if the transform includes non-uniform scaling.</p>
<p>Although you can often deliberately set the scaling to exactly unity, or to be exactly uniform, there are some occasions, including animation and automatic physics, where the scale can be close to, but not exactly zero. By permitting a tolerance, unity scaling or uniform scaling can be assumed if the values are reasonably close, and the performance gain can be acquired under a wider range of conditions.</p>
<p>Specifically, the isTransformRigid will return YES if each of the X, Y &amp; Z components of the scale property are within the tolerance range defined by this property, when comparing the components to unity.</p>
<p>For example, if the value of this property is 0.02, and the value of the scale property is (1.01, 1.0, 1.02), the isTransformRigid will return YES. However, if the value of this property was left at zero, the isTransformRigid property would return NO with the same scale value.</p>
<p>This property is also used by the isUniformlyScaledLocally and isUniformlyScaledGlobally properties when testing whether the components of the scale property are equal to each other, for the purpose of determining whether the scaling is uniform.</p>
<p>For example, if the value of this property is 0.02 and the value of the scale property is (3.01, 3.0, 3.02), the isUniformlyScaledLocally property will return YES, as will the isUniformlyScaledGlobally, if the ancestor scales are similarly uniform.</p>
<p>If this property is set to zero, then no tolerance is accepted, and all three components of the scale property must be exactly equal to one for this node to be considered to have no scaling applied, or exactly equal to each other for this node to be considered to have uniform scaling.</p>
<p>Setting this property sets the same property in all child nodes to the same value.</p>
<p>Initially, the value of this property is set to the value of the class-side defaultUnityScaleTolerance property. Use the class-side property to establish a global tolerance for all CC3Nodes. </p>

</div>
</div>
<a class="anchor" id="aa09d8bfdfd1a67eb94f108a984197dd8"></a><!-- doxytag: member="CC3Node::shouldAllowTouchableWhenInvisible" ref="aa09d8bfdfd1a67eb94f108a984197dd8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldAllowTouchableWhenInvisible<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node should be touchable even when invisible. </p>
<p>When this property and the visible property are set to NO, the isTouchable property will always return NO. When this property is YES, the isTouchable property can return YES for an invisible node, if the other conditions for touchability are met. See the isTouchable property for more info.</p>
<p>The initial value of this propety is NO. </p>

</div>
</div>
<a class="anchor" id="a452f578797e63d9a8fabd8e3fdb7d772"></a><!-- doxytag: member="CC3Node::shouldAutoremoveWhenEmpty" ref="a452f578797e63d9a8fabd8e3fdb7d772" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldAutoremoveWhenEmpty<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance should automatically remove itself from its parent once its last child is removed. </p>
<p>Setting this property to YES can be useful for certain types of wrapper subclasses, where a instance wraps a single child node. Removing that child node from the node hierarchy (typically by invoking the remove method on that child node, and which may be performed automatically for some types of child nodes), will also cause the wrapper node to be removed as well. This cleanup is important to avoid littering your world with empty wrapper nodes.</p>
<p>The initial value of this property is NO, indicating that this instance will NOT automatically remove itself from the node hierarchy once all its child nodes have been removed. </p>

</div>
</div>
<a class="anchor" id="a3a212b8b1aaa572d0901b29f554d6712"></a><!-- doxytag: member="CC3Node::shouldCleanupWhenRemoved" ref="a3a212b8b1aaa572d0901b29f554d6712" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldCleanupWhenRemoved<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether all the CCActions currently running on this node and all descendants should be stopped and removed when this node is removed from its parent. </p>
<p>If the value of this property is YES, when this node is removed from its parent, the cleanup method will automatically be invoked. If the value of this method is NO, when this node is removed from its parent, the isRunning property will be set to NO, which causes all actions to be paused, but not removed.</p>
<p>Stopping and removing CCActions is important because the actions running on a node retain links to the node. If the actions are simply paused, those links will be retained forever, potentially creating memory leaks of nodes that are invisibly retained by their actions.</p>
<p>The iniital value of this property is YES, indicating that all actions will be stopped and removed when this node is removed from its parent. If you have reason to want the actions to be paused but not removed when removing this node from its parent, set this property to NO.</p>
<p>One example of such a situation might be if you are moving a node from one parent to another. You may want to temporarily set this property to NO during the move so that the actions are paused during the move, but resumed when the node is added to a new parent.</p>
<p>If you have this property set to NO, you can manually stop and remove all actions using the cleanup method. </p>

</div>
</div>
<a class="anchor" id="a0a02ef76817887e925c9dc04c0e9826e"></a><!-- doxytag: member="CC3Node::shouldCullBackFaces" ref="a0a02ef76817887e925c9dc04c0e9826e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldCullBackFaces<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the back faces should be culled on the meshes contained in descendants of this node. </p>
<p>The initial value is YES, indicating that back faces will not be displayed. You can set this property to NO if you have reason to display the back faces of the mesh (for instance, if you have a rectangular plane and you want to show both sides of it).</p>
<p>Since the normal of the face points out the front face, back faces interact with light the same way the front faces do, and will appear luminated by light that falls on the front face, much like a stained-glass window. This may not be the affect that you are after, and for some lighting conditions, instead of disabling back face culling, you might consider creating a second textured front face, placed back-to-back with the original front face.</p>
<p>Be aware that culling improves performance, so this property should be set to NO only when specifically needed for visual effect, and only on the meshes that need it.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns NO if any of the descendant mesh nodes have this property set to NO. Initially, and in most cases, all mesh nodes have this property set to YES.</p>
<p>For more information about this use of this property, see the class notes for the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> class. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a0a2dcf49d0997083a838a366d7a026d1">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a890865bb4d5cf77011e4e3de7f3d1e17"></a><!-- doxytag: member="CC3Node::shouldCullFrontFaces" ref="a890865bb4d5cf77011e4e3de7f3d1e17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldCullFrontFaces<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the front faces should be culled on the meshes contained in descendants of this node. </p>
<p>The initial value is NO. Normally, you should leave this property with the initial value, unless you have a specific need not to display the front faces.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES. Initially, and in most cases, all mesh nodes have this property set to NO.</p>
<p>For more information about this use of this property, see the class notes for the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> class. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#aba9c33476284294c99a718a0259c4c9a">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a26a30412b0a1de08a1baae7db25d0790"></a><!-- doxytag: member="CC3Node::shouldDisableDepthMask" ref="a26a30412b0a1de08a1baae7db25d0790" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldDisableDepthMask<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance will disable the GL depth mask while drawing the content of this node. </p>
<p>When the depth mask is disabled, drawing activity will not write to the depth buffer.</p>
<p>If this property is set to NO, the Z-distance of this node will be compared against previously drawn content, and the drawing of this node will update the depth buffer, so that subsequent drawing will take into consideration the Z-distance of this node.</p>
<p>If this property is set to YES, the Z-distance of this node will still be compared against previously drawn content, but the drawing of this node will NOT update the depth buffer, and subsequent drawing will NOT take into consideration the Z-distance of this node.</p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>In most cases, to draw an accurate scene, we want depth testing to be performed at all times, and this property is usually set to NO. However, there are some occasions where it is useful to disable writing to the depth buffer during the drawing of a node. One notable situation is with particle systems, where temporarily disabling the depth mask will avoid Z-fighting between individual particles.</p>
<p>The initial value of this property is NO, indicating that the GL depth mask will not be disabled during the drawing of this node, and the depth buffer will be updated during the drawing of this node.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a36ab2366c2f8cb77f6898c7a6a65f682">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="ae14b782b005ee61d7c12a66669100a1d"></a><!-- doxytag: member="CC3Node::shouldDisableDepthTest" ref="ae14b782b005ee61d7c12a66669100a1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldDisableDepthTest<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance will disable the GL depth test while drawing the content of this node. </p>
<p>When the depth test is disabled, the Z-distance of this node will not be compared against previously drawn content, and drawing activity will not write to the depth buffer.</p>
<p>If this property is set to NO, the Z-distance of this node will be compared against previously drawn content, and the drawing of this node will update the depth buffer, so that subsequent drawing will take into consideration the Z-distance of this node.</p>
<p>If this property is set to YES, the Z-distance of this node will not be compared against previously drawn content and this node will be drawn over all previously drawn content. In addition, the drawing of this node will not update the depth buffer, with the result that subsequent object drawing will not take into consideration the Z-distance of this node.</p>
<p>In most cases, to draw an accurate scene, we want depth testing to be performed at all times, and this property is usually set to NO. However, there are some occasions where it is useful to disable depth testing during the drawing of a node. One notable situation is with particle systems, where temporarily disabling depth testing may help avoid Z-fighting between individual particles.</p>
<p>The initial value of this property is NO, indicating that the GL depth tesing will not be disabled during the drawing of this node, and the depth buffer will be updated during the drawing of this node.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a8710a0a76335e1cffa53c0304214a036">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="ae4262f42e7d2a599cf5cdf2d7a2edb6c"></a><!-- doxytag: member="CC3Node::shouldDrawAllDescriptors" ref="ae4262f42e7d2a599cf5cdf2d7a2edb6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldDrawAllDescriptors<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the state of the shouldDrawDescriptor property of this node and all descendant nodes. </p>
<p>Setting this property sets that value into the shouldDrawDescriptor property on this and all descendant nodes.</p>
<p>Setting this property to YES draws a descriptor label on this node and each descendant node. Setting this property to NO removes all of those labels.</p>
<p>Reading this property traverses this node and its descendants and returns NO if any descendant returns NO. Otherwise returns YES. </p>

</div>
</div>
<a class="anchor" id="a5fcb4583de836b376bd11880c67d7598"></a><!-- doxytag: member="CC3Node::shouldDrawAllLocalContentWireframeBoxes" ref="a5fcb4583de836b376bd11880c67d7598" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldDrawAllLocalContentWireframeBoxes<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the state of the shouldDrawLocalContentWireframeBox property of this node, if it has local content, and all descendant nodes that have local content. </p>
<p>Setting this property sets that value into the shouldDrawLocalContentWireframeBox property on this node, if it has local content, and all descendant nodes that have local content.</p>
<p>Setting this property to YES draws individual wireframe boxes around any local content of this node and any descendant nodes that have local content. Setting this property to NO removes all of those boxes.</p>
<p>Reading this property traverses this node and its descendants and returns NO if any descendant returns NO. Otherwise returns YES. </p>

</div>
</div>
<a class="anchor" id="a791e5a2fb4e409d23125af2e9fc3b9a0"></a><!-- doxytag: member="CC3Node::shouldDrawAllWireframeBoxes" ref="a791e5a2fb4e409d23125af2e9fc3b9a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldDrawAllWireframeBoxes<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the state of the shouldDrawWireframeBox property of this node and all descendant nodes. </p>
<p>Setting this property sets that value into the shouldDrawWireframeBox property on this and all descendant nodes.</p>
<p>Setting this property to YES draws individual wireframe boxes around this node and each descendant node. Setting this property to NO removes all of those boxes.</p>
<p>Reading this property traverses this node and its descendants and returns NO if any descendant returns NO. Otherwise returns YES.</p>
<p>If this node has no local content, or has descendant nodes without local content, or descendants themselves (for example cameras, lights, or simply empty structural or targetting nodes), setting this property will have no effect for those descendants. Under those conditions, it is possible to set this property to YES and subsequently read the property back as NO. </p>

</div>
</div>
<a class="anchor" id="a98878a97ed2aeaa6cd809cd9596e91b4"></a><!-- doxytag: member="CC3Node::shouldDrawDescriptor" ref="a98878a97ed2aeaa6cd809cd9596e91b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldDrawDescriptor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node should display a descriptive label on this node. </p>
<p>When set to YES, a descriptive text label will appear on this node. The descriptive label is positioned at the origin of this node, in this node's local coordinate system. The origin is the pivot point around which transforms such as rotation, movement and scale will occur when applied to this node. The origin is not always the same as the center of geometry of the node.</p>
<p>The descriptive text will appear in the font size specified in the class-side descriptorFontSize property. The color of the descriptive text is determined by the subclass. Typically, for structural nodes, it is the same color as the wireframe box that is drawn around the node when the shouldDrawWireframeBox property is set to YES. For nodes with local content to draw, the color of the text is the same as the wireframe box that is drawn around the local content of the node when the shouldDrawLocalContentWireframeBox property is set to YES.</p>
<p>Setting this property to YES can be useful during development in determining the identification of visible nodes, or the location of nodes that are unable to be drawn correctly.</p>
<p>The descriptive label is drawn by creating and adding a <a class="el" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano...">CC3NodeDescriptor</a> node as a child node to this node. <a class="el" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano...">CC3NodeDescriptor</a> is a type of <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a>, and is configured to contain a 2D CCLabel, whose text is set to the description of this node. Setting this property to YES adds the descriptor child node, and setting this property to NO removes the descriptor child node.</p>
<p>By default, the child descriptor node is not touchable, even if this node is touchable. If, for some reason you want the descriptor text to be touchable, you can retrieve the descriptor node from the descriptorNode property, and set the isTouchEnabled property to YES. </p>

</div>
</div>
<a class="anchor" id="a6296e007b77e700dc737c733454dfa16"></a><!-- doxytag: member="CC3Node::shouldDrawWireframeBox" ref="a6296e007b77e700dc737c733454dfa16" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldDrawWireframeBox<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the node should display a wireframe bounding box around this node and all its descendants. </p>
<p>The wireframe box is drawn by creating and adding a <a class="el" href="interface_c_c3_wireframe_bounding_box_node.html" title="CC3WireframeBoundingBoxNode is a type of CC3LineNode specialized for drawing a wireframe bounding box...">CC3WireframeBoundingBoxNode</a> as a child node to this node. The dimensions of the child node are set from the boundingBox property of this node. Setting this property to YES adds the wireframe child node, and setting this property to NO removes the wireframe child node.</p>
<p>Setting this property to YES can be useful during development in determining the boundaries of a 3D structural node.</p>
<p>The color of the wireframe box will be the value of the class-side defaultWireframeBoxColor property, or the value of the color property of this node if defaultWireframeBoxColor is equal to kCCC4FBlackTransparent.</p>
<p>If this node has no local content, or no descendant nodes with local content, setting this property will have no effect. In this condition, it is possible to set this property to YES and subsequently read the property back as NO.</p>
<p>By default, the child wireframe node is not touchable, even if this node is touchable. If, for some reason you want the wireframe to be touchable, you can retrieve the wireframe node from the wireframeBoxNode property, and set the isTouchEnabled property to YES. </p>

</div>
</div>
<a class="anchor" id="a6833d96291530bec5cdcdc62fc7dad43"></a><!-- doxytag: member="CC3Node::shouldInheritTouchability" ref="a6833d96291530bec5cdcdc62fc7dad43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldInheritTouchability<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this node should automatically be considered touchable if this node's parent is touchable. </p>
<p>By using this property, you can turn off touchability on a child node, even when the parent node is touchable.</p>
<p>Normally, a node will be touchable if its isTouchEnabled property is set to YES on the node itself, or on one of its ancestors. You can change this behaviour by setting this property to NO on the child node. With the isTouchEnabled property and this property both set to NO, the isTouchable property will return NO, even if the isTouchable property of the parent returns YES, and the node will not respond to touch events even if the parent node does.</p>
<p>The initial value of this property is YES, indicating that this node will return YES in the isTouchable property if the parent node returns YES in its isTouchable property, even if the isTouchEnabled property of this node is set to NO. </p>

</div>
</div>
<a class="anchor" id="a899c01b0e0a806669d7827112a275ddc"></a><!-- doxytag: member="CC3Node::shouldUseClockwiseFrontFaceWinding" ref="a899c01b0e0a806669d7827112a275ddc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldUseClockwiseFrontFaceWinding<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the edge-widing algorithm used by the GL engine to determine which face of a triangle is the front face should use clockwise winding. </p>
<p>If this property is set to YES, the front face of all triangles in the mesh of this node will be determined using clockwise winding of the edges. If this property is set to NO, the front face of all triangles in the mesh of this node will be determined using counter-clockwise winding of the edges.</p>
<p>The initial value of this property is NO, indicating that the OpenGL-standard counter-clockwise winding will be used by the GL engine to determine the front face of all triangles in the mesh of this node. Unless you have a reason to change this value, you should leave it at the initial value.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a4a416a1c347b2e7808aaae647a3d7ede">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="ab17442122bf69cf1f949c241cb229fe3"></a><!-- doxytag: member="CC3Node::shouldUseFixedBoundingVolume" ref="ab17442122bf69cf1f949c241cb229fe3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldUseFixedBoundingVolume<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the bounding volume of this node should be considered fixed, even if the mesh vertices that determine the boundary are changed, or should be recalculated whenever the underlying mesh vertices change. </p>
<p>If the value of this property is set to YES, the bounding volume will NOT be recalculated each time the vertices of the mesh are modified (typically via the setVertexLocation:at: method). If the value of this property is set to NO, the bounding volume will be recalculated each time the vertices of the mesh are modified.</p>
<p>The initial value of this property is NO, indicating that the bounding volume will be recalculated whenever the underlying mesh vertices change.</p>
<p>For most scenarios, the most accurate bounding volume is achieved by leaving setting this property to NO, and letting the bounding volume automatically adapt to changes in the underlying mesh vertices.</p>
<p>However, for some specialized meshes, such as particle generators, where the vertex data is continuously being modified in a predictable manner, the processing cost of constantly re-measuring the bounding volume may be significant, and it may be more effective to set a fixed bounding volume that encompasses the entire possible range of vertex location data, and set the value of this property to YES to stop the bounding volume from being recalculated every time the vertex data is changed.</p>
<p>See the note for the various subclasses of <a class="el" href="interface_c_c3_node_bounding_volume.html" title="Bounding volumes are used by CC3Nodes to determine whether a node interset the camera&#39;s frustum...">CC3NodeBoundingVolume</a> (eg- <a class="el" href="interface_c_c3_node_bounding_box_volume.html" title="A bounding volume that forms an axially aligned bounding box (AABB) around the node, in the node&#39;s local coordinate system.">CC3NodeBoundingBoxVolume</a> and <a class="el" href="interface_c_c3_node_spherical_bounding_volume.html" title="A bounding volume that forms a sphere around a single point.">CC3NodeSphericalBoundingVolume</a>) to learn how to set the properties of the bounding volumes, to fix them to a particular range. </p>

</div>
</div>
<a class="anchor" id="a3cbea6e6582b701b52b7a64d37ce6aa6"></a><!-- doxytag: member="CC3Node::shouldUseLighting" ref="a3cbea6e6582b701b52b7a64d37ce6aa6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldUseLighting<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this value is set to YES, current lighting conditions will be taken into consideration when drawing colors and textures, and the ambientColor, diffuseColor, specularColor, emissionColor, and shininess properties will interact with lighting settings. </p>
<p>If this value is set to NO, lighting conditions will be ignored when drawing colors and textures, and the material emissionColor will be applied to the mesh surface without regard to lighting. Blending will still occur, but the other material aspects, including ambientColor, diffuseColor, specularColor, and shininess will be ignored. This is useful for a cartoon effect, where you want a pure color, or the natural colors of the texture, to be included in blending calculations, without having to arrange lighting, or if you want those colors to be displayed in their natural values despite current lighting conditions.</p>
<p>Setting the value of this property sets the same property in the materials contained in all descendant nodes. Reading the value of this property returns YES if any descendant node returns YES, and returns NO otherwise. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#a32c89a1b1bdb7ec9ebb2bbaafd5a53d9">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="adcf527d032102ac1750699662c0c753d"></a><!-- doxytag: member="CC3Node::shouldUseSmoothShading" ref="adcf527d032102ac1750699662c0c753d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::shouldUseSmoothShading<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the shading of the faces of the mesh of this node should be smoothly shaded, using color interpolation between vertices. </p>
<p>If this property is set to YES, the color of each pixel in any face in the mesh of this node will be interpolated from the colors of all three vertices of the face, using the distance of the pixel to each vertex as the means to interpolate. The result is a smooth gradient of color across the face.</p>
<p>If this property is set to NO, the color of all pixels in any face in the mesh of this node will be determined by the color at the third vertex of the face. All pixels in the face will be painted in the same color.</p>
<p>The initial value is YES. For realistic rendering, you should leave this property with the initial value, unless you have a specific need to render flat color across each face in the mesh, such as to deliberately create a cartoon-like effect on the model.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns NO if any of the descendant mesh nodes have this property set to NO. Initially, and in most cases, all mesh nodes have this property set to YES. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#ae8856e39d188accad9ad49dbd40649f2">CC3MeshNode</a>.</p>

</div>
</div>
<a class="anchor" id="a12ec9c3ae66471ffdc3eec5612cf4b4e"></a><!-- doxytag: member="CC3Node::specularColor" ref="a12ec9c3ae66471ffdc3eec5612cf4b4e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Node::specularColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The specular color of the materials of this node. </p>
<p>Setting this property sets the same property on all child nodes.</p>
<p>Querying this property returns the average value of querying this property on all child nodes. When querying this value on a large node assembly, be aware that this may be time-consuming. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mesh_node.html#add17365ad2a6a86b4a75b63b12b8bcfc">CC3MeshNode</a>, and <a class="el" href="interface_c_c3_light.html#a4123c1e20b025f5989db09400394f951">CC3Light</a>.</p>

</div>
</div>
<a class="anchor" id="af4f64f9bff8e82bd227b87368bdd6ae5"></a><!-- doxytag: member="CC3Node::structureDescription" ref="af4f64f9bff8e82bd227b87368bdd6ae5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NSString* CC3Node::structureDescription<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a description of the structure of this node and its descendants, by recursing through this node and its descendants and appending the result of the description property of each node. </p>
<p>The description of each node appears on a separate line and is indented according to its depth in the structural hierarchy, starting at this node. </p>

</div>
</div>
<a class="anchor" id="aa18700eb982dbcff8acbf70ce0f97b6c"></a><!-- doxytag: member="CC3Node::touchableNode" ref="aa18700eb982dbcff8acbf70ce0f97b6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node.html">CC3Node</a>* CC3Node::touchableNode<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the node that is of interest if this node is selected by a touch event. </p>
<p>The value of this property is not always this node, but may be an ancestor node instead.</p>
<p>The value returned by this property is this node if the isTouchEnabled property of this node is set to YES, or the nearest ancestor whose isTouchEnabled property is set to YES, or nil if neither this node, nor any ancestor has the isTouchEnabled property set to YES.</p>
<p>This design simplifies identifying the node that is of interest when a touch event occurs. Thus, a car may be drawn as a node assembly of many descendant nodes (doors, wheels, body, etc). If isTouchEnabled is set for the car structural node, but not each wheel, it will be the parent car node that will be returned by the touchableNode property of the car structural node, or each wheel node. This allows the user to touch a wheel, but still have the car identified as the object of interest. </p>

</div>
</div>
<a class="anchor" id="a5a4a4b22e76c0461c5bd3d5a25241660"></a><!-- doxytag: member="CC3Node::transformMatrix" ref="a5a4a4b22e76c0461c5bd3d5a25241660" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> * CC3Node::transformMatrix<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The transformation matrix derived from the location, rotation and scale transform properties of this node and any ancestor nodes. </p>
<p>This matrix is recalculated automatically when the node is updated.</p>
<p>The transformation matrix for each node is global, in that it includes the transforms of all ancestors to the node. This streamlines rendering in that it allows the transform of each drawable node to be applied directly, and allows the order in which drawable nodes are drawn to be independent of the node structural hierarchy.</p>
<p>Setting this property udpates the globalLocation and globalScale properties. </p>

</div>
</div>
<a class="anchor" id="abfe250c04fe124bb7939f2f35171186f"></a><!-- doxytag: member="CC3Node::transformMatrixInverted" ref="abfe250c04fe124bb7939f2f35171186f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> * CC3Node::transformMatrixInverted<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the matrix inversion of the transformMatrix. </p>
<p>This can be useful for converting global transform properties, such as global location, rotation and scale to the local coordinate system of the node. </p>

</div>
</div>
<a class="anchor" id="a112d11012a4d25e53e1cf431ea5c8469"></a><!-- doxytag: member="CC3Node::uniformScale" ref="a112d11012a4d25e53e1cf431ea5c8469" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Node::uniformScale<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The scale of the node, uniform in each dimension, relative to the parent of this node. </p>
<p>Unless non-uniform scaling is needed, it is preferable to use this property instead of the scale property.</p>
<p>If non-uniform scaling is applied via the scale property, this uniformScale property will return the length of the scale property vector divided by the length of a unit cube (sqrt(3.0)), as an approximation of the overall scaling condensed to a single scalar value. </p>

</div>
</div>
<a class="anchor" id="ab8d92d79ffd98917bdcce43917eb87d5"></a><!-- doxytag: member="CC3Node::visible" ref="ab8d92d79ffd98917bdcce43917eb87d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Node::visible<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Controls whether this node shoud be displayed. </p>
<p>Initial value is YES.</p>
<p>You can set this to NO to make this node and all its descendants invisible to stop them from being displayed and to stop rendering processing on them.</p>
<p>When reading this property, the return value takes into consideration whether the parent is visible. As a result, setting this property to YES and then reading it may return NO if an ancestor has visibility set to NO. </p>

</div>
</div>
<a class="anchor" id="a9ad12e8a7b4202e8cd152c64a31b70aa"></a><!-- doxytag: member="CC3Node::wireframeBoxNode" ref="a9ad12e8a7b4202e8cd152c64a31b70aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_wireframe_bounding_box_node.html">CC3WireframeBoundingBoxNode</a>* CC3Node::wireframeBoxNode<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the shouldDrawWireframeBox is set to YES, returns the child node that draws the wireframe box around this node. </p>
<p>Otherwise, returns nil. </p>

</div>
</div>
<a class="anchor" id="a43cfe3d4e71b1eaf276a54d6a65de15e"></a><!-- doxytag: member="CC3Node::world" ref="a43cfe3d4e71b1eaf276a54d6a65de15e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_world.html">CC3World</a>* CC3Node::world<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this node has been added to the 3D world, either directly, or as part of a node assembly, returns the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance that forms the 3D world, otherwise returns nil. </p>
<p>Reading this property traverses up the node hierarchy. If this property is accessed frequently, it is recommended that it be cached. </p>

</div>
</div>
<a class="anchor" id="acbb29f8d02c53f72f48d45c673d33ce4"></a><!-- doxytag: member="CC3Node::zOrder" ref="acbb29f8d02c53f72f48d45c673d33ce4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint CC3Node::zOrder<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the order in which this node should be drawn when compared to other nodes, when drawing order should be determined by distance from the camera (Z-order). </p>
<p>Sequencing nodes for drawing based on distance from the camera is necessary for translucent nodes.</p>
<p>In a drawing sequencer that sorts nodes by drawing order based on distance from the camera, the value of this property overrides the distances of the nodes from the camera. Sorting occurs on the value of this property first, and then on distance from the camera.</p>
<p>Sorting based on distance to the camera alone is quite effective. In almost all cases, it is not necessary to set the value of this property, and if nodes are moving around, setting a value to this property can actually interfere with the dynamic determination of the correct drawing order. Only use this property if you have reason to force a node to be drawn before or after another node for visual effect.</p>
<p>The smaller the value of this property, the closer to the camera the node is deemed to be. This property may be assigned a negative value.</p>
<p>The initial value of this property is zero.</p>
<p>The <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> must be configured with a drawing sequencer that sorts by Z-order for this property to be effective.</p>
<p>This property only has effect for nodes with local content to draw (instances of <a class="el" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr...">CC3LocalContentNode</a>). Setting this property passes the value to all descendant nodes. Reading this value returns the average value of all child nodes, or returns zero if there are no child nodes. </p>

<p>Implemented in <a class="el" href="interface_c_c3_local_content_node.html#a274eeaa4a5c9481c774dfa8450b04ba0">CC3LocalContentNode</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_node_8h.html">CC3Node.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_node.html">CC3Node</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:09 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
