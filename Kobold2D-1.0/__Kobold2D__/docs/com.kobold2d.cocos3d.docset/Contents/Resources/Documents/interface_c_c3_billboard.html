<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3Billboard Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_billboard.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3Billboard Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3Billboard" --><!-- doxytag: inherits="CC3MeshNode" -->
<p><code>#include &lt;CC3Billboard.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Billboard:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_billboard__inherit__graph.png" border="0" usemap="#_c_c3_billboard_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_billboard_inherit__map" id="_c_c3_billboard_inherit__map">
<area shape="rect" id="node11" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano..." alt="" coords="5,393,136,421"/><area shape="rect" id="node13" href="interface_c_c3_particle_system_billboard.html" title="A CC3Billboard node customized to display and manage a cocos2d 2D CCParticleSystem." alt="" coords="160,393,336,421"/><area shape="rect" id="node2" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh." alt="" coords="107,238,211,266"/><area shape="rect" id="node4" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="85,161,232,189"/><area shape="rect" id="node6" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="121,83,195,111"/><area shape="rect" id="node8" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="105,6,212,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3Billboard:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_billboard__coll__graph.png" border="0" usemap="#_c_c3_billboard_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_billboard_coll__map" id="_c_c3_billboard_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh." alt="" coords="71,259,175,287"/><area shape="rect" id="node4" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="49,179,196,207"/><area shape="rect" id="node6" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="85,99,159,127"/><area shape="rect" id="node8" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/><area shape="rect" id="node10" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array." alt="" coords="137,6,236,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_billboard-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#ac186a8a9df9848ee6a0121c12a52462d">alignToCamera:</a> (<a class="el" href="interface_c_c3_camera.html">CC3Camera</a> *camera)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a167dc005fac488f8db81c039566217d6">doesIntersectBounds:</a> (CGRect bounds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a364d63f410c2bb363ca0a7bc9a73e7e3">draw2dWithinBounds:</a> (CGRect bounds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a5efa472f042f75866ee334dd31dde03d">initWithBillboard:</a> (CCNode *a2DNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#ac1516daf49aaae65ebc0ec993417d0d8">initWithName:withBillboard:</a> (NSString *aName,[withBillboard] CCNode *a2DNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a8c636b3c8b739c841c2d6781ccd728d1">initWithTag:withName:withBillboard:</a> (GLuint aTag,[withName] NSString *aName,[withBillboard] CCNode *a2DNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a4dc55220a01574fd80c49bf5b3e6f626">resetBillboardBoundingRect</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a3f519d4c15a9f23b2bac7bce37719fd9">deviceScaleFactor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a467cee4b4a2c39d81cde969d68217c9b">nodeWithBillboard:</a> (CCNode *a2DNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a2a8f2d376c75258cfd4d78b9c5a9b6bb">nodeWithName:withBillboard:</a> (NSString *aName,[withBillboard] CCNode *a2DNode)</td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#ac2fce27cd6417e1e9bbfd4f5ec6116bc">billboard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a68bf62bcde2b3f3c2af1d883eae7d98b">billboardBoundingRect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a1324c538b91b816e4b1ab42b664b855d">maximumBillboardScale</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a78e9cdabfa206c83e65a26669e6d3d5d">minimumBillboardScale</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#aad89ceeef943483999d94ba3c2955d6c">offsetPosition</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#aee3367696940f4e162aa9f6c3215f64e">shouldAlwaysMeasureBillboardBoundingRect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a4cbd36ec999e2517f600e5e91af1c36b">shouldDrawAs2DOverlay</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a187a0823c2112e71054b0ca01e1a41d6">shouldMaximizeBillboardBoundingRect</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#a13596cd43c1ee52a2836aaf9b6966637">shouldNormalizeScaleToDevice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#aa1e0acc68da1aeb51ac09232cdc77d36">textureUnitIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_billboard.html#aa3145d74235f0e6c982486283b321940">unityScaleDistance</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> displays a 2D cocos2d CCNode as part of the 3D world. </p>
<p>The 2D node can be displayed in one of two ways, as determined by the value of the shouldDrawAs2DOverlay property:</p>
<ul>
<li>When shouldDrawAs2DOverlay is set to NO (the default), the 2D CCNode will be embedded in the 3D world and will be drawn at the Z-depth of this node. Like all 3D nodes, the 2D node will be occluded if other 3D nodes are between this node and the camera, it can be rotated in 3D to face away from the camera, and can be selected by touch events.</li>
</ul>
<ul>
<li>When shouldDrawAs2DOverlay is set to YES, the 2D CCNode will be drawn at the projectedPosition of this node, after the 3D world has completed drawing, and the GL engine has reverted to 2D rendering. The 2D node will ignore 3D depth testing, and will be drawn on top of all 3D nodes, even if there are other 3D nodes between this node and the camera. The 2D node will always appear to face directly towards the camera, and cannot be selected by touch events.</li>
</ul>
<p>CC3Billboards are useful for drawing a label, health-bar, speech-balloon, or some other 2D artifact in or on the 3D world, and have that 2D artifact move along with this node as it moves through the 3D world.</p>
<p><a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a> is a type of <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a>, and can therefore participate in a structural node assembly. An instance can be the child of another node, and the <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a> itself can have child nodes.</p>
<p>The size of the 2D node will be automatically scaled based on the distance between the 3D billboard node and the 3D camera to keep the 2D artifact at the correct perspective as this node moves toward or away from the camera.</p>
<p>The perspective sizing of the 2D node can be influenced by two properties: minimumBillboardScale and maximumBillboardScale, which can define a minimum and maximum limits to which the node will be sized, respectively, relative to a nominal size. This capability is useful when the 2D node is a label, health-bar, or speech-balloon, and it is desirable to keep the text at a readable size, regardless of how near or far the node moves in the 3D world, relative to the camera.</p>
<p>Since the scale of the 2D billboard is often automatically adjusted, you should be careful when setting the scale property of the 2D billboard. In particular, when the 2D node is embedded in the 3D world, (the shouldDrawAs2DOverlay property is set to the default NO), the scale property of the 2D node will be directly manipulated if the value of the shouldNormalizeScaleToDevice property on this <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a> is set to YES, and any value you set for the 2D node scale property will be ignored.</p>
<p>As with all CC3Nodes, CC3Billboards support the protocol CCRGBAProtocol. When wrapping a 2D CCNode billboard that also supports CCRGBAProtocol, changes to the <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a> color and opacity properties will change those same properties in the encapsulated 2D CCNode billboard. When reading the color and opacity properties of the <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a>, the value returned will be that of the 2D CCNode.</p>
<p>A <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a> can, and should, have a bounding volume, but the bounding volume must be an instance of a subclass of <a class="el" href="interface_c_c3_node_bounding_area.html" title="A bounding volume that defines a 2D bounding area for a node, and checks that bounding area against a...">CC3NodeBoundingArea</a>, which maps the 2D boundary of the 2D node into the 3D world, and when shouldDrawAs2DOverlay is YES, handles testing the 2D bounds of the 2D node against the bounds of the 2D drawing plane. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac186a8a9df9848ee6a0121c12a52462d"></a><!-- doxytag: member="CC3Billboard::alignToCamera:" ref="ac186a8a9df9848ee6a0121c12a52462d" args="(CC3Camera *camera)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Billboard::alignToCamera: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_camera.html">CC3Camera</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invoked automatically by the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> to configure the 2D node relative to the location of the camera, including ensuring the correct perspective. </p>
<p>If the value of the shouldDrawAs2DOverlay property is NO, the 2D node is embedded in the 3D world. As such, the 2D node will naturally be drawn with the correct perspective projection, but invoking this method enforces the sizing restrictions specified in the minimumBillboardScale and maximumBillboardScale properties.</p>
<p>If the value of the shouldDrawAs2DOverlay property is YES, the 2D node is overlaid on the 3D world at a 2D position determined by projecting the location of the node onto the camera view. This position is cached in the projectedPosition property of this node.</p>
<p>In addition, with the shouldDrawAs2DOverlay property set to YES, since the 2D node is drawn over the whole 3D world, As such, the 2D node will not have natural perspective projection. To mimic perspetive sizing, this method scales the 2D node according to the distance between this node and the camera, relative to a scale of one at the unityScaleDistance, taking into consideration the sizing restrictions specified in the minimumBillboardScale and maximumBillboardScale properties.</p>
<p>This method is invoked automatically by <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a3f519d4c15a9f23b2bac7bce37719fd9"></a><!-- doxytag: member="CC3Billboard::deviceScaleFactor" ref="a3f519d4c15a9f23b2bac7bce37719fd9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Billboard::deviceScaleFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The scaling factor used to adjust the scale of the 2D overlay node so that it's size relative to the 3D artifacts appears consistent across all device screen resolutions, if the shouldNormalizeScaleToDevice property is set to YES. </p>
<p>The value returned depends on the device screen window size and is normalized to the original iPhone/iPod Touch screen size of 480 x 320. The value returned for an original iPhone or iPod Touch will be 1.0. The value returned for other devices depends on the screen resolution, and formally, on the screen height as measured in pixels. Devices with larger screen heights in pixels will return a value greater than 1.0. Devices with smaller screen heights in pixels will return a value less than 1.0 </p>

</div>
</div>
<a class="anchor" id="a167dc005fac488f8db81c039566217d6"></a><!-- doxytag: member="CC3Billboard::doesIntersectBounds:" ref="a167dc005fac488f8db81c039566217d6" args="(CGRect bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Billboard::doesIntersectBounds: </td>
          <td>(</td>
          <td class="paramtype">CGRect&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the local content of this node intersects the given bounding rectangle. </p>
<p>This check does not include checking children, only the local content.</p>
<p>If the value of the shouldDrawAs2DOverlay property is YES, this method is invoked during the drawing operations of each frame to determine whether this node should be culled from the visible nodes and not drawn. A return value of YES will cause the node to be drawn, a return value of NO will cause the node to be culled and not drawn.</p>
<p>Culling nodes that are not visible to the camera is an important performance enhancement. The node should strive to be as accurate as possible in returning whether it intersects the viewport. Incorrectly returning YES will cause wasted processing within the GL engine. Incorrectly returning NO will cause a node that should at least be partially visible to not be drawn.</p>
<p>In this implementation, if this node has a boundingVolume, this method delegates to it. Otherwise, it simply returns YES. Subclasses may override to change this standard behaviour.</p>
<p>The boundingVolume of a <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a> must be an instance of a subclass of <a class="el" href="interface_c_c3_node_bounding_area.html" title="A bounding volume that defines a 2D bounding area for a node, and checks that bounding area against a...">CC3NodeBoundingArea</a>. </p>

</div>
</div>
<a class="anchor" id="a364d63f410c2bb363ca0a7bc9a73e7e3"></a><!-- doxytag: member="CC3Billboard::draw2dWithinBounds:" ref="a364d63f410c2bb363ca0a7bc9a73e7e3" args="(CGRect bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Billboard::draw2dWithinBounds: </td>
          <td>(</td>
          <td class="paramtype">CGRect&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the value of the shouldDrawAs2DOverlay property is YES, and the 2D node is within the given bounds, draws the 2D node at the projected 2D position calculated in the alignToCamera: method. </p>
<p>This method is invoked automatically by <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> at the end of each frame drawing cycle. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a5efa472f042f75866ee334dd31dde03d"></a><!-- doxytag: member="CC3Billboard::initWithBillboard:" ref="a5efa472f042f75866ee334dd31dde03d" args="(CCNode *a2DNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Billboard::initWithBillboard: </td>
          <td>(</td>
          <td class="paramtype">CCNode *&#160;</td>
          <td class="paramname"><em>a2DNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes this unnamed instance with an automatically generated unique tag value, and the specified 2D node to be drawn. </p>

</div>
</div>
<a class="anchor" id="ac1516daf49aaae65ebc0ec993417d0d8"></a><!-- doxytag: member="CC3Billboard::initWithName:withBillboard:" ref="ac1516daf49aaae65ebc0ec993417d0d8" args="(NSString *aName,[withBillboard] CCNode *a2DNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Billboard::initWithName:withBillboard: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withBillboard] CCNode *&#160;</td>
          <td class="paramname"><em>a2DNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes this instance with an automatically generated unique tag value, and the specified name and 2D node to be drawn. </p>

</div>
</div>
<a class="anchor" id="a8c636b3c8b739c841c2d6781ccd728d1"></a><!-- doxytag: member="CC3Billboard::initWithTag:withName:withBillboard:" ref="a8c636b3c8b739c841c2d6781ccd728d1" args="(GLuint aTag,[withName] NSString *aName,[withBillboard] CCNode *a2DNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Billboard::initWithTag:withName:withBillboard: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withName] NSString *&#160;</td>
          <td class="paramname"><em>aName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withBillboard] CCNode *&#160;</td>
          <td class="paramname"><em>a2DNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes this instance with the specified tag, name and 2D node to be drawn. </p>

</div>
</div>
<a class="anchor" id="a467cee4b4a2c39d81cde969d68217c9b"></a><!-- doxytag: member="CC3Billboard::nodeWithBillboard:" ref="a467cee4b4a2c39d81cde969d68217c9b" args="(CCNode *a2DNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Billboard::nodeWithBillboard: </td>
          <td>(</td>
          <td class="paramtype">CCNode *&#160;</td>
          <td class="paramname"><em>a2DNode</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value, and the specified 2D node to be drawn. </p>

</div>
</div>
<a class="anchor" id="a2a8f2d376c75258cfd4d78b9c5a9b6bb"></a><!-- doxytag: member="CC3Billboard::nodeWithName:withBillboard:" ref="a2a8f2d376c75258cfd4d78b9c5a9b6bb" args="(NSString *aName,[withBillboard] CCNode *a2DNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Billboard::nodeWithName:withBillboard: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withBillboard] CCNode *&#160;</td>
          <td class="paramname"><em>a2DNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with an automatically generated unique tag value, and the specified name and 2D node to be drawn. </p>

</div>
</div>
<a class="anchor" id="a4dc55220a01574fd80c49bf5b3e6f626"></a><!-- doxytag: member="CC3Billboard::resetBillboardBoundingRect" ref="a4dc55220a01574fd80c49bf5b3e6f626" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Billboard::resetBillboardBoundingRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the value of the billboardBoundingRect property so that it will be measured again from the 2D node the next time the billboardBoundingRect is accessed. </p>
<p>You can use this method after you change the 2D node is a way that changes its boundary, to force the bounding rectangle of the 2D node to be re-measured and re-cached. An example might be when you change the text of a 2D label, which will change the boundary of the label. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="ac2fce27cd6417e1e9bbfd4f5ec6116bc"></a><!-- doxytag: member="CC3Billboard::billboard" ref="ac2fce27cd6417e1e9bbfd4f5ec6116bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCNode * CC3Billboard::billboard<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The 2D artifact that this node will display. </p>
<p>This can be any CCNode subclass. </p>

</div>
</div>
<a class="anchor" id="a68bf62bcde2b3f3c2af1d883eae7d98b"></a><!-- doxytag: member="CC3Billboard::billboardBoundingRect" ref="a68bf62bcde2b3f3c2af1d883eae7d98b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGRect CC3Billboard::billboardBoundingRect<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rectangle, in pixels, bounding the 2D CCNode, in the local coordinate system of the 2D node. </p>
<p>This property is used by cocos3d when each frame is drawn, to test whether this node is within the field of view of the camera and should be drawn. It is accessed on each rendering frame. The value of this property is also used when picking nodes from touch events.</p>
<p>The value of this property can be set directly, or it can be measured automatically from the size of the 2D node when accesssed as follows:</p>
<ul>
<li>If the value of this property is left unset, the value will be lazily measured from the size of the 2D node the first time this property is accessed. The value of this property will then be cached for subsequent accesses, and will not be remeasured from the 2D node unless the resetBillboardBoundingRect method is invoked.</li>
<li>If the value of either of the shouldAlwaysMeasureBillboardBoundingRect or shouldDrawAs2DOverlay properties is YES, the value of this property will be measured from the size of the 2D node each time this property is accessed.</li>
<li>If the value of the shouldMaximizeBillboardBoundingRect property is YES, the value of this property will be measured from the size of the 2D node each time this property is accessed, and the maximum value of this property will be retained. In this situation, for a 2D node that changes shape and size over time, such as a particle system, the value of this property will grow over time to to the maximum size that the 2D node has become since this property was initialized or last reset using the resetBillboardBoundingRect method.</li>
</ul>
<p>The choice of how to use this property depends on the type of 2D node being held. If the value of the shouldDrawAs2DOverlay property is set to NO (the default), the 2D node is embedded in the 3D world, and the following applies:</p>
<ul>
<li>For static 2D nodes, such as buttons, 2D sprites, or static text labels, the simplest thing to do is leave this property with the default value and allow it to be lazily measureed from the 2D node the first time it is accessed, and cached for subsequent accesses.</li>
<li>For 2D nodes whose boundary change under app control, such as a text label, you can also allow this property to be lazily initialized, and then use the resetBillboardBoundingRect method whenever you know the size or shape of the 2D node has changed (eg- the text of the label has changed), to reset this property so that it will be measured again from the 2D node the next time this property is accessed.</li>
<li>For 2D nodes whose boundary changes dynamically, such as a text label that is frequently changed, or a 2D node whose scale or rotation changes under control of a CCAction, or a particle system, you can cause the boundary of the 2D node to be measured on each access of this property by setting the value of the shouldAlwaysMeasureBillboardBoundingRect property to YES.</li>
<li>For a particle system with many particles, measuring the boundary of the 2D every time this property is accessed (which is on each rendering frame) can be very computationally expensive. For a particle system that has a reasonable maximum boundary (like a flame, explosion, etc), you can pre-compute the boundary, and explicitly set this property to that pre-computed value. If the value of the shouldAlwaysMeasureBillboardBoundingRect property is left set to NO, then this pre-computed boundary will be retained and used for the life of the particle system, and the boundary will not be measured on each frame render.</li>
<li>To pre-compute the maximum boundary of a dynamic node like a particle system, you can temporarily set the shouldMaximizeBillboardBoundingRect property to YES (either at development time, or runtime start-up), running the particle system, and then extracting (or logging at development time) the maximum boundary that is accumulated.</li>
<li>For a particle system that spans a large amount of screen space, like rain or stars, you can either pre-compute a large boundary, or simply set the boundingVolume of this node to nil, in which case this property will be ignored, and the particle system will be drawn on every frame render, regardless of where the camera is pointed.</li>
</ul>
<p>If the shouldDrawAs2DOverlay property is set to YES, the 2D node will be drawn as a 2D overlay, and the value of this property will be measured from the 2D node each time this property is accessed. This is because the boundary of the 2D overlay node changes dynamically as either the node or the camera is moved.</p>
<p>The initial value of this property is CGRectNull. If this node contains a 2D node, the value returned will be measured from the 2D node the first time this property is accessed, and cached for future access. If this node does not contain a 2D node, this property will simply return the CGRectNull value. </p>

</div>
</div>
<a class="anchor" id="a1324c538b91b816e4b1ab42b664b855d"></a><!-- doxytag: member="CC3Billboard::maximumBillboardScale" ref="a1324c538b91b816e4b1ab42b664b855d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGPoint CC3Billboard::maximumBillboardScale<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum scale to which the 2D node will be allowed to grow as it approaches the camera. </p>
<p>Setting this property to a non-zero value will stop the 2D node from growing too large as the 3D object approaches the camera. For example, you may want to keep a name label or speech-balloon at a readable text size, even if the character it is attached to is right in front of the camera.</p>
<p>The value of this property is relative to the unityScaleDistance. The 2D node will not grow to a size larger than its size at the unity distance multiplied by the value of this property. For example, if this property is set to 2.0, the 2D node will not grow to more than twice the size it appears when at the unityScaleDistance.</p>
<p>If this property is zero, no maximum will be applied. If this property is non-zero and is equal to the minimumBillboardScale, the 2D node will always be displayed at that single scale, regardless of how near or far this node is from the camera.</p>
<p>It is possible to specify different scales for each of the X and Y dimensions, if such behaviour makes sense. </p>

</div>
</div>
<a class="anchor" id="a78e9cdabfa206c83e65a26669e6d3d5d"></a><!-- doxytag: member="CC3Billboard::minimumBillboardScale" ref="a78e9cdabfa206c83e65a26669e6d3d5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGPoint CC3Billboard::minimumBillboardScale<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The minimum scale to which the 2D node will be allowed to shrink as it moves away from the camera. </p>
<p>Setting this property to a non-zero value will stop the 2D node from shrinking away to nothing as the 3D object recedes far from the camera. For example, you may want to keep a name label or speech-balloon readable, even if the character it is attached to is far from the camera.</p>
<p>The value of this property is relative to the unityScaleDistance. The 2D node will not shrink to a size smaller than its size at the unity distance multiplied by the value of this property. For example, if this property is set to 0.5, the 2D node will not shrink to less than one-half the size it appears when at the unityScaleDistance.</p>
<p>If this property is zero, no minimum will be applied. If this property is non-zero and is equal to the maximumBillboardScale, the 2D node will always be displayed at that single scale, regardless of how near or far this node is from the camera.</p>
<p>It is possible to specify different scales for each of the X and Y dimensions, if such behaviour makes sense. </p>

</div>
</div>
<a class="anchor" id="aad89ceeef943483999d94ba3c2955d6c"></a><!-- doxytag: member="CC3Billboard::offsetPosition" ref="aad89ceeef943483999d94ba3c2955d6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGPoint CC3Billboard::offsetPosition<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An offset, measured in 2D display points, at which the 2D node should be positioned relative to the 2D projectedPosition of this node. </p>
<p>The initial value is {0, 0}. This property can be useful in helping to center or positionally justify the 2D artifact.</p>
<p>This property only has effect when the shouldDrawAs2DOverlay property is set to YES, indicating that the 2D node is being drawn as a 2D overlay to the 3D world. </p>

</div>
</div>
<a class="anchor" id="aee3367696940f4e162aa9f6c3215f64e"></a><!-- doxytag: member="CC3Billboard::shouldAlwaysMeasureBillboardBoundingRect" ref="aee3367696940f4e162aa9f6c3215f64e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Billboard::shouldAlwaysMeasureBillboardBoundingRect<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the value of the billboardBoundingRect property should be measured from the 2D node each time the billboardBoundingRect property is accessed. </p>
<p>If the values of this property and the shouldMaximizeBillboardBoundingRect property are both set to NO, the boundary of the 2D node will only be measured the first time the billboardBoundingRect is accessed.</p>
<p>You can set this property to YES for dynamic 2D nodes whose boundary changes frequently or unpredicatably.</p>
<p>You should exercise caution in deciding to set this property to YES. The billboardBoundingRect property is accessed at least once per rendering frame during node culling, and the cost of re-measuring the boundary of some types of 2D nodes can be quite high. In particular, measuring the boundary of a particle system involves iterating though every particle vertex.</p>
<p>For 2D nodes whose boundary is expensive to measure, consider leaving this property set to NO, and either pre-calculating the maximum value of the billboardBoundingRect, and setting it explicitly, or using the resetBillboardBoundingRect method to measure the boundary of the 2D node only when necessary.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a4cbd36ec999e2517f600e5e91af1c36b"></a><!-- doxytag: member="CC3Billboard::shouldDrawAs2DOverlay" ref="a4cbd36ec999e2517f600e5e91af1c36b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Billboard::shouldDrawAs2DOverlay<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance should be drawn in 2D as an overlay on top of the 3D world, or embedded into the 3D world. </p>
<p>When set to NO, the 2D CCNode will be drawn at the Z-depth of this node, and will be occluded if other 3D nodes are between this node and the camera. And, like other 3D nodes, it can be rotated in 3D to face away from the camera, and can be selected by touch events.</p>
<p>When set to YES, the 2D CCNode will be drawn after the 3D world has completed drawing, and the GL engine has reverted to 2D rendering. The 2D node will ignore 3D depth testing, and will be drawn on top of all 3D nodes, even if there are other 3D nodes between this node and the camera. The CCNode will always appear to face directly towards the camera, and cannot be selected by touch events.</p>
<p>The initial value of this property is NO, indicating that the 2D node will be embedded into the 3D world.</p>
<p>In most cases, you will simply want to leave this property with the default NO value. However, there are some cases where you want the 2D node to truly be displayed on top of the whole 3D world. An example might be an identifier label or speech-balloon attached to a character in the game. You might want to display the label or speech-balloon even when the character is not visible becuase it is behind another object, or inside a building. You can attach this node to the character node and set the value of this property to YES. The label or speech- balloon will then move around as the character moves, but will remain visible even if the character moves behind another object in the scene. </p>

</div>
</div>
<a class="anchor" id="a187a0823c2112e71054b0ca01e1a41d6"></a><!-- doxytag: member="CC3Billboard::shouldMaximizeBillboardBoundingRect" ref="a187a0823c2112e71054b0ca01e1a41d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Billboard::shouldMaximizeBillboardBoundingRect<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the value of this property is set to YES, the boundary of the 2D node will be measured each time the billboardBoundingRect property is accessed, and the resulting value will be accumulated in the billboardBoundingRect property so that the resulting value of the billboardBoundingRect property will be an ever-growing rectangle that covers all areas covered by the 2D node since initialization of this node, or since the resetBillboardBoundingRect method was last invoked. </p>
<p>If the values of this property and the shouldAlwaysMeasureBillboardBoundingRect property are both set to NO, the boundary of the 2D node will only be measured the first time the billboardBoundingRect is accessed.</p>
<p>This property can be useful when pre-computing an appropriate fixed boundary for a dynamic 2D node such as a particle system, and is often used at development time. The resulting accumulated boundary can then be explicitly set into the billboardBoundingRect property (with both this property and the shouldAlwaysMeasureBillboardBoundingRect property set to NO) so that the cost of measuring the 2D boundary is not incurred during each rendering frame at runtime.</p>
<p>If a truly dynamic boundary is required at runtime, there is no advantage to using this property instead of the shouldAlwaysMeasureBillboardBoundingRect property. The performance cost is the same, and the resulting boundary will be less accurate.</p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a13596cd43c1ee52a2836aaf9b6966637"></a><!-- doxytag: member="CC3Billboard::shouldNormalizeScaleToDevice" ref="a13596cd43c1ee52a2836aaf9b6966637" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Billboard::shouldNormalizeScaleToDevice<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the size of the 2D billboard node should be adjusted so that its size relative to the 3D artifacts appears to be the same across all devices. </p>
<p>The 3D camera frustum is consistent across all devices, making the view of the 3D scene consistent across all devices. The result is that on devices with larger screen resolutions, the 2D overlay node will be drawn across more pixels, and may appear visually larger.</p>
<p>If this property is set to YES, the scale of the 2D overlay node will be adjusted so that it appears to be the same size across all devices, relative to the 3D nodes.</p>
<p>If this property is set to NO, the 2D overlay node will be drawn in the same absolute pixel size across all devices, which may make it appear to be smaller or larger, relative to the 3D artifacts around it, on different devices.</p>
<p>This property has different effects, depending on the value of the shouldDrawAs2DOverlay property. If that property is set to YES, and the 2D node is being drawn as an overlay over the entire 3D scene, all 2D nodes will be adjusted.</p>
<p>However, if the shouldDrawAs2DOverlay property is set to NO, indicating that the 2D node is embedded in the 3D world, the 2D node will be scaled by the value of the billboardContentScaleFactor property of the 2D node. Most 2D nodes do not require scaling adjustment when being drawn embedded in the 3D world and will return 1.0 for this property. However, some 2D nodes, such as text labels and particle systems actively compensate for the screen resolution when drawing to a retina screen, and do need to be adjusted.</p>
<p>The initial value of this property is YES. </p>

</div>
</div>
<a class="anchor" id="aa1e0acc68da1aeb51ac09232cdc77d36"></a><!-- doxytag: member="CC3Billboard::textureUnitIndex" ref="aa1e0acc68da1aeb51ac09232cdc77d36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint CC3Billboard::textureUnitIndex<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The index of the GL texture unit to use when drawing the 2D CCNode. </p>
<p>The initial value of this property is zero. cocos2d uses texture unit zero by default, and in most cases it is recommended that you use this initial value.</p>
<p>The value of this property must be between zero and one less than the maximum number of supported texture units. The maximum number of texture units is platform dependent, and can be read from [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine].platform.maxTextureUnits.value. </p>

</div>
</div>
<a class="anchor" id="aa3145d74235f0e6c982486283b321940"></a><!-- doxytag: member="CC3Billboard::unityScaleDistance" ref="aa3145d74235f0e6c982486283b321940" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Billboard::unityScaleDistance<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The distance from the camera, in 3D space, at which the 2D artifact will be displayed at unity scale (its natural size). </p>
<p>This effect this property has depends on the value of the shouldDrawAs2DOverlay property.</p>
<p>If the value of the shouldDrawAs2DOverlay property is NO, the 2D node is embedded in the 3D world. As such, like all other nodes, the size of the 2D node automatically changes as this node moves closer to or farther away from the camera. As such, this property has no effect on the size of the 2D node, and is used only as a reference when calculating the effect of the minimumBillboardScale and maximumBillboardScale properties.</p>
<p>If the value of the shouldDrawAs2DOverlay property is YES, the 2D node is overlaid on the 3D world. As such, if this node is closer to the camera than the distance value of this property, the 2D artifact will be scaled up proportionally. If this node is farther from the camera than this distance, the 2D artifact will be scaled down proportionally.</p>
<p>If the value of this property is zero, the camera's near clip plane distance will be used as the unity scale distance.</p>
<p>The initial value of this property is zero. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_billboard_8h.html">CC3Billboard.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_billboard.html">CC3Billboard</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:06 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
