<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3SkinMesh Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_skin_mesh.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3SkinMesh Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3SkinMesh" --><!-- doxytag: inherits="CC3VertexArrayMesh" -->
<p><code>#include &lt;CC3VertexSkinning.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3SkinMesh:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_skin_mesh__inherit__graph.png" border="0" usemap="#_c_c3_skin_mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_skin_mesh_inherit__map" id="_c_c3_skin_mesh_inherit__map">
<area shape="rect" id="node9" href="interface_c_c3_p_o_d_skin_mesh.html" title="A CC3SkinMesh extracted from a POD file." alt="" coords="13,315,139,343"/><area shape="rect" id="node2" href="interface_c_c3_vertex_array_mesh.html" title="A CC3VertexArrayMesh is a mesh whose mesh data is kept in a set of CC3VertexArrays instances..." alt="" coords="5,161,147,189"/><area shape="rect" id="node4" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode." alt="" coords="38,83,113,111"/><area shape="rect" id="node6" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="22,6,129,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3SkinMesh:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_skin_mesh__coll__graph.png" border="0" usemap="#_c_c3_skin_mesh_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_skin_mesh_coll__map" id="_c_c3_skin_mesh_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_vertex_array_mesh.html" title="A CC3VertexArrayMesh is a mesh whose mesh data is kept in a set of CC3VertexArrays instances..." alt="" coords="5,161,147,189"/><area shape="rect" id="node4" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode." alt="" coords="38,83,113,111"/><area shape="rect" id="node6" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="22,6,129,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_skin_mesh-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a5b6215eadec766c9c8c9e829eb0edbda">doNotBufferVertexMatrixIndices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a199428a8cb09133138b062c06aead6b3">doNotBufferVertexWeights</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a3fa11f36c01fda0d7b4389c888f23d50">matrixIndexForVertexUnit:at:</a> (GLuint vertexUnit,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a1dce59b06b43a11f91154ed3d1c8ed9c">retainVertexMatrixIndices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a6e645102e33294257886bc96130b2864">retainVertexWeights</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a5be6219921bc6a42fa41243181f18cf6">setMatrixIndex:forVertexUnit:at:</a> (GLushort aMatrixIndex,[forVertexUnit] GLuint vertexUnit,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a7bdc09515c0c7be9586fb6e5f4536e4f">setWeight:forVertexUnit:at:</a> (GLfloat aWeight,[forVertexUnit] GLuint vertexUnit,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a9a78c040a4ca2d425760d9246a04f398">updateVertexMatrixIndicesGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a926b759f75e79a62d6e61212c387e5bd">updateVertexWeightsGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#ae6e447b53e60e0af1ba65fafa35a6494">weightForVertexUnit:at:</a> (GLuint vertexUnit,[at] GLsizei index)</td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_matrix_indices.html">CC3VertexMatrixIndices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#a69b7b9b6d8aecc6730f3f98ec2c0462a">boneMatrixIndices</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_vertex_weights.html">CC3VertexWeights</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_skin_mesh.html#ac9222c6e4340a7d73be290e695b866b6">boneWeights</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_skin_mesh.html" title="CC3SkinMesh is a CC3VertexArrayMesh that, in addition to the familiar vertex data such as locations...">CC3SkinMesh</a> is a <a class="el" href="interface_c_c3_vertex_array_mesh.html" title="A CC3VertexArrayMesh is a mesh whose mesh data is kept in a set of CC3VertexArrays instances...">CC3VertexArrayMesh</a> that, in addition to the familiar vertex data such as locations, normals and texture coordinates, adds vertex arrays for bone weights and bone matrix indices. </p>
<p>Each element of the <a class="el" href="interface_c_c3_vertex_matrix_indices.html" title="A CC3VertexArray that manages a collection of indices used by each vertex to point to a collection of...">CC3VertexMatrixIndices</a> vertex array in the boneMatrixIndices property is a set of index values that reference a set of bones that influence the location of that vertex.</p>
<p>Each element of the <a class="el" href="interface_c_c3_vertex_weights.html" title="A CC3VertexArray that manages a collection of weights used by each vertex during vertex skinning...">CC3VertexWeights</a> vertex array in the boneWeights property contains a corresponding set of weighting values that determine the relative influence that each of the bones identified in the boneMatrixIndices has on transforming the location of the vertex.</p>
<p>For each vertex, there is a one-to-one correspondence between each bone index values and the weights. The first weight is applied to the bone identified by the first index. Therefore, the elementSize property of the vertex arrays in the boneWeights and boneMatrixIndices properties must be the same. The value of these elementSize properties therefore effectively defines how many bones influence each vertex in these arrays, and this value must be the same for all vertices in these arrays.</p>
<p>Since the bone indexes can change from vertex to vertex, different vertices can be influenced by a different set of bones, but the absolute number of bones influencing each vertex must be consistent, and is defined by the elementSize properties. For any vertex, the weighting values define the influe that each of the bones has on the vertex. A zero value for a bone weight in a vertex indicates that location of that vertex is not affected by the tranformation of that bone.</p>
<p>There is a limit to how many bones may be assigned to each vertex, and this limit is defined by the number of vertex units supported by the platform, and the elementSize property of each of the boneMatrixIndices and boneWeights vertex arrays must not be larger than the number of available vertex units. This value can be retrieved from [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine].platform.maxVertexUnits.value.</p>
<p>This <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> subclass adds a number of methods for accessing and managing the weights and matrix index data associated with each vertex. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5b6215eadec766c9c8c9e829eb0edbda"></a><!-- doxytag: member="CC3SkinMesh::doNotBufferVertexMatrixIndices" ref="a5b6215eadec766c9c8c9e829eb0edbda" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::doNotBufferVertexMatrixIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex matrix index data to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex matrix index will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexMatrixIndices method. </p>

</div>
</div>
<a class="anchor" id="a199428a8cb09133138b062c06aead6b3"></a><!-- doxytag: member="CC3SkinMesh::doNotBufferVertexWeights" ref="a199428a8cb09133138b062c06aead6b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::doNotBufferVertexWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex weight data to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex weight will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexWeights method. </p>

</div>
</div>
<a class="anchor" id="a3fa11f36c01fda0d7b4389c888f23d50"></a><!-- doxytag: member="CC3SkinMesh::matrixIndexForVertexUnit:at:" ref="a3fa11f36c01fda0d7b4389c888f23d50" args="(GLuint vertexUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLushort CC3SkinMesh::matrixIndexForVertexUnit:at: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>vertexUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the matrix index element, for the specified vertex unit, at the specified index in the underlying vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>Several matrix indices are stored for each vertex, one per vertex unit, corresponding to one for each bone that influences the location of the vertex. The specified vertexUnit parameter must be between zero inclusive, and the elementSize property, exclusive.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a1dce59b06b43a11f91154ed3d1c8ed9c"></a><!-- doxytag: member="CC3SkinMesh::retainVertexMatrixIndices" ref="a1dce59b06b43a11f91154ed3d1c8ed9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::retainVertexMatrixIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex matrix index data to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex matrix index will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a6e645102e33294257886bc96130b2864"></a><!-- doxytag: member="CC3SkinMesh::retainVertexWeights" ref="a6e645102e33294257886bc96130b2864" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::retainVertexWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex weight data to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex weight will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a5be6219921bc6a42fa41243181f18cf6"></a><!-- doxytag: member="CC3SkinMesh::setMatrixIndex:forVertexUnit:at:" ref="a5be6219921bc6a42fa41243181f18cf6" args="(GLushort aMatrixIndex,[forVertexUnit] GLuint vertexUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::setMatrixIndex:forVertexUnit:at: </td>
          <td>(</td>
          <td class="paramtype">GLushort&#160;</td>
          <td class="paramname"><em>aMatrixIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forVertexUnit] GLuint&#160;</td>
          <td class="paramname"><em>vertexUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the matrix index element, for the specified vertex unit, at the specified index in the underlying vertex data, to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>Several matrix indices are stored for each vertex, one per vertex unit, corresponding to one for each bone that influences the location of the vertex. The specified vertexUnit parameter must be between zero inclusive, and the elementSize property, exclusive.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexMatrixIndicesGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a7bdc09515c0c7be9586fb6e5f4536e4f"></a><!-- doxytag: member="CC3SkinMesh::setWeight:forVertexUnit:at:" ref="a7bdc09515c0c7be9586fb6e5f4536e4f" args="(GLfloat aWeight,[forVertexUnit] GLuint vertexUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::setWeight:forVertexUnit:at: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>aWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forVertexUnit] GLuint&#160;</td>
          <td class="paramname"><em>vertexUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the weight element, for the specified vertex unit, at the specified index in the underlying vertex data, to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>Several weights are stored for each vertex, one per vertex unit, corresponding to one for each bone that influences the location of the vertex. The specified vertexUnit parameter must be between zero inclusive, and the elementSize property, exclusive.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexWeightsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a9a78c040a4ca2d425760d9246a04f398"></a><!-- doxytag: member="CC3SkinMesh::updateVertexMatrixIndicesGLBuffer" ref="a9a78c040a4ca2d425760d9246a04f398" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::updateVertexMatrixIndicesGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex weight data in this mesh. </p>

</div>
</div>
<a class="anchor" id="a926b759f75e79a62d6e61212c387e5bd"></a><!-- doxytag: member="CC3SkinMesh::updateVertexWeightsGLBuffer" ref="a926b759f75e79a62d6e61212c387e5bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3SkinMesh::updateVertexWeightsGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex weight data in this mesh. </p>

</div>
</div>
<a class="anchor" id="ae6e447b53e60e0af1ba65fafa35a6494"></a><!-- doxytag: member="CC3SkinMesh::weightForVertexUnit:at:" ref="ae6e447b53e60e0af1ba65fafa35a6494" args="(GLuint vertexUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3SkinMesh::weightForVertexUnit:at: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>vertexUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the weight element, for the specified vertex unit, at the specified index in the underlying vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>Several weights are stored for each vertex, one per vertex unit, corresponding to one for each bone that influences the location of the vertex. The specified vertexUnit parameter must be between zero inclusive, and the elementSize property, exclusive.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a69b7b9b6d8aecc6730f3f98ec2c0462a"></a><!-- doxytag: member="CC3SkinMesh::boneMatrixIndices" ref="a69b7b9b6d8aecc6730f3f98ec2c0462a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_vertex_matrix_indices.html">CC3VertexMatrixIndices</a> * CC3SkinMesh::boneMatrixIndices<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The vertex array that manages the indices of the bones that influence each vertex. </p>
<p>Each element of the vertex array in this property is a small set of index values that reference a set of bones that influence the location of that vertex.</p>
<p>The elementSize property of the vertex arrays in the boneWeights and boneMatrixIndices properties must be the same, and must not be larger than the maximum number of available vertex units for the platform, which can be retreived from [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine].platform.maxVertexUnits.value. </p>

</div>
</div>
<a class="anchor" id="ac9222c6e4340a7d73be290e695b866b6"></a><!-- doxytag: member="CC3SkinMesh::boneWeights" ref="ac9222c6e4340a7d73be290e695b866b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_vertex_weights.html">CC3VertexWeights</a> * CC3SkinMesh::boneWeights<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The vertex array that manages the weighting that each bone has in influencing each vertex. </p>
<p>Each element of the vertex array in this property contains a small set of weighting values that determine the relative influence that each of the bones identified for that vertex in the boneMatrixIndices property has on transforming the location of the vertex.</p>
<p>The elementSize property of the vertex arrays in the boneWeights and boneMatrixIndices properties must be the same, and must not be larger than the maximum number of available vertex units for the platform, which can be retreived from [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine].platform.maxVertexUnits.value. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_vertex_skinning_8h.html">CC3VertexSkinning.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_skin_mesh.html">CC3SkinMesh</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:11 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
