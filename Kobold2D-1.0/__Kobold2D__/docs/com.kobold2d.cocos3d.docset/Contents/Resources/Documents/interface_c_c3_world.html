<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3World Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_world.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3World Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3World" --><!-- doxytag: inherits="CC3Node" -->
<p><code>#include &lt;CC3World.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3World:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_world__inherit__graph.png" border="0" usemap="#_c_c3_world_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_world_inherit__map" id="_c_c3_world_inherit__map">
<area shape="rect" id="node2" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="21,83,95,111"/><area shape="rect" id="node4" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3World:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_world__coll__graph.png" border="0" usemap="#_c_c3_world_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_world_coll__map" id="_c_c3_world_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="85,99,159,127"/><area shape="rect" id="node4" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/><area shape="rect" id="node6" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array." alt="" coords="137,6,236,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_world-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a85c477dea3dd3301c20a9a8baabb5ec9">addContentFromPODFile:</a> (NSString *aFilepath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#acba211f220ad44235806444ac288ee50">addContentFromPODFile:withName:</a> (NSString *aFilepath,[withName] NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a8dcd154fd87663fb7c3ece8d7002ff45">addContentFromPODResourceFile:</a> (NSString *aRezPath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a156d04fd2670ab10a21a4a92d933fdab">addContentFromPODResourceFile:withName:</a> (NSString *aRezPath,[withName] NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a39962d64ab703ef7c7cf77bf2ee09c1b">drawVisitorClass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a8257999067576dd3ef68110e544a03a6">drawWorld</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a80ab922e5f2bacbd4a004b47dc1c936b">initializeWorld</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a9ecead38d3efbc3d2789e3787c5d13d5">nodeSelected:byTouchEvent:at:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[byTouchEvent] uint touchType,[at] CGPoint touchPoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a81a5584dc08435d3d776f05dff9ce4ce">pause</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a50d35f77d98326b52c69a49262e26c4d">pickVisitorClass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a4763d74580552d55e46ebdee3794c51f">play</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#aaa9c646456d5b441fda5944fa74f1cd4">touchEvent:at:</a> (uint touchType,[at] CGPoint touchPoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a55e61fb1704bca5917081b69640e0050">updateVisitorClass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a8f03e596eda611ff33cf0deca9b081fb">updateWorld</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a96a67f998773213dff47d1f11ab78b25">updateWorld:</a> (ccTime dt)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a159a26eccf5b8dcb180edd86c801e3e2">world</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5f6507ebfce0cd2fc93ebb3a38c3982"></a><!-- doxytag: member="CC3World::billboards" ref="ab5f6507ebfce0cd2fc93ebb3a38c3982" args="" -->
CCArray *&#160;</td><td class="memItemRight" valign="bottom"><b>billboards</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e25b4a965dcaacd3090a3d641e8982f"></a><!-- doxytag: member="CC3World::cameras" ref="a7e25b4a965dcaacd3090a3d641e8982f" args="" -->
CCArray *&#160;</td><td class="memItemRight" valign="bottom"><b>cameras</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29925a8589f1cf792de4623426d78648"></a><!-- doxytag: member="CC3World::lights" ref="a29925a8589f1cf792de4623426d78648" args="" -->
CCArray *&#160;</td><td class="memItemRight" valign="bottom"><b>lights</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d1d6f12ce41540f8a2a0108c5478cd2"></a><!-- doxytag: member="CC3World::targettingNodes" ref="a9d1d6f12ce41540f8a2a0108c5478cd2" args="" -->
CCArray *&#160;</td><td class="memItemRight" valign="bottom"><b>targettingNodes</b></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_camera.html">CC3Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a60c88e4c67cd30393e5d5612dd4259c6">activeCamera</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a11c4c38fed3e5c48c09249a31a158154">ambientLight</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_layer.html">CC3Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#acca4e761f942e4473cb317102fc9dfbc">cc3Layer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_sequencer.html">CC3NodeSequencer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#ae40fd28ab2f13568e9877c917427cc9d">drawingSequencer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_sequencer_visitor.html">CC3NodeSequencerVisitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a698ade173d82d5a28f2346f8f4830f18">drawingSequenceVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#ad0e1712b746067328c4292a6d7bcde85">drawVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_fog.html">CC3Fog</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a99bc8b6e37b8506517e52a0eb436ada3">fog</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a117ad5c56b93f0b1f2b06a3022be79f6">isUsingDrawingSequence</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#acacd7e19e4cf69671812dae706775997">maxUpdateInterval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a50041d65fe611309060e23e0b68a1413">minUpdateInterval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_performance_statistics.html">CC3PerformanceStatistics</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a75034883f24c2a436d2bc72bf0dca52e">performanceStatistics</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a05eaae1b50852df0166d902cb212593c">shouldClearDepthBufferBefore2D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a67c4b667cd476c32dcf0503fbf0ce700">shouldClearDepthBufferBefore3D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_touched_node_picker.html">CC3TouchedNodePicker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a454fae6d00bfe5cca3cbff4fc8c533c4">touchedNodePicker</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_transforming_visitor.html">CC3NodeTransformingVisitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a2cef1389cd02f253ff6487102a441baf">transformVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#af838ecc6aa6577fb220c5068adc6b482">updateVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_viewport_manager.html">CC3ViewportManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_world.html#a5e1304a3ece0063bac3401b199f855f4">viewportManager</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is a <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> that manages a 3D scene. </p>
<p><a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> has the following responsibilities:</p>
<ul>
<li>Acts as the root of the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> structural assembly for the scene</li>
<li>Manages updating scene activity, including nodes, lights, and the camera based on a periodic animation trigger from the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a></li>
<li>Manages the drawing of the 3D artifacts to the GL engine</li>
<li>Manages the transition from 2D to 3D behaviour during each drawing frame</li>
<li>Manages the ordering of drawing of the 3D objects to maximize performance</li>
<li>facilitates user interaction with the world by interacting with UI events occuring in the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> controls</li>
<li>supports selection of 3D nodes via UI touch events</li>
<li>collects performance statistics</li>
</ul>
<p>When creating a 3D application, you will almost always create a subclass of <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> to define the control, features, and behaviour of your 3D world suitable to your application. In your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> subclass, your will typically override one or more of the following template methods:</p>
<ul>
<li>initializeWorld - assemble the objects of your 3D world, or load them from files.</li>
</ul>
<ul>
<li>updateBeforeTransform: - periodically update the activity of your 3D world prior to the automatic recalulation of the node's transformation matrix, and prior to the automatic invoking the same method on each of child node of this node.</li>
</ul>
<ul>
<li>updateAfterTransform: - periodically update the activity of your 3D world after the automatic recalulation of the node's transformMatrix and prior to the automatic invoking the same method on each of child node of this node.</li>
</ul>
<p>In these methods, you can manipulate most nodes by setting their properties. You can move and orient nodes using the node's location, rotation and scale properties, and can show or hide nodes with the node's visible property.</p>
<p>You should override the updateBeforeTransform: method if you need to make changes to the transform properties (location, rotation, scale), of any node. These changes will them automatically be applied to the transformMatrix of the node and its child nodes.</p>
<p>You should override the updateAfterTransform: method if you need access to the global transform properties (globalLocation, globalRotation, globalScale), of a node since these properties are only valid after the transformMatrix has been recalculated. An example of where access to the global transform properties would be useful is in the execution of collision detection algorithms.</p>
<p>To access nodes in your world, you can use the method getNodeNamed: on the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> (or any node). However, if you need to access the same node repeatedly, for example to update it on every frame, it's highly recommended that you retrieve it once and then cache it in an instance variable in your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance.</p>
<p>By default, the initializeWorld, updateBeforeTransform:, and updateAfterTransform: methods do nothing. Subclasses do not need to invoke this default superclass implementations in the overridden methods. The updateBeforeTransform: and updateAfterTransform: methods are defined in the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> class. See the documentation there.</p>
<p>If you change the contents of the world outside of the normal update mechanism, for instance, as a result of a user event, you may find that the next frame is rendered without the updated content. Depending on the degree of change to your world (for instance, if you have removed and added many nodes), you may notice a flicker. To avoid this, you can use the updateWorld method to force your updates to be processed immediately, without waiting for the next update interval.</p>
<p>You must add at least one <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> to your 3D world to make it viewable. This camera may be added directly, or it may be added as part of a larger node assembly. Regardless of the technique used to add cameras, the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> will take the first camera added and automatically make it the activeCamera.</p>
<p>The camera can also be used to project global locations within the 3D world onto a 2D point on the screen view, and can be used to project 2D screen points onto a ray or plane intersection within the 3D world. See the class notes of <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> for more information on mapping between 3D and 2D locations.</p>
<p>You can add fog to your world using the fog property. Fog has a color and blends with the display of objects within the world. Objects farther away from the camera are affected by the fog more than objects that are closer to the camera.</p>
<p>During drawing, the nodes can be traversed in the hierarchical order of the node structural assembly, starting at the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance that forms the root node of the node assembly. Alternately, and preferrably, the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> can use a <a class="el" href="interface_c_c3_node_sequencer.html" title="A CC3NodeSequencer instance organizes nodes that are added to it.">CC3NodeSequencer</a> instance to arrange the nodes into a linear sequence, ordered and grouped based on definable sorting priorities. This is beneficial, because it allows the application to order and group drawing operations in ways that reduce the number and scope of state changes within the GL engine, thereby improving performance and throughput.</p>
<p>For example, when drawing, nodes could be grouped by the drawing sequencer so that opaque objects are drawn prior to blended objects, and an application with many objects that use the same material or mesh can be sorted so that nodes with like materials or meshes are grouped together. It is highly recommended that you use a <a class="el" href="interface_c_c3_node_sequencer.html" title="A CC3NodeSequencer instance organizes nodes that are added to it.">CC3NodeSequencer</a>, and this is the default configuration for <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instances.</p>
<p>The <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> maintains this drawing sequence separately from the hierarchical node assembly. This allows the maintenance of the hierarchical parent-child relationships for operations such as movement and transformations, while simultaneously enabling more efficient drawing operations through node drawing sequencing.</p>
<p>An instance of <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is held by an instance of <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, which is a subclass of the cocos2d CCLayer class, and can participate with other cocos2d layers and CCNodes in an overall cocos2d scene. During drawing, the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> delegates all 3D operations to its <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance. You will also typically create a subclass of <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that is customized for your application. In most cases, you will add methods and state to both your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> and <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> subclasses to facilitate user interaction.</p>
<p>The <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> and <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> can process touch events. To enable touch event handling, set the isTouchEnabled property of your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> to YES. Touch events are forwarded from the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> to the touchEvent:at: method of your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> for handling by your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>.</p>
<p>Since the touch-move events are both voluminous and seldom used, the implementation of ccTouchMoved:withEvent: has been left out of the default <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> implementation. To receive and handle touch-move events for object picking, copy the commented-out ccTouchMoved:withEvent: template method implementation in <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> to your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> subclass.</p>
<p>The default implementation of the touchEvent:at: method forwards all touch events to the node picker held in the touchedNodePicker property. The node picker determines which 3D node is under the touch point. Object picking is handled asynchronously, and once the node is retrieved, the nodeSelected:byTouchEvent:at: callback method will be invoked on your customized <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance. You indicate which nodes in your world should respond to touch events by setting the isTouchEnabled property on those nodes that you want to trigger a touch event callback to the nodeSelected:byTouchEvent:at: method. See the description of the nodeSelected:byTouchEvent:at: method and the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> isTouchEnabled property for useful hints about choosing which nodes to enable for touch selection.</p>
<p>Be aware that node picking from touch events is expensive, and you should override the touchEvent:at: method to forward to the node picker only those touch events that you actually intend to select a node. By default, all touch events are forwarded from the touchEvent:at: method. You should override this implementation, handle touch events that are not used for selection directly in this method, and forward only those events for which you want a node picked, to the touchedNodePicker.</p>
<p>The node picker uses a colorization algorithm to determine which node is under the touch point. When a touch event occurs and has been forwarded to the node picker, the node picker draws the scene in solid colors, with each node a different color, and then reads the color of the pixel under the touch point to identify the object under the touch point. This is performed under the covers, and the scene is immediately redrawn in true colors and textures before being presented to the screen, so the user is never aware that the scene was drawn twice. However, be aware that, if a translucent or transparent object has nothing but the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> background color behind it, AND that <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> background color is also translucent or transparent, you might notice an unavoidable flicker of the translucent node. To avoid this, you can use a backdrop or skybox in your 3D world. This issue only occurs during node picking, and only when BOTH the node and the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> background colors are translucent or transparent, and the backgound color is directly behind the node.</p>
<p>Depending on the complexity of the application, it may instantiate a single <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, instance, or multiple instances if the application progresses from scene to scene. Similarly, the application may have a single <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, or multiple CC3Layers. Each <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> may have its own <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance, or may share a single instance.</p>
<p>To maximize GL throughput, all OpenGL ES 1.1 state is tracked by the singleton instance [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine]. <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> only sends state change calls to the GL engine if GL state really is changing. It is critical that all changes to GL state are made through the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton. When adding or overriding functionality in this framework, do NOT make gl* function calls directly if there is a corresponding state change tracker in the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton. Route the state change request through the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton instead.</p>
<p>You can collect statistics about the performance of your cocos3d application by setting the performanceStatistics property to an appropriate instance of a statistics collector. By default, no statistics are collected. See the notes of the performanceStatistics property for more information. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a85c477dea3dd3301c20a9a8baabb5ec9"></a><!-- doxytag: member="CC3World::addContentFromPODFile:" ref="a85c477dea3dd3301c20a9a8baabb5ec9" args="(NSString *aFilepath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_world.html">CC3World</a>(PVRPOD)::addContentFromPODFile: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aFilepath</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiates an instance of <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a>, loads it from the POD file at the specified path, which must be an absolute path, and adds the <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a> instance as a child node to this <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance. </p>
<p>The name of the resource node will be that of the file. </p>

</div>
</div>
<a class="anchor" id="acba211f220ad44235806444ac288ee50"></a><!-- doxytag: member="CC3World::addContentFromPODFile:withName:" ref="acba211f220ad44235806444ac288ee50" args="(NSString *aFilepath,[withName] NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_world.html">CC3World</a>(PVRPOD)::addContentFromPODFile:withName: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aFilepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withName] NSString *&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiates an instance of <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a> with the specified name, loads it from the POD file at the specified path, which must be an absolute path, and adds the <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a> instance as a child node to this <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance. </p>

</div>
</div>
<a class="anchor" id="a8dcd154fd87663fb7c3ece8d7002ff45"></a><!-- doxytag: member="CC3World::addContentFromPODResourceFile:" ref="a8dcd154fd87663fb7c3ece8d7002ff45" args="(NSString *aRezPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_world.html">CC3World</a>(PVRPOD)::addContentFromPODResourceFile: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aRezPath</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiates an instance of <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a>, loads it from the POD file at the specified resource path, and adds the <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a> instance as a child node to this <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance. </p>
<p>The name of the resource node will be that of the file.</p>
<p>The specified file path is a path relative to the resource directory. Typically this means that the specified path can just be the name of the file, with no path information. </p>

</div>
</div>
<a class="anchor" id="a156d04fd2670ab10a21a4a92d933fdab"></a><!-- doxytag: member="CC3World::addContentFromPODResourceFile:withName:" ref="a156d04fd2670ab10a21a4a92d933fdab" args="(NSString *aRezPath,[withName] NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_world.html">CC3World</a>(PVRPOD)::addContentFromPODResourceFile:withName: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aRezPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withName] NSString *&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiates an instance of <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a> with the specified name, loads it from the POD file at the specified resource path, and adds the <a class="el" href="interface_c_c3_p_o_d_resource_node.html" title="A CC3ResourceNode that that wraps a CC3PODResource PVR POD resource.">CC3PODResourceNode</a> instance as a child node to this <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance. </p>
<p>The specified file path is a path relative to the resource directory. Typically this means that the specified path can just be the name of the file, with no path information. </p>

</div>
</div>
<a class="anchor" id="a39962d64ab703ef7c7cf77bf2ee09c1b"></a><!-- doxytag: member="CC3World::drawVisitorClass" ref="a39962d64ab703ef7c7cf77bf2ee09c1b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3World::drawVisitorClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the class of visitor that will automatically be instantiated into the drawVisitor property. </p>
<p>The returned class must be a subclass of <a class="el" href="interface_c_c3_node_drawing_visitor.html" title="CC3NodeDrawingVisitor is a CC3NodeVisitor that is passed to a node when it is visited during drawing ...">CC3NodeDrawingVisitor</a>. This implementation returns <a class="el" href="interface_c_c3_node_drawing_visitor.html" title="CC3NodeDrawingVisitor is a CC3NodeVisitor that is passed to a node when it is visited during drawing ...">CC3NodeDrawingVisitor</a>. Subclasses may override to customize the behaviour of the drawing visits. </p>

</div>
</div>
<a class="anchor" id="a8257999067576dd3ef68110e544a03a6"></a><!-- doxytag: member="CC3World::drawWorld" ref="a8257999067576dd3ef68110e544a03a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::drawWorld </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is invoked periodically when the objects in the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> are to be drawn. </p>
<p>Typcially this method is invoked automatically from the draw method of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> instance. This method is invoked asynchronously to the model updating loop, to keep the processing of OpenGL ES drawing separate from model updates.</p>
<p>To maximize GL throughput, all OpenGL ES 1.1 state is tracked by the singleton instance [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine]. <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> only sends state change calls to the GL engine if GL state really is changing. It is critical that all changes to GL state are made through the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton. When overriding this method, or any other 3D drawing features, do NOT make gl* function calls directly if there is a corresponding state change tracker in the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton. Route the state change request through the <a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> singleton instead.</p>
<p>This method is invoked automatically during each rendering frame. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a80ab922e5f2bacbd4a004b47dc1c936b"></a><!-- doxytag: member="CC3World::initializeWorld" ref="a80ab922e5f2bacbd4a004b47dc1c936b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::initializeWorld </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This template method is where a subclass should populate the 3D world models. </p>
<p>This can be accomplished through a combination of instantiting model objects directly and loading them from model data files exported from a 3D editor.</p>
<p>This <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance forms the base of a structural tree of nodes. Model objects are added as nodes to this root node instance using the addChild: method.</p>
<p>When loading from files, or adding large node assemblies, you can access individual nodes using the getNodeNamed: method, if you need to set futher initial state.</p>
<p>If you will need to access the same node repeatedly, for example to update it on every frame, it's highly recommended that you retrieve it once in this method, and cache it in an instance variable in your <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> subclass instance.</p>
<p>You must add at least one <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> to your 3D world to make it viewable. This can be instantiated directly, or loaded from a file as part of a node assembly.</p>
<p>By default, this method does nothing. Subclasses do not need to invoke this default superclass implementation in the overridden method. </p>

</div>
</div>
<a class="anchor" id="a9ecead38d3efbc3d2789e3787c5d13d5"></a><!-- doxytag: member="CC3World::nodeSelected:byTouchEvent:at:" ref="a9ecead38d3efbc3d2789e3787c5d13d5" args="(CC3Node *aNode,[byTouchEvent] uint touchType,[at] CGPoint touchPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::nodeSelected:byTouchEvent:at: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byTouchEvent] uint&#160;</td>
          <td class="paramname"><em>touchType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] CGPoint&#160;</td>
          <td class="paramname"><em>touchPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This callback template method is invoked automatically from the touchedNodePicker when a node has been picked as a result of a touch event. </p>
<p>The specified node will be one of the visible nodes whose isTouchable property returns YES, or will be nil if the touch event occurred in an area under which there is no 3D node that is touch enabled.</p>
<p>For node assemblies, the specified node will not necessarily be the individual component or leaf node that was touched. The specified node will be the closest structural ancestor of the leaf node that has the isTouchEnabled property set to YES.</p>
<p>For example, if the node representing a wheel of a car is touched, it may be more desireable to identify the car as being the object of interest to be selected, instead of the wheel. In this case, setting the isTouchEnabled property to YES on the car, but to NO on the wheel, will allow the wheel to be touched, but the node received by this callback will be the car structural node.</p>
<p>The touchType is one of the enumerated touch types: kCCTouchBegan, kCCTouchMoved, kCCTouchEnded, or kCCTouchCancelled. The touchPoint is the location in 2D coordinate system of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> where the touch occurred.</p>
<p>This callback is received as part of the update processing loop, and is invoked before the invocation of either the updateBeforeTransform: and updateAfterTransform: methods. This callback is invoked only once per event.</p>
<p>To enable touch events, set the isTouchEnabled property of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>.</p>
<p>Since the touch-move events are both voluminous and seldom used, the handling of ccTouchMoved:withEvent: has been left out of the default <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> implementation. To receive and handle touch-move events for object picking, copy the commented-out ccTouchMoved:withEvent: template method implementation in <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> to your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> subclass.</p>
<p>In addition, node selection is expensive, and you should only propagate touch events from touchEvent:at: that actually intend to select a node. By default, all touch events are propagated from touchEvent:at:, but in practice, you should override that method and handle touch events that are not used for selection in that method.</p>
<p>For example, if you want to let a user touch an object and move it around with their finger, only the initial touch-down event needs to select a node. Once the node is selected, you can cache the node, and move it and release it by capturing the touch-move and touch-up events in the touchEvent:at: method, and avoid propagating them to the selection mechanism.</p>
<p>To enable a node to be selectable by touching, set the isTouchEnabled property of that node, or an ancestor node to YES.</p>
<p>This implementation does nothing. Subclasses that are interested in node picking will override.</p>
<p>Usually, you would not invoke this method directly. This method is invoked automatically whenever a touch event occurs and is processed by the touchEvent:at: method. If you are handling touch events, multi-touch events, or gestures within your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, invoke the touchEvent:at: method to initiate node selection, and implement this callback method to determine what to do with selected nodes. </p>

</div>
</div>
<a class="anchor" id="a81a5584dc08435d3d776f05dff9ce4ce"></a><!-- doxytag: member="CC3World::pause" ref="a81a5584dc08435d3d776f05dff9ce4ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pauses the dynamics of the 3D world model, including internal updates and CCActions, by setting the isRunning property to NO. </p>
<p>The world will automatically start playing when added to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, and will automatically pause when removed from the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. During typical use, you will not need to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a50d35f77d98326b52c69a49262e26c4d"></a><!-- doxytag: member="CC3World::pickVisitorClass" ref="a50d35f77d98326b52c69a49262e26c4d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3World::pickVisitorClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the class of visitor that will be instantiated in the touchedNodePicker pickTouchedNode method, in order to paint each node a unique color so that the node under the touched pixel can be identified. </p>
<p>The returned class must be a subclass of <a class="el" href="interface_c_c3_node_picking_visitor.html" title="CC3NodePickingVisitor is a CC3NodeDrawingVisitor that is passed to a node when it is visited during n...">CC3NodePickingVisitor</a>. This implementation returns <a class="el" href="interface_c_c3_node_picking_visitor.html" title="CC3NodePickingVisitor is a CC3NodeDrawingVisitor that is passed to a node when it is visited during n...">CC3NodePickingVisitor</a>. Subclasses may override to customized the behaviour of the drawing visits. </p>

</div>
</div>
<a class="anchor" id="a4763d74580552d55e46ebdee3794c51f"></a><!-- doxytag: member="CC3World::play" ref="a4763d74580552d55e46ebdee3794c51f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::play </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the dynamics of the 3D world model, including internal updates and CCActions, by setting the isRunning property to YES. </p>
<p>The world will automatically start playing when added to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, and will automatically pause when removed from the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. During typical use, you will not need to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="aaa9c646456d5b441fda5944fa74f1cd4"></a><!-- doxytag: member="CC3World::touchEvent:at:" ref="aaa9c646456d5b441fda5944fa74f1cd4" args="(uint touchType,[at] CGPoint touchPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::touchEvent:at: </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>touchType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] CGPoint&#160;</td>
          <td class="paramname"><em>touchPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is invoked from the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> whenever a touch event occurs, if that layer has indicated that it is interested in receiving touch events, and is handling them. </p>
<p>The touchType is one of the enumerated touch types: kCCTouchBegan, kCCTouchMoved, kCCTouchEnded, or kCCTouchCancelled, and may have originated as a single-touch event, a multi-touch event, or a gesture event.</p>
<p>To enable touch events, set the isTouchEnabled property of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. Once the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> is touch-enabled, this method is invoked automatically whenever a single-touch event occurs.</p>
<p>Since the touch-move events are both voluminous and seldom used, the handling of ccTouchMoved:withEvent: has been left out of the default <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> implementation. To receive and handle touch-move events for object picking, copy the commented-out ccTouchMoved:withEvent: template method implementation in <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> to your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> subclass.</p>
<p>This default implementation forwards touch-down events to the node picker held in the touchedNodePicker property, which determines which 3D node is under the touch point, and does nothing with touch-move and touch-up events. For the touch-down events, object picking is handled asynchronously, and once the node is retrieved, the nodeSelected:byTouchEvent:at: callback method will be invoked on this instance.</p>
<p>Node picking from touch events is somewhat expensive. If you do not require node picking, you should override this implementation and avoid forwarding the touch-down events to the node picker. You can also override this method to enhance the touch interaction, such as swipe detection, or dragging &amp; dropping objects. You can use the implementation of this method as a template for enhancements.</p>
<p>For example, if you want to let a user touch an object and move it around with their finger, only the initial touch-down event needs to select a node. Once the node is selected, you can cache the node, and move it and release it by capturing the touch-move and touch-up events in this method.</p>
<p>To support multi-touch events or gestures, add event-handing behaviour to your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, as you would for any cocos2d application, and invoke this method from your customized <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> when interaction with 3D objects, such as node-picking, is required. </p>

</div>
</div>
<a class="anchor" id="a55e61fb1704bca5917081b69640e0050"></a><!-- doxytag: member="CC3World::updateVisitorClass" ref="a55e61fb1704bca5917081b69640e0050" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3World::updateVisitorClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the class of visitor that will automatically be instantiated into the updateVisitor property. </p>
<p>The returned class must be a subclass of <a class="el" href="interface_c_c3_node_updating_visitor.html" title="CC3NodeUpdatingVisitor is a CC3NodeVisitor that is passed to a node when it is visited during updatin...">CC3NodeUpdatingVisitor</a>. This implementation returns <a class="el" href="interface_c_c3_node_updating_visitor.html" title="CC3NodeUpdatingVisitor is a CC3NodeVisitor that is passed to a node when it is visited during updatin...">CC3NodeUpdatingVisitor</a>. Subclasses may override to customize the behaviour of the updating visits. </p>

</div>
</div>
<a class="anchor" id="a8f03e596eda611ff33cf0deca9b081fb"></a><!-- doxytag: member="CC3World::updateWorld" ref="a8f03e596eda611ff33cf0deca9b081fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::updateWorld </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invokes the udpateWorld: method with the value of the minUpdateInterval property. </p>
<p>This method temporarily ensures that the isRunning property is set to YES internally, to ensure that the updateWorld: method will run successfully.</p>
<p>You can use this method if you change the contents of the world outside of the normal update mechanism, for instance, as a result of a user event, and need the update to be processed immediately, without waiting for the next update interval, and even if the world has not been set running yet via the play method, or isRunning property.</p>
<p>This method is automatically invoked when a the world is assigned to the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, and when the world is added to a running <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, to ensure that transforms have been processed before the first rendering frame draws the contents of the world. </p>

</div>
</div>
<a class="anchor" id="a96a67f998773213dff47d1f11ab78b25"></a><!-- doxytag: member="CC3World::updateWorld:" ref="a96a67f998773213dff47d1f11ab78b25" args="(ccTime dt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3World::updateWorld: </td>
          <td>(</td>
          <td class="paramtype">ccTime&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method is invoked periodically when the components in the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> are to be updated. </p>
<p>Typcially this method is invoked automatically from a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> instance via a scheduled update, but may also be invoked by some other periodic operation, or even directly by the application.</p>
<p>This method is invoked asynchronously to the frame rendering animation loop, to keep the processing of model updates separate from OpenGL ES drawing.</p>
<p>The dt argument gives the interval, in seconds, since the previous update. This value can be used to create realistic real-time motion that is independent of specific frame or update rates. If either of the minUpdateInterval or maxUpdateInterval properties have been set, this method will clamp dt to those limits. See the description of minUpdateInterval and maxUpdateInterval for more information about clamping the update interval.</p>
<p>If this instance is not running, as indicated by the isRunning property, this method does nothing.</p>
<p>As implemented, this method performs the following processing steps, in order:</p>
<ol type="1">
<li>Checks isRunning property of this instance, and exits immediately if not running.</li>
<li>If needed, clamps the dt property to the value in maxUpdateInterval property.</li>
<li>Invokes updateBeforeTransform: on this instance.</li>
<li>Triggers recalculation of the transformMatrix on this node.</li>
<li>Updates each child (including invoking updateBeforeTransform:, recalulating the child node's transformMatrix, and invoking updateAfterTransform: on each descendant, in order).</li>
<li>Invokes updateAfterTransform: on this instance.</li>
<li>Updates target tracking in all cameras, lights and billboards.</li>
</ol>
<p>Sublcasses should not override this updateWorld: method. To customize the behaviour of the 3D model world, sublcasses should override the updateBeforeTransform: or updateAfterTransform: methods. Those two methods are defined and documented in the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> class. Please refer there for more documentation.</p>
<p>This method is invoked automatically at each scheduled update. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a159a26eccf5b8dcb180edd86c801e3e2"></a><!-- doxytag: member="CC3World::world" ref="a159a26eccf5b8dcb180edd86c801e3e2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3World::world </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a60c88e4c67cd30393e5d5612dd4259c6"></a><!-- doxytag: member="CC3World::activeCamera" ref="a60c88e4c67cd30393e5d5612dd4259c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_camera.html">CC3Camera</a> * CC3World::activeCamera<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The 3D camera that is currently displaying the scene of this world. </p>
<p>You can set this property directly, or if this property is not set directly, it will be set automatically to the first <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> added to this world via the addChild: method, including cameras contained somewhere in a structural assembly of nodes whose root node was added to this instance via addChild:. In this way, adding the root node of a node assembly loaded from a file will set the activeCamera property to the first camera found in the assembly, if the property was not already set.</p>
<p>The converse occurs when a camera is removed from the world using the removeChild: method. The camera will be removed as the activeCamera, and the second camera that was previously added (assuming more than one was added) will automatically be set as the activeCamera. Again, this is true even if the root node of a large assembly containing the active camera is removed from the world using the removeChild: method.</p>
<p>The initial value is nil. You must add at least one <a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> to your 3D world to make it viewable. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a6c93e6c1c60cf0757df9bd33cdc09fbb">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a11c4c38fed3e5c48c09249a31a158154"></a><!-- doxytag: member="CC3World::ambientLight" ref="a11c4c38fed3e5c48c09249a31a158154" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3World::ambientLight<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The color of the ambient light of the world. </p>
<p>This is independent of any <a class="el" href="interface_c_c3_light.html" title="CC3Light represents the light in the 3D world.">CC3Light</a> nodes that are added as child nodes. You can use this to provide general flat lighting in your world without having to add light nodes.</p>
<p>The initial value is set to kCC3DefaultLightColorAmbientWorld. </p>

</div>
</div>
<a class="anchor" id="acca4e761f942e4473cb317102fc9dfbc"></a><!-- doxytag: member="CC3World::cc3Layer" ref="acca4e761f942e4473cb317102fc9dfbc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_layer.html">CC3Layer</a> * CC3World::cc3Layer<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that is holding this 3D world. </p>
<p>This property is set automatically when this world is assigned to the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. The application should not set this property directly. </p>

</div>
</div>
<a class="anchor" id="ae40fd28ab2f13568e9877c917427cc9d"></a><!-- doxytag: member="CC3World::drawingSequencer" ref="ae40fd28ab2f13568e9877c917427cc9d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_sequencer.html">CC3NodeSequencer</a> * CC3World::drawingSequencer<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The node sequencer being used by this instance to order the drawing of child nodes. </p>
<p>During drawing, the nodes can be traversed in the hierarchical order of the node structural assembly, starting at the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> instance that forms the root node of the node assembly. Alternately, and preferrably, the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> can use a <a class="el" href="interface_c_c3_node_sequencer.html" title="A CC3NodeSequencer instance organizes nodes that are added to it.">CC3NodeSequencer</a> instance to arrange the nodes into a linear sequence, ordered and grouped based on definable sorting priorities. This is beneficial, because it allows the application to order and group drawing operations in ways that reduce the number and scope of state changes within the GL engine, thereby improving performance and throughput.</p>
<p>For example, when drawing, nodes could be grouped by the drawing sequencer so that opaque objects are drawn prior to blended objects, and an application with many objects that use the same material or mesh can be sorted so that nodes with like materials or meshes are grouped together. It is highly recommended that you use a <a class="el" href="interface_c_c3_node_sequencer.html" title="A CC3NodeSequencer instance organizes nodes that are added to it.">CC3NodeSequencer</a>.</p>
<p>The default drawing sequencer includes only nodes with local content, and groups them so that opaque nodes are drawn first, then nodes with blending. </p>

</div>
</div>
<a class="anchor" id="a698ade173d82d5a28f2346f8f4830f18"></a><!-- doxytag: member="CC3World::drawingSequenceVisitor" ref="a698ade173d82d5a28f2346f8f4830f18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_sequencer_visitor.html">CC3NodeSequencerVisitor</a> * CC3World::drawingSequenceVisitor<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The sequencer visitor used to visit the drawing sequencer during operations on the drawing sequencer, such as adding or removing individual nodes. </p>
<p>This property defaults to an instance of the <a class="el" href="interface_c_c3_node_sequencer_visitor.html" title="This visitor is used to visit CC3NodeSequencers to perform operations on nodes within the sequencers...">CC3NodeSequencerVisitor</a> class. The application can set a different visitor if desired. </p>

</div>
</div>
<a class="anchor" id="ad0e1712b746067328c4292a6d7bcde85"></a><!-- doxytag: member="CC3World::drawVisitor" ref="ad0e1712b746067328c4292a6d7bcde85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> * CC3World::drawVisitor<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The visitor that is used to visit the nodes to draw them to the GL engine. </p>
<p>This property defaults to an instance of the class returned by the drawVisitorClass method. The application can set a different visitor if desired. </p>

</div>
</div>
<a class="anchor" id="a99bc8b6e37b8506517e52a0eb436ada3"></a><!-- doxytag: member="CC3World::fog" ref="a99bc8b6e37b8506517e52a0eb436ada3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_fog.html">CC3Fog</a> * CC3World::fog<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If set, creates fog within the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>. </p>
<p>Fog has a color and blends with the display of objects within the world. Objects farther away from the camera are affected by the fog more than objects that are closer to the camera.</p>
<p>The initial value is nil, indicating that the world will contain no fog. </p>

</div>
</div>
<a class="anchor" id="a117ad5c56b93f0b1f2b06a3022be79f6"></a><!-- doxytag: member="CC3World::isUsingDrawingSequence" ref="a117ad5c56b93f0b1f2b06a3022be79f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3World::isUsingDrawingSequence<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this instance is using a drawing sequencer. </p>

</div>
</div>
<a class="anchor" id="acacd7e19e4cf69671812dae706775997"></a><!-- doxytag: member="CC3World::maxUpdateInterval" ref="acacd7e19e4cf69671812dae706775997" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTime CC3World::maxUpdateInterval<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the value of this property is greater than zero, it will be used as the upper limit accepted by the updateWorld: method. </p>
<p>Values sent to the updateWorld: method that are larger than this maximum will be clamped to this limit. If the value of this property is zero (or negative), the updateWorld: method will use the value that is passed to it unchanged.</p>
<p>Resource limitations, and activities around start-up and shut-down, can sometimes cause an occasional large interval between consecutive updates. These large intervals can sometimes cause object in the world to appear to jump around, and if you are using physics simulation, might cause collisions to be missed.</p>
<p>Setting a maximum update interval can help eliminate both concerns, but the trade-off may be less realistic real-time behaviour. With a limit in place, larger intervals between updates will make the world appear to run in slow motion, rather than jump around.</p>
<p>The initial value of this property is set to kCC3DefaultMaximumUpdateInterval.</p>
<p>The behaviour described here does not apply to nodes controlled by CCActionIntervals, which are not affected by the time between updates, or the value of this property. </p>

</div>
</div>
<a class="anchor" id="a50041d65fe611309060e23e0b68a1413"></a><!-- doxytag: member="CC3World::minUpdateInterval" ref="a50041d65fe611309060e23e0b68a1413" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTime CC3World::minUpdateInterval<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The value of this property is used as the lower limit accepted by the updateWorld: method. </p>
<p>Values sent to the updateWorld: method that are smaller than this maximum will be clamped to this limit. If the value of this property is zero (or negative), the updateWorld: method will use the value that is passed to it unchanged.</p>
<p>You can set this value if your custom world cannot work with a zero interval, or with an interval that is too small. For instance, if the logic of your world uses the update interval as the denominator in a division calculation, you would want to set this property to a value slightly above zero.</p>
<p>The initial value of this property is set to kCC3DefaultMinimumUpdateInterval.</p>
<p>The behaviour described here does not apply to nodes controlled by CCActionIntervals, which are not affected by the time between updates, or the value of this property. </p>

</div>
</div>
<a class="anchor" id="a75034883f24c2a436d2bc72bf0dca52e"></a><!-- doxytag: member="CC3World::performanceStatistics" ref="a75034883f24c2a436d2bc72bf0dca52e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_performance_statistics.html">CC3PerformanceStatistics</a> * CC3World::performanceStatistics<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If set, collects statistics about the updating and drawing performance of the 3D world. </p>
<p>By default, this property is nil, and no statistics are accumulated. To accumulate statistics, set this property with an appropriate instance. Subclasses of <a class="el" href="interface_c_c3_performance_statistics.html" title="Collects statistics about the updating and drawing performance of the 3D world.">CC3PerformanceStatistics</a> can customize the statistics that are collected.</p>
<p>To allow flexibility in accumulating statistics, the statistics collector does not automatically clear the accumulated statistics. If you set this property with a statistic collector, it is your responsibility to read the values, and reset the performanceStatistics instance periodically, using the <a class="el" href="interface_c_c3_performance_statistics.html" title="Collects statistics about the updating and drawing performance of the 3D world.">CC3PerformanceStatistics</a> reset method, to ensure that the counters do not overflow. Depending on the complexity and capabilities of your application, you should reset the performance statistics at least every few seconds. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a968396edac85926dcd809809220f0489">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a05eaae1b50852df0166d902cb212593c"></a><!-- doxytag: member="CC3World::shouldClearDepthBufferBefore2D" ref="a05eaae1b50852df0166d902cb212593c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3World::shouldClearDepthBufferBefore2D<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the OpenGL depth buffer should be cleared before reverting back to the 2D world. </p>
<p>If 2D content will be drawn on top of the 3D content, AND it is being drawn with depth testing enabled, then this property should be set to YES.</p>
<p>However, if this is not the case, then this property can be set to NO to skip the overhead of clearing of the depth buffer when transitioning from 3D back to 2D.</p>
<p>Clearing the depth buffer is a relatively expensive operation, and avoiding it when it is not necessary can result in a performance improvement. Because of this, it is recommended that this property be set to NO, and turn depth testing off during drawing of the 2D content on top of the 3D world.</p>
<p>You can turn depth testing off for the 2D content by invoking the following code once during the initialization of your application after the EAGLView has been created:</p>
<p>[[CCDirector sharedDirector] setDepthTest: NO];</p>
<p>By doing so, you will then be able to set this property to NO and still be able to draw 2D content on top of the 3D world, while avoiding an unnecessary clearing of the depth buffer.</p>
<p>The initial value of this property is YES. Set this property to NO to improve performance if depth-testing 2D content is not being drawn on top of 3D content. </p>

</div>
</div>
<a class="anchor" id="a67c4b667cd476c32dcf0503fbf0ce700"></a><!-- doxytag: member="CC3World::shouldClearDepthBufferBefore3D" ref="a67c4b667cd476c32dcf0503fbf0ce700" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3World::shouldClearDepthBufferBefore3D<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the OpenGL depth buffer should be cleared before drawing the 3D world. </p>
<p>If the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, or other 2D nodes that the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> may be contained within, have drawn 2D content on which the 3D world is to be drawn on top of, AND is using depth testing, then this property should be set to YES to ensure that the 3D content will not conflict with the previously drawn 2D content, and will be drawn on top of that 2D content.</p>
<p>However, if this is not the case, then this property can be set to NO to skip the overhead of clearing of the depth buffer when transitioning from 2D to 3D.</p>
<p>Clearing the depth buffer is a relatively expensive operation, and avoiding it when it is not necessary can result in a performance improvement. Because of this, it is recommended that this property be set to NO unless conflicts arise when drawing 3D content over previously drawn 2D content.</p>
<p>The initial value of this property is YES. Set this property to NO to improve performance if 3D content is not being drawn on top of 2D content. </p>

</div>
</div>
<a class="anchor" id="a454fae6d00bfe5cca3cbff4fc8c533c4"></a><!-- doxytag: member="CC3World::touchedNodePicker" ref="a454fae6d00bfe5cca3cbff4fc8c533c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_touched_node_picker.html">CC3TouchedNodePicker</a> * CC3World::touchedNodePicker<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The touchedNodePicker picks the node under the point at which a touch event occurred. </p>
<p>Touch events are forwarded to the touchedNodePicker from the touchEvent:at: method when a node is to be picked from a particular touch event. </p>

</div>
</div>
<a class="anchor" id="a2cef1389cd02f253ff6487102a441baf"></a><!-- doxytag: member="CC3World::transformVisitor" ref="a2cef1389cd02f253ff6487102a441baf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_transforming_visitor.html">CC3NodeTransformingVisitor</a> * CC3World::transformVisitor<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The visitor that is used to visit the nodes when transforming them without updating. </p>
<p>This property defaults to an instance of the class returned by the transformVisitorClass method. The application can set a different visitor if desired. </p>

</div>
</div>
<a class="anchor" id="af838ecc6aa6577fb220c5068adc6b482"></a><!-- doxytag: member="CC3World::updateVisitor" ref="af838ecc6aa6577fb220c5068adc6b482" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_updating_visitor.html">CC3NodeUpdatingVisitor</a> * CC3World::updateVisitor<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The visitor that is used to visit the nodes to update and transform them during scheduled updates. </p>
<p>This property defaults to an instance of the class returned by the updateVisitorClass method. The application can set a different visitor if desired. </p>

</div>
</div>
<a class="anchor" id="a5e1304a3ece0063bac3401b199f855f4"></a><!-- doxytag: member="CC3World::viewportManager" ref="a5e1304a3ece0063bac3401b199f855f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_viewport_manager.html">CC3ViewportManager</a> * CC3World::viewportManager<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The viewport manager manages the viewport and device orientation, including handling coordinate rotation based on the device orientation, and conversion of locations and points between the 3D and 2D coordinate systems. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_world_8h.html">CC3World.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_world.html">CC3World</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:12 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
