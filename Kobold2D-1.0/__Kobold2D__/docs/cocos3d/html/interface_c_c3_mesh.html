<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3Mesh Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_mesh.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3Mesh Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3Mesh" --><!-- doxytag: inherits="CC3Identifiable" -->
<p><code>#include &lt;CC3Mesh.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_mesh__inherit__graph.png" border="0" usemap="#_c_c3_mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_mesh_inherit__map" id="_c_c3_mesh_inherit__map">
<area shape="rect" id="node5" href="interface_c_c3_mesh_model.html" title="Deprecated CC3MeshModel renamed to CC3Mesh." alt="" coords="70,161,180,189"/><area shape="rect" id="node7" href="interface_c_c3_vertex_array_mesh.html" title="A CC3VertexArrayMesh is a mesh whose mesh data is kept in a set of CC3VertexArrays instances..." alt="" coords="205,161,347,189"/><area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="146,6,253,34"/><area shape="rect" id="node9" href="interface_c_c3_p_o_d_mesh.html" title="A CC3VertexArrayMesh whose content originates from POD resource data." alt="" coords="5,238,107,266"/><area shape="rect" id="node11" href="interface_c_c3_point_particle_mesh.html" title="A mesh whose vertices are used to display point particles." alt="" coords="131,238,275,266"/><area shape="rect" id="node13" href="interface_c_c3_skin_mesh.html" title="CC3SkinMesh is a CC3VertexArrayMesh that, in addition to the familiar vertex data such as locations..." alt="" coords="299,238,399,266"/><area shape="rect" id="node17" href="interface_c_c3_vertex_array_mesh_model.html" title="Deprecated CC3VertexArrayMeshModel renamed to CC3VertexArrayMesh." alt="" coords="423,238,600,266"/><area shape="rect" id="node15" href="interface_c_c3_p_o_d_skin_mesh.html" title="A CC3SkinMesh extracted from a POD file." alt="" coords="286,315,412,343"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_mesh__coll__graph.png" border="0" usemap="#_c_c3_mesh_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_mesh_coll__map" id="_c_c3_mesh_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_mesh-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ad4f6651b2fbe0dcdc48dc5ddf281fbb7">alignWithInvertedTexturesIn:</a> (<a class="el" href="interface_c_c3_material.html">CC3Material</a> *aMaterial)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a91e883a043d0c4e5fdf006d41c5b915b">alignWithTexturesIn:</a> (<a class="el" href="interface_c_c3_material.html">CC3Material</a> *aMaterial)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#add9407049ba2360bd1e4fb7d71528f72">createGLBuffers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a604e2a044074bc3edf3aac6fe10f1cb2">defaultBoundingVolume</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a229ebe05173b24083df7670142329dc0">deleteGLBuffers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#abf52e2f315042f9d460fe498ce2e49ae">doNotBufferVertexColors</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ad90ec5e09f1e234180493efa7cffeba9">doNotBufferVertexIndices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#af13c4436396a1f7665419abaa6e36d2b">doNotBufferVertexLocations</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#af143643024e51626d7964ab32e42640b">doNotBufferVertexNormals</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#acf2aac3eaa854c47447ffb2012b80343">doNotBufferVertexTextureCoordinates</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ae88ac2a93a7d9d69744a3042062b85b0">drawFrom:forCount:withVisitor:</a> (GLuint vertexIndex,[forCount] GLuint vertexCount,[withVisitor] <a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a5e6349c01b70f4a2bad6b542407e2ee1">drawWithVisitor:</a> (<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a2288666a187bfe6805bce345279d8e0f">faceCountFromVertexCount:</a> (GLsizei vc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a8eb6e704ee1f81c79ddcee258855af42">movePivotTo:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aLocation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a8dcc0b0903b5cad6772dcd3e8258c194">movePivotToCenterOfGeometry</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a4d0254d8892c61cd600fa2a991b8773e">releaseRedundantData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aa256b77a007dc390ca8b4af81bf329ab">repeatTexture:</a> (ccTex2F repeatFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a4d4e4f796b40b81f5041c7db69692de5">retainVertexColors</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#af9418b19b821c6127392eddeed7730d8">retainVertexIndices</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a4aa5bd30d6c22ab7fb3d9b43627e9a95">retainVertexLocations</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a087f4bde149868930686af3bdac971f8">retainVertexNormals</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ab8e83fd5ac13c16e87948ef08bb09b8c">retainVertexTextureCoordinates</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a6d4b01c5368d3425072124f59b2ad7a6">setTextureRectangle:forTextureUnit:</a> (CGRect aRect,[forTextureUnit] GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ac8c445ca1a860ad8c872defc0df96ffd">setVertexColor4B:at:</a> (ccColor4B aColor,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a54bf4707da6abc0129bef0038d6ca6ca">setVertexColor4F:at:</a> (ccColor4F aColor,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a610b4ba40f8148becf3e249e5512d0a8">setVertexIndex:at:</a> (GLushort vertexIndex,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a33d7cbde7a0d48ef30a83aa4c28355f5">setVertexLocation:at:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aLocation,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aaa9d605ae22451efe5bf33cebd40d562">setVertexNormal:at:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aNormal,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a8460525eb2dd82c3d0ed63112b1e7264">setVertexTexCoord2F:at:</a> (ccTex2F aTex2F,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a1e3841c4ac9e493ebf97d16918825250">setVertexTexCoord2F:at:forTextureUnit:</a> (ccTex2F aTex2F,[at] GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aaf181aca33dda5d5cf37af240f805ebc">setVertexTexCoord2F:forTextureUnit:at:</a> (ccTex2F aTex2F,[forTextureUnit] GLuint texUnit,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a50bcbd2a4349f0cac6c4f43b6368ccce">textureRectangleForTextureUnit:</a> (GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#af94e31962b7d39013aeb746d6d2c4160">updateVertexColorsGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ab925a11366aa934f5cf797b666258998">updateVertexIndicesGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a2ff690a5a325fef4f05e50c3f0958e82">updateVertexLocationsGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a03c94d644d9c71eea23e24b559f9982c">updateVertexNormalsGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aedc3dee48200842097c95a0dbcb6812d">updateVertexTextureCoordinatesGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a4f2b7a99b8db027d40207a7ce3f0532a">updateVertexTextureCoordinatesGLBufferForTextureUnit:</a> (GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a5404a9d6cac27ee7f1a501b214c308b9">vertexColor4BAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aa5b51894550c4dd0b000826066981fb8">vertexColor4FAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a3084ed5df5b17cf21abd18ecc5ee46ce">vertexCountFromFaceCount:</a> (GLsizei fc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a8495a5045ec3d7a8dea2c69f28af5938">vertexIndexAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a15c2acf94ea8002c6c36180ddbf61396">vertexLocationAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a89dd062b65206fa670f181922ec8b6bc">vertexNormalAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTex2F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a4618534025813c65b2b9c1e3f2fa97a8">vertexTexCoord2FAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTex2F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a50ce35ec3aba59ecb31892a0d319c736">vertexTexCoord2FAt:forTextureUnit:</a> (GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTex2F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aaf688de3ea36c3d2bf3bc0fbb6233fc6">vertexTexCoord2FForTextureUnit:at:</a> (GLuint texUnit,[at] GLsizei index)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aba5a511998a9ba82ac2d0e886d01b6b8">mesh</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a8bdc6046a3a3702348138f0ed58565f8">meshWithName:</a> (NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a2f7917909ad2887d109ef4ba508a87d9">meshWithTag:</a> (GLuint aTag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#ab5202c876913aa8043e226ea32df8ec2">meshWithTag:withName:</a> (GLuint aTag,[withName] NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a41f97e217dfb0500c27a8279e448ea58">resetSwitching</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a894a773da6f0d4e72c80b1fc471b4ff2">boundingBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a799ba572f5741b70f68575626e7c0d33">hasColors</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a7831fd442e211cd7eae17c7e59506bf8">hasNormals</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#aec0451580686743d8bbf5baf0745cf7f">textureRectangle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh.html#a00ab53446893ad0baf4537a731881eb1">vertexCount</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> holds the 3D mesh for a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a>. </p>
<p>The <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> enapsulates a reference to the <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a>.</p>
<p>In 3D models, the mesh generally remains fixed, and transformations such as translation, rotation, and scaling are applied at the node level. A single <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> instance, which typically contains a large set of data points, can be used by many nodes simultaneously, and each node instance can be transformed, colored, and textured independently.</p>
<p>With this in mind, and following best practices to consevere memory and processing time, you should strive to create only one <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> instance for each distinct mesh in your application, and assign that single <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> instance to any number of separate <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instances that make use of it.</p>
<p>When drawing the mesh to the GL engine, this class remembers which mesh was last drawn and only binds the mesh data to the GL engine when a different mesh is drawn. This allows the application to organize the CC3MeshNodes within the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> so that nodes using the same mesh are drawn together, before moving on to other mesh models. This strategy can minimize the number of mesh switches in the GL engine, which improves performance.</p>
<p><a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> is an abstract class. Subclasses can be created for loading and managing meshes from different sources and third-party libraries. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad4f6651b2fbe0dcdc48dc5ddf281fbb7"></a><!-- doxytag: member="CC3Mesh::alignWithInvertedTexturesIn:" ref="ad4f6651b2fbe0dcdc48dc5ddf281fbb7" args="(CC3Material *aMaterial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::alignWithInvertedTexturesIn: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_material.html">CC3Material</a> *&#160;</td>
          <td class="paramname"><em>aMaterial</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the texture coordinates of the mesh with the textures held in the specified material. </p>
<p>The texture coordinates are aligned assuming that the texture is inverted in the Y-direction. Certain texture formats are inverted during loading, and this method can be used to compensate.</p>
<p>This method can be useful when the mesh is covered by textures whose width and height are not a power-of-two. Under iOS, when loading a texture that is not a power-of-two, the texture will be converted to a size whose width and height are a power-of-two. The result is a texture that can have empty space on the top and right sides. If the texture coordinates of the mesh do not take this into consideration, the result will be that only the lower left of the mesh will be covered by the texture.</p>
<p>When this occurs, invoking this method will adjust the texture coordinates of the mesh to map to the original width and height of the texture.</p>
<p>If the mesh is using multi-texturing, this method will adjust the texture coordinates array for each texture unit, using the corresponding texture for that texture unit in the specified material.</p>
<p>Care should be taken when using this method, as it changes the actual vertex data. This method should only be invoked once on any mesh, and it may cause mapping conflicts if the same mesh is shared by other CC3MeshNodes that use different textures.</p>
<p>To adjust the texture coordinates of only a single texture coordinates array within this mesh, invoke the alignWithInvertedTexture: method on the appropriate instance of <a class="el" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices.">CC3VertexTextureCoordinates</a>. </p>

</div>
</div>
<a class="anchor" id="a91e883a043d0c4e5fdf006d41c5b915b"></a><!-- doxytag: member="CC3Mesh::alignWithTexturesIn:" ref="a91e883a043d0c4e5fdf006d41c5b915b" args="(CC3Material *aMaterial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::alignWithTexturesIn: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_material.html">CC3Material</a> *&#160;</td>
          <td class="paramname"><em>aMaterial</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the texture coordinates of the mesh with the textures held in the specified material. </p>
<p>This method can be useful when the mesh is covered by textures whose width and height are not a power-of-two. Under iOS, when loading a texture that is not a power-of-two, the texture will be converted to a size whose width and height are a power-of-two. The result is a texture that can have empty space on the top and right sides. If the texture coordinates of the mesh do not take this into consideration, the result will be that only the lower left of the mesh will be covered by the texture.</p>
<p>When this occurs, invoking this method will adjust the texture coordinates of the mesh to map to the original width and height of the texture.</p>
<p>If the mesh is using multi-texturing, this method will adjust the texture coordinates array for each texture unit, using the corresponding texture for that texture unit in the specified material.</p>
<p>Care should be taken when using this method, as it changes the actual vertex data. This method should only be invoked once on any mesh, and it may cause mapping conflicts if the same mesh is shared by other CC3MeshNodes that use different textures.</p>
<p>To adjust the texture coordinates of only a single texture coordinates array within this mesh, invoke the alignWithTexture: method on the appropriate instance of <a class="el" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices.">CC3VertexTextureCoordinates</a>. </p>

</div>
</div>
<a class="anchor" id="add9407049ba2360bd1e4fb7d71528f72"></a><!-- doxytag: member="CC3Mesh::createGLBuffers" ref="add9407049ba2360bd1e4fb7d71528f72" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::createGLBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to create GL buffers for all vertex arrays used by this mesh. </p>
<p>This method may safely be called more than once, or on more than one mesh that shares vertex arrays, since vertex array GL buffers are only created if they don't already exist. </p>

</div>
</div>
<a class="anchor" id="a604e2a044074bc3edf3aac6fe10f1cb2"></a><!-- doxytag: member="CC3Mesh::defaultBoundingVolume" ref="a604e2a044074bc3edf3aac6fe10f1cb2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_node_bounding_volume.html">CC3NodeBoundingVolume</a>* CC3Mesh::defaultBoundingVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an allocated, initialized, autorelease instance of the bounding volume to be used by the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> that wraps this mesh. </p>
<p>This method is called automatically by the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instance when this mesh is attached to the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a>.</p>
<p>This abstract implementation always returns nil. Subclasses will override to provide an appropriate and useful bounding volume instance. </p>

</div>
</div>
<a class="anchor" id="a229ebe05173b24083df7670142329dc0"></a><!-- doxytag: member="CC3Mesh::deleteGLBuffers" ref="a229ebe05173b24083df7670142329dc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::deleteGLBuffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to delete any GL buffers for all vertex arrays used by this mesh. </p>
<p>The arrays may continue to be used, and the arrays will be passed from the client during each draw instead of bound to the GL server as a vertex buffer.</p>
<p>This is a convenience method. Because vertex arrays may be shared between arrays, this method should likely be used when it is known that this mesh is the only user of the array, or to clear GL memory for any rarely used meshes. A more general design is to simply release the vertex array. The GL buffer will be deleted when the vertex array is deallocated.</p>
<p>This method may safely be called more than once, or on more than one mesh that shares vertex arrays, since vertex array GL buffers are only deleted if they exist. </p>

</div>
</div>
<a class="anchor" id="abf52e2f315042f9d460fe498ce2e49ae"></a><!-- doxytag: member="CC3Mesh::doNotBufferVertexColors" ref="abf52e2f315042f9d460fe498ce2e49ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::doNotBufferVertexColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex color data to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex colors will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="ad90ec5e09f1e234180493efa7cffeba9"></a><!-- doxytag: member="CC3Mesh::doNotBufferVertexIndices" ref="ad90ec5e09f1e234180493efa7cffeba9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::doNotBufferVertexIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex index data to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex indices will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexColors method. </p>

</div>
</div>
<a class="anchor" id="af13c4436396a1f7665419abaa6e36d2b"></a><!-- doxytag: member="CC3Mesh::doNotBufferVertexLocations" ref="af13c4436396a1f7665419abaa6e36d2b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::doNotBufferVertexLocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex location data to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex locations will not be buffered to a GL VBO. Any other vertex data, such as normals, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexLocations method. </p>

</div>
</div>
<a class="anchor" id="af143643024e51626d7964ab32e42640b"></a><!-- doxytag: member="CC3Mesh::doNotBufferVertexNormals" ref="af143643024e51626d7964ab32e42640b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::doNotBufferVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex normal data to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex normals will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexNormals method. </p>

</div>
</div>
<a class="anchor" id="acf2aac3eaa854c47447ffb2012b80343"></a><!-- doxytag: member="CC3Mesh::doNotBufferVertexTextureCoordinates" ref="acf2aac3eaa854c47447ffb2012b80343" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::doNotBufferVertexTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate data for all texture units used by this mesh to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex texture coordinates will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexTextureCoordinates method. </p>

</div>
</div>
<a class="anchor" id="ae88ac2a93a7d9d69744a3042062b85b0"></a><!-- doxytag: member="CC3Mesh::drawFrom:forCount:withVisitor:" ref="ae88ac2a93a7d9d69744a3042062b85b0" args="(GLuint vertexIndex,[forCount] GLuint vertexCount,[withVisitor] CC3NodeDrawingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::drawFrom:forCount:withVisitor: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>vertexIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forCount] GLuint&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withVisitor] <a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a portion of the mesh data to the GL engine, starting at the vertex at the specified index, and drawing the specified number of vertices. </p>
<p>The specified visitor encapsulates the currently active camera, and certain drawing options.</p>
<p>If this mesh is different than the last mesh drawn, this method binds this mesh data to the GL engine. Otherwise, if this mesh is the same as the mesh already bound, it is not bound again, Once binding is complete, this method then performs the GL draw operations.</p>
<p>This is invoked automatically from the draw method of the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instance that is using this mesh. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a5e6349c01b70f4a2bad6b542407e2ee1"></a><!-- doxytag: member="CC3Mesh::drawWithVisitor:" ref="a5e6349c01b70f4a2bad6b542407e2ee1" args="(CC3NodeDrawingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::drawWithVisitor: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws the mesh data to the GL engine. </p>
<p>The specified visitor encapsulates the currently active camera, and certain drawing options.</p>
<p>If this mesh is different than the last mesh drawn, this method binds this mesh data to the GL engine. Otherwise, if this mesh is the same as the mesh already bound, it is not bound again, Once binding is complete, this method then performs the GL draw operations.</p>
<p>This is invoked automatically from the draw method of the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instance that is using this mesh. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a2288666a187bfe6805bce345279d8e0f"></a><!-- doxytag: member="CC3Mesh::faceCountFromVertexCount:" ref="a2288666a187bfe6805bce345279d8e0f" args="(GLsizei vc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei CC3Mesh::faceCountFromVertexCount: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>vc</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of faces to be drawn from the specified number of vertices, based on the type of primitives that this mesh is drawing. </p>

</div>
</div>
<a class="anchor" id="aba5a511998a9ba82ac2d0e886d01b6b8"></a><!-- doxytag: member="CC3Mesh::mesh" ref="aba5a511998a9ba82ac2d0e886d01b6b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Mesh::mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a8bdc6046a3a3702348138f0ed58565f8"></a><!-- doxytag: member="CC3Mesh::meshWithName:" ref="a8bdc6046a3a3702348138f0ed58565f8" args="(NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Mesh::meshWithName: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified name and an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a2f7917909ad2887d109ef4ba508a87d9"></a><!-- doxytag: member="CC3Mesh::meshWithTag:" ref="a2f7917909ad2887d109ef4ba508a87d9" args="(GLuint aTag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Mesh::meshWithTag: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an unnamed autoreleased instance with the specified tag. </p>

</div>
</div>
<a class="anchor" id="ab5202c876913aa8043e226ea32df8ec2"></a><!-- doxytag: member="CC3Mesh::meshWithTag:withName:" ref="ab5202c876913aa8043e226ea32df8ec2" args="(GLuint aTag,[withName] NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Mesh::meshWithTag:withName: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withName] NSString *&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified tag and name. </p>

</div>
</div>
<a class="anchor" id="a8eb6e704ee1f81c79ddcee258855af42"></a><!-- doxytag: member="CC3Mesh::movePivotTo:" ref="a8eb6e704ee1f81c79ddcee258855af42" args="(CC3Vector aLocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::movePivotTo: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aLocation</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the mesh data so that the pivot point of the mesh will be at the specified location. </p>
<p>The pivot point of the mesh is the location in the local coordinate system around which all transforms are performed. A vertex at the pivot point would have local coordinates (0,0,0).</p>
<p>This method can be used to adjust the mesh structure to make it easier to apply transformations, by moving the origin of the transformations to a more convenient location in the mesh.</p>
<p>This method changes the location component of every vertex in the mesh data. This can be quite costly, and should only be performed once to adjust a mesh so that it is easier to manipulate.</p>
<p>Do not use this method to move your model around. Instead, use the transform properties (location, rotation and scale) of the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> that contains this mesh, and let the GL engine do the heavy lifting of transforming the mesh vertices.</p>
<p>If this mesh is being used by any mesh nodes, be sure to invoke the rebuildBoundingVolume method on all nodes that use this mesh, to ensure that the boundingVolume is recalculated using the new location values.</p>
<p>This method ensures that the GL VBO that holds the vertex data is updated. </p>

</div>
</div>
<a class="anchor" id="a8dcc0b0903b5cad6772dcd3e8258c194"></a><!-- doxytag: member="CC3Mesh::movePivotToCenterOfGeometry" ref="a8dcc0b0903b5cad6772dcd3e8258c194" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::movePivotToCenterOfGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the mesh data so that the pivot point of the mesh will be at the center of geometry of the mesh vertices. </p>
<p>The pivot point of the mesh is the location in the local coordinate system around which all transforms are performed. A vertex at the pivot point would have local coordinates (0,0,0).</p>
<p>This method can be used to adjust the mesh structure to make it easier to apply transformations, by moving the origin of the transformations to the center of the mesh.</p>
<p>This method changes the location component of every vertex in the mesh data. This can be quite costly, and should only be performed once to adjust a mesh so that it is easier to manipulate.</p>
<p>Do not use this method to move your model around. Instead, use the transform properties (location, rotation and scale) of the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> that contains this mesh, and let the GL engine do the heavy lifting of transforming the mesh vertices.</p>
<p>If this mesh is being used by any mesh nodes, be sure to invoke the rebuildBoundingVolume method on all nodes that use this mesh, to ensure that the boundingVolume is recalculated using the new location values.</p>
<p>This method ensures that the GL VBO that holds the vertex data is updated. </p>

</div>
</div>
<a class="anchor" id="a4d0254d8892c61cd600fa2a991b8773e"></a><!-- doxytag: member="CC3Mesh::releaseRedundantData" ref="a4d0254d8892c61cd600fa2a991b8773e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::releaseRedundantData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Once the elements data has been buffered into a GL vertex buffer object (VBO) within the GL engine, via the createGLBuffer method, this method can be used to release the data in main memory that is now redundant. </p>
<p>Typically, this method is not invoked directly by the application. Instead, consider using the same method on a node assembly in order to release as much memory as possible in one simply method invocation. </p>

</div>
</div>
<a class="anchor" id="aa256b77a007dc390ca8b4af81bf329ab"></a><!-- doxytag: member="CC3Mesh::repeatTexture:" ref="aa256b77a007dc390ca8b4af81bf329ab" args="(ccTex2F repeatFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::repeatTexture: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>repeatFactor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the mesh so that a texture applied to this mesh will be repeated the specified number of times across the mesh, in each dimension. </p>
<p>The repeatFactor argument contains two numbers, corresponding to how many times in each dimension the texture should be repeated.</p>
<p>As an example, a value of (1, 2) for the repeatValue indicates that the texture should repeat twice vertically, but not repeat horizontally.</p>
<p>When a texture is repeated, the corresponding side of the texture covering this mesh must have a length that is a power-of-two, otherwise the padding added by iOS to convert it to a power-of-two length internally will be visible in the repeating pattern across the mesh.</p>
<p>For a side that is not repeating, the corresponding side of the texture covering this mesh does not require a length that is a power-of-two.</p>
<p>The textureParameters property of any texture covering this mesh should include the GL_REPEAT setting in each of its texture wrap components that correspond to a repeatFactor greater than one. The GL_REPEAT setting is the default setting for <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a>.</p>
<p>For example, if you want to repeat your texture twice in one dimension, but only once in the other, then you would use a repeatFactor of (1, 2) or (2, 1). For the side that is repeating twice, the length of that side of the texture must be a power-of-two. But the other side may have any dimension. The textureParameters property of the <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a> should include the GL_REPEAT setting for the corresponding texture dimension.</p>
<p>If your texture requires aligning with the mesh (typically if one of the texture dimensions is not a power-of-two), you should invoke either the alignWithTexturesIn: or alignWithInvertedTexturesIn: method before invoking this method.</p>
<p>In the example above, you would invoke one of those methods before invoking this method, to first align the mesh with that non-power-of-two side.</p>
<p>The dimensions of the repeatFactor are independent of the size derived from the texture by the alignWithTexturesIn: or alignWithInvertedTexturesIn: methods. A value of 1.0 for an element in the specified repeatFactor will automatically take into consideration the adjustment made to the mesh by those methods, and will display only the part of the texture defined by them.</p>
<p>You can specify a fractional value for either of the components of the repeatFactor to expand the texture in that dimension so that only part of the texture appears in that dimension, while potentially repeating multiple times in the other dimension. </p>

</div>
</div>
<a class="anchor" id="a41f97e217dfb0500c27a8279e448ea58"></a><!-- doxytag: member="CC3Mesh::resetSwitching" ref="a41f97e217dfb0500c27a8279e448ea58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::resetSwitching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the tracking of the mesh switching functionality. </p>
<p>This is invoked automatically by the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> at the beginning of each frame drawing cycle. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a4d4e4f796b40b81f5041c7db69692de5"></a><!-- doxytag: member="CC3Mesh::retainVertexColors" ref="a4d4e4f796b40b81f5041c7db69692de5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::retainVertexColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex color data to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex colors will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="af9418b19b821c6127392eddeed7730d8"></a><!-- doxytag: member="CC3Mesh::retainVertexIndices" ref="af9418b19b821c6127392eddeed7730d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::retainVertexIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex index data to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex indices will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a4aa5bd30d6c22ab7fb3d9b43627e9a95"></a><!-- doxytag: member="CC3Mesh::retainVertexLocations" ref="a4aa5bd30d6c22ab7fb3d9b43627e9a95" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::retainVertexLocations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex location data to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex locations will be retained. Any other vertex data, such as normals, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a087f4bde149868930686af3bdac971f8"></a><!-- doxytag: member="CC3Mesh::retainVertexNormals" ref="a087f4bde149868930686af3bdac971f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::retainVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex normal data to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex normals will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="ab8e83fd5ac13c16e87948ef08bb09b8c"></a><!-- doxytag: member="CC3Mesh::retainVertexTextureCoordinates" ref="ab8e83fd5ac13c16e87948ef08bb09b8c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::retainVertexTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex texture coordinate data for all texture units used by this mesh to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex texture coordinates will be retained. Any other vertex data, such as locations, or normals, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked. </p>

</div>
</div>
<a class="anchor" id="a6d4b01c5368d3425072124f59b2ad7a6"></a><!-- doxytag: member="CC3Mesh::setTextureRectangle:forTextureUnit:" ref="a6d4b01c5368d3425072124f59b2ad7a6" args="(CGRect aRect,[forTextureUnit] GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setTextureRectangle:forTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">CGRect&#160;</td>
          <td class="paramname"><em>aRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the textureRectangle property from the texture coordinates that are mapping the specified texture unit index. </p>
<p>See the notes for the textureRectangle property of this class for an explanation of the use of this property. </p>

</div>
</div>
<a class="anchor" id="ac8c445ca1a860ad8c872defc0df96ffd"></a><!-- doxytag: member="CC3Mesh::setVertexColor4B:at:" ref="ac8c445ca1a860ad8c872defc0df96ffd" args="(ccColor4B aColor,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexColor4B:at: </td>
          <td>(</td>
          <td class="paramtype">ccColor4B&#160;</td>
          <td class="paramname"><em>aColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexColorsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a54bf4707da6abc0129bef0038d6ca6ca"></a><!-- doxytag: member="CC3Mesh::setVertexColor4F:at:" ref="a54bf4707da6abc0129bef0038d6ca6ca" args="(ccColor4F aColor,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexColor4F:at: </td>
          <td>(</td>
          <td class="paramtype">ccColor4F&#160;</td>
          <td class="paramname"><em>aColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexColorsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a610b4ba40f8148becf3e249e5512d0a8"></a><!-- doxytag: member="CC3Mesh::setVertexIndex:at:" ref="a610b4ba40f8148becf3e249e5512d0a8" args="(GLushort vertexIndex,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexIndex:at: </td>
          <td>(</td>
          <td class="paramtype">GLushort&#160;</td>
          <td class="paramname"><em>vertexIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the index element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexIndicesGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a33d7cbde7a0d48ef30a83aa4c28355f5"></a><!-- doxytag: member="CC3Mesh::setVertexLocation:at:" ref="a33d7cbde7a0d48ef30a83aa4c28355f5" args="(CC3Vector aLocation,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexLocation:at: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the location element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If this mesh is being used by any mesh nodes, be sure to invoke the rebuildBoundingVolume method on all nodes that use this mesh, to ensure that the boundingVolume is recalculated using the new location values.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexLocationsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="aaa9d605ae22451efe5bf33cebd40d562"></a><!-- doxytag: member="CC3Mesh::setVertexNormal:at:" ref="aaa9d605ae22451efe5bf33cebd40d562" args="(CC3Vector aNormal,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexNormal:at: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the normal element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexNormalsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a8460525eb2dd82c3d0ed63112b1e7264"></a><!-- doxytag: member="CC3Mesh::setVertexTexCoord2F:at:" ref="a8460525eb2dd82c3d0ed63112b1e7264" args="(ccTex2F aTex2F,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexTexCoord2F:at: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>aTex2F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the texture coordinate element at the specified index in the vertex data, at the commonly used texture unit zero, to the specified texture coordinate value. </p>
<p>This is a convenience method that delegates to the setVertexTexCoord2F:forTextureUnit:at: method, passing in zero for the texture unit index.</p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexTextureCoordinatesGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a1e3841c4ac9e493ebf97d16918825250"></a><!-- doxytag: member="CC3Mesh::setVertexTexCoord2F:at:forTextureUnit:" ref="a1e3841c4ac9e493ebf97d16918825250" args="(ccTex2F aTex2F,[at] GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexTexCoord2F:at:forTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>aTex2F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use the setVertexTexCoord2F:forTextureUnit:at: method instead, </dd></dl>

</div>
</div>
<a class="anchor" id="aaf181aca33dda5d5cf37af240f805ebc"></a><!-- doxytag: member="CC3Mesh::setVertexTexCoord2F:forTextureUnit:at:" ref="aaf181aca33dda5d5cf37af240f805ebc" args="(ccTex2F aTex2F,[forTextureUnit] GLuint texUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::setVertexTexCoord2F:forTextureUnit:at: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>aTex2F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the texture coordinate element at the specified index in the vertex data, at the specified texture unit index, to the specified texture coordinate value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexTextureCoordinatesGLBufferForTextureUnit: method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a50bcbd2a4349f0cac6c4f43b6368ccce"></a><!-- doxytag: member="CC3Mesh::textureRectangleForTextureUnit:" ref="a50bcbd2a4349f0cac6c4f43b6368ccce" args="(GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGRect CC3Mesh::textureRectangleForTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the textureRectangle property from the texture coordinates that are mapping the specified texture unit index. </p>
<p>See the notes for the textureRectangle property of this class for an explanation of the use of this property. </p>

</div>
</div>
<a class="anchor" id="af94e31962b7d39013aeb746d6d2c4160"></a><!-- doxytag: member="CC3Mesh::updateVertexColorsGLBuffer" ref="af94e31962b7d39013aeb746d6d2c4160" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::updateVertexColorsGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex color data in this mesh. </p>

</div>
</div>
<a class="anchor" id="ab925a11366aa934f5cf797b666258998"></a><!-- doxytag: member="CC3Mesh::updateVertexIndicesGLBuffer" ref="ab925a11366aa934f5cf797b666258998" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::updateVertexIndicesGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex index data in this mesh. </p>

</div>
</div>
<a class="anchor" id="a2ff690a5a325fef4f05e50c3f0958e82"></a><!-- doxytag: member="CC3Mesh::updateVertexLocationsGLBuffer" ref="a2ff690a5a325fef4f05e50c3f0958e82" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::updateVertexLocationsGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex location data in this mesh. </p>

</div>
</div>
<a class="anchor" id="a03c94d644d9c71eea23e24b559f9982c"></a><!-- doxytag: member="CC3Mesh::updateVertexNormalsGLBuffer" ref="a03c94d644d9c71eea23e24b559f9982c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::updateVertexNormalsGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex normal data in this mesh. </p>

</div>
</div>
<a class="anchor" id="aedc3dee48200842097c95a0dbcb6812d"></a><!-- doxytag: member="CC3Mesh::updateVertexTextureCoordinatesGLBuffer" ref="aedc3dee48200842097c95a0dbcb6812d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::updateVertexTextureCoordinatesGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex texture coord data from texture unit zero in this mesh. </p>

</div>
</div>
<a class="anchor" id="a4f2b7a99b8db027d40207a7ce3f0532a"></a><!-- doxytag: member="CC3Mesh::updateVertexTextureCoordinatesGLBufferForTextureUnit:" ref="a4f2b7a99b8db027d40207a7ce3f0532a" args="(GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Mesh::updateVertexTextureCoordinatesGLBufferForTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex texture coord data from the specified texture unit in this mesh. </p>

</div>
</div>
<a class="anchor" id="a5404a9d6cac27ee7f1a501b214c308b9"></a><!-- doxytag: member="CC3Mesh::vertexColor4BAt:" ref="a5404a9d6cac27ee7f1a501b214c308b9" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4B CC3Mesh::vertexColor4BAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the color element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="aa5b51894550c4dd0b000826066981fb8"></a><!-- doxytag: member="CC3Mesh::vertexColor4FAt:" ref="aa5b51894550c4dd0b000826066981fb8" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Mesh::vertexColor4FAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the color element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a3084ed5df5b17cf21abd18ecc5ee46ce"></a><!-- doxytag: member="CC3Mesh::vertexCountFromFaceCount:" ref="a3084ed5df5b17cf21abd18ecc5ee46ce" args="(GLsizei fc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei CC3Mesh::vertexCountFromFaceCount: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>fc</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of vertices required to draw the specified number of faces, based on the type of primitives that this mesh is drawing. </p>

</div>
</div>
<a class="anchor" id="a8495a5045ec3d7a8dea2c69f28af5938"></a><!-- doxytag: member="CC3Mesh::vertexIndexAt:" ref="a8495a5045ec3d7a8dea2c69f28af5938" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLushort CC3Mesh::vertexIndexAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a15c2acf94ea8002c6c36180ddbf61396"></a><!-- doxytag: member="CC3Mesh::vertexLocationAt:" ref="a15c2acf94ea8002c6c36180ddbf61396" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Mesh::vertexLocationAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the location element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a89dd062b65206fa670f181922ec8b6bc"></a><!-- doxytag: member="CC3Mesh::vertexNormalAt:" ref="a89dd062b65206fa670f181922ec8b6bc" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Mesh::vertexNormalAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the normal element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a4618534025813c65b2b9c1e3f2fa97a8"></a><!-- doxytag: member="CC3Mesh::vertexTexCoord2FAt:" ref="a4618534025813c65b2b9c1e3f2fa97a8" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTex2F CC3Mesh::vertexTexCoord2FAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the texture coordinate element at the specified index from the vertex data at the commonly used texture unit zero. </p>
<p>This is a convenience method that is equivalent to invoking the vertexTexCoord2FForTextureUnit:at: method, with zero as the texture unit index.</p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a50ce35ec3aba59ecb31892a0d319c736"></a><!-- doxytag: member="CC3Mesh::vertexTexCoord2FAt:forTextureUnit:" ref="a50ce35ec3aba59ecb31892a0d319c736" args="(GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTex2F CC3Mesh::vertexTexCoord2FAt:forTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use the vertexTexCoord2FForTextureUnit:at: method instead, </dd></dl>

</div>
</div>
<a class="anchor" id="aaf688de3ea36c3d2bf3bc0fbb6233fc6"></a><!-- doxytag: member="CC3Mesh::vertexTexCoord2FForTextureUnit:at:" ref="aaf688de3ea36c3d2bf3bc0fbb6233fc6" args="(GLuint texUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTex2F CC3Mesh::vertexTexCoord2FForTextureUnit:at: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the texture coordinate element at the specified index from the vertex data at the specified texture unit index. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a894a773da6f0d4e72c80b1fc471b4ff2"></a><!-- doxytag: member="CC3Mesh::boundingBox" ref="a894a773da6f0d4e72c80b1fc471b4ff2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a> CC3Mesh::boundingBox<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The axially-aligned-bounding-box (AABB) in the mesh local (untransformed) coordinate system. </p>
<p>This abstract implementation always returns the null bounding box. Subclasses will override to return an appropriate value. </p>

</div>
</div>
<a class="anchor" id="a799ba572f5741b70f68575626e7c0d33"></a><!-- doxytag: member="CC3Mesh::hasColors" ref="a799ba572f5741b70f68575626e7c0d33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Mesh::hasColors<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this mesh contains data for vertex colors. </p>
<p>This abstract implementation always returns NO. Subclasses will override to return an appropriate value. </p>

</div>
</div>
<a class="anchor" id="a7831fd442e211cd7eae17c7e59506bf8"></a><!-- doxytag: member="CC3Mesh::hasNormals" ref="a7831fd442e211cd7eae17c7e59506bf8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Mesh::hasNormals<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this mesh contains data for vertex normals. </p>
<p>This abstract implementation always returns NO. Subclasses will override to return an appropriate value. </p>

</div>
</div>
<a class="anchor" id="aec0451580686743d8bbf5baf0745cf7f"></a><!-- doxytag: member="CC3Mesh::textureRectangle" ref="aec0451580686743d8bbf5baf0745cf7f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGRect CC3Mesh::textureRectangle<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the rectangular area of the textures, for all texture units, that should be mapped to this mesh. </p>
<p>This property facilitates the use of sprite-sheets, where the mesh is covered by a small fraction of a larger texture. This technique has many uses, including animating a texture onto a mesh, where each section of the full texture is really a different frame of a texture animation, or simply loading one larger texture and using parts of it to texture many different meshes.</p>
<p>The dimensions of this rectangle are taken as fractional portions of the full area of the texture. Therefore, a rectangle with zero origin, and unit size ((0.0, 0.0), (1.0, 1.0)) indicates that the mesh should be covered with the complete texture.</p>
<p>A rectangle of smaller size, and/or a non-zero origin, indicates that the mesh should be covered by a fractional area of the texture. For example, a rectangular value for this property with origin at (0.5, 0.5), and size of (0.5, 0.5) indicates that only the top-right quarter of the texture will be used to cover this mesh.</p>
<p>The bounds of the texture rectangle must fit within a unit rectangle. Both the bottom-left and top-right corners must lie between zero and one in both the X and Y directions.</p>
<p>The dimensions of the rectangle in this property are independent of adjustments made by the alignWithTexturesIn: and alignWithInvertedTexturesIn: methods. A unit rectangle value for this property will automatically take into consideration the adjustment made to the mesh by those methods, and will display only the part of the texture defined by them. Rectangular values for this property that are smaller than the unit rectangle will be relative to the displayable area defined by alignWithTexturesIn: and alignWithInvertedTexturesIn:.</p>
<p>As an example, if the alignWithTexturesIn: method was used to limit the mesh to using only 80% of the texture (perhaps when using a non-POT texture), and this property was set to a rectangle with origin at (0.5, 0.0) and size (0.5, 0.5), the mesh will be covered by the bottom-right quarter of the usable 80% of the overall texture.</p>
<p>This property affects all texture units used by this mesh, to query or change this property for a single texture unit only, use the textureRectangleForTextureUnit: and setTextureRectangle:forTextureUnit: methods.</p>
<p>The initial value of this property is a rectangle with origin at zero, and unit size, indicating that the mesh will be covered with the complete usable area of the texture. </p>

</div>
</div>
<a class="anchor" id="a00ab53446893ad0baf4537a731881eb1"></a><!-- doxytag: member="CC3Mesh::vertexCount" ref="a00ab53446893ad0baf4537a731881eb1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei CC3Mesh::vertexCount<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of vertices in this mesh. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_mesh_8h.html">CC3Mesh.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:08 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
