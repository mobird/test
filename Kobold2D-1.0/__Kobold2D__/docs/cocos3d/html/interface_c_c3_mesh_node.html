<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3MeshNode Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_mesh_node.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3MeshNode Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3MeshNode" --><!-- doxytag: inherits="CC3LocalContentNode" -->
<p><code>#include &lt;CC3MeshNode.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3MeshNode:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_mesh_node__inherit__graph.png" border="0" usemap="#_c_c3_mesh_node_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_mesh_node_inherit__map" id="_c_c3_mesh_node_inherit__map">
<area shape="rect" id="node9" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world." alt="" coords="659,30,755,58"/><area shape="rect" id="node15" href="interface_c_c3_box_node.html" title="CC3BoxNode is a type of CC3MeshNode that is specialized to display simple box or cube meshes..." alt="" coords="658,82,755,110"/><area shape="rect" id="node17" href="interface_c_c3_line_node.html" title="CC3LineNode is a type of CC3MeshNode that is specialized to display lines." alt="" coords="657,134,756,162"/><area shape="rect" id="node25" href="interface_c_c3_plane_node.html" title="CC3PlaneNode is a type of CC3MeshNode that is specialized to display planes and simple rectanglular m..." alt="" coords="655,186,759,214"/><area shape="rect" id="node27" href="interface_c_c3_p_o_d_mesh_node.html" title="A CC3MeshNode whose content originates from POD resource data." alt="" coords="641,238,772,266"/><area shape="rect" id="node29" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles." alt="" coords="629,290,784,318"/><area shape="rect" id="node37" href="interface_c_c3_skin_mesh_node.html" title="CC3SkinMeshNode is a CC3MeshNode specialized to use vertex skinning to draw the contents of its mesh..." alt="" coords="642,342,771,370"/><area shape="rect" id="node2" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="282,186,430,214"/><area shape="rect" id="node4" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="160,186,235,214"/><area shape="rect" id="node6" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,186,112,214"/><area shape="rect" id="node11" href="interface_c_c3_node_descriptor.html" title="CC3NodeDescriptor is a type of CC3Billboard specialized for attaching a descriptive text label to ano..." alt="" coords="871,5,1001,33"/><area shape="rect" id="node13" href="interface_c_c3_particle_system_billboard.html" title="A CC3Billboard node customized to display and manage a cocos2d 2D CCParticleSystem." alt="" coords="848,57,1024,85"/><area shape="rect" id="node19" href="interface_c_c3_wireframe_bounding_box_node.html" title="CC3WireframeBoundingBoxNode is a type of CC3LineNode specialized for drawing a wireframe bounding box..." alt="" coords="832,134,1040,162"/><area shape="rect" id="node21" href="interface_c_c3_direction_marker_node.html" title="CC3DirectionMarkerNode is a type of CC3LineNode specialized for drawing a line from the pivot point o..." alt="" coords="1146,109,1310,137"/><area shape="rect" id="node23" href="interface_c_c3_wireframe_local_content_bounding_box_node.html" title="CC3WireframeLocalContentBoundingBoxNode is a CC3WireframeBoundingBoxNode that further specializes in ..." alt="" coords="1088,161,1368,189"/><area shape="rect" id="node31" href="interface_c_c3_mortal_point_particle_emitter.html" title="CC3MortalPointParticleEmitter emits particles of type CC3MortalPointParticle." alt="" coords="841,290,1031,318"/><area shape="rect" id="node33" href="interface_c_c3_point_particle_hose_emitter.html" title="CC3PointParticleHoseEmitter emits CC3UniformMotionParticle particles in a stream, as if from the nozz..." alt="" coords="1137,290,1319,318"/><area shape="rect" id="node35" href="interface_c_c3_variegated_point_particle_hose_emitter.html" title="CC3VariegatedPointParticleHoseEmitter is a type of CC3PointParticleHoseEmitter whose particles can ha..." alt="" coords="1416,290,1656,318"/><area shape="rect" id="node39" href="interface_c_c3_p_o_d_skin_mesh_node.html" title="A CC3SkinMeshNode extracted from a POD file." alt="" coords="858,342,1014,370"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3MeshNode:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_mesh_node__coll__graph.png" border="0" usemap="#_c_c3_mesh_node_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_mesh_node_coll__map" id="_c_c3_mesh_node_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="49,179,196,207"/><area shape="rect" id="node4" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="85,99,159,127"/><area shape="rect" id="node6" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/><area shape="rect" id="node8" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array." alt="" coords="137,6,236,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_mesh_node-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a38e50d04d8d52734b33246590fdded38">alignInvertedTextures</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a943e5c901a964ec7a421f7f38b7046de">alignTextures</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a8a15c4a11e9d1075a623105fe81b96f9">drawWithVisitor:</a> (<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ae2233ea892001bf075a2affc7f73c174">movePivotTo:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aLocation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#aea4ca7e6c9b44d00590248713b9d1ca2">movePivotToCenterOfGeometry</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ae57f208fe2dc911287f9872f7862deec">populateAsCenteredRectangleWithSize:</a> (CGSize rectSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ad4f35b8a4c99fdf8089492b05ffe963e">populateAsCenteredRectangleWithSize:andTessellation:</a> (CGSize rectSize,[andTessellation] ccGridSize facesPerSide)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a9a3a3efa2c63efb1398eb271d4b5f80d">populateAsCenteredRectangleWithSize:andTessellation:withTexture:invertTexture:</a> (CGSize rectSize,[andTessellation] ccGridSize facesPerSide,[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ae89822fc38fc4772a110bb1b8b35cfb7">populateAsCenteredRectangleWithSize:withTexture:invertTexture:</a> (CGSize rectSize,[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a1e87161b0e6fc10f35206ee6704c7343">populateAsCenteredTexturedRectangleWithSize:</a> (CGSize rectSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ad1bce9ea33dc76b7f06df1b97f4db15c">populateAsCenteredTexturedRectangleWithSize:andTessellation:</a> (CGSize rectSize,[andTessellation] ccGridSize facesPerSide)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a32ede9a6cbd5b1ee51fd2fe58e9b5934">populateAsLineStripWith:vertices:andRetain:</a> (GLshort vertexCount,[vertices] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> *vertices,[andRetain] BOOL shouldRetainVertices)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a2372988a089bf02820974644e2acc98e">populateAsRectangleWithSize:andPivot:</a> (CGSize rectSize,[andPivot] CGPoint pivot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#aff9d8831e7ec49299b31910ab0b1dc19">populateAsRectangleWithSize:andPivot:andTessellation:</a> (CGSize rectSize,[andPivot] CGPoint pivot,[andTessellation] ccGridSize facesPerSide)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a978a5f54ea2eb24c8afa37976f867e01">populateAsRectangleWithSize:andPivot:andTessellation:withTexture:invertTexture:</a> (CGSize rectSize,[andPivot] CGPoint pivot,[andTessellation] ccGridSize facesPerSide,[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ac299281c24bf0531d0ab639a3048006a">populateAsRectangleWithSize:andPivot:withTexture:invertTexture:</a> (CGSize rectSize,[andPivot] CGPoint pivot,[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a1ea6896b09a8a424b09452283b8b6702">populateAsSolidBox:</a> (<a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a> box)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#aa47ab37ab2c849a5f6e98d7ac1b2e078">populateAsTexturedBox:</a> (<a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a> box)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a2476d68c1449e1b8c27daa3ff343ebb7">populateAsTexturedBox:withCorner:</a> (<a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a> box,[withCorner] CGPoint corner)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a66ea3d7d7c60f53b84ed804b1c07e4ec">populateAsTexturedRectangleWithSize:andPivot:</a> (CGSize rectSize,[andPivot] CGPoint pivot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a5e8eddffb318b7294082a8972d2c6dbc">populateAsTexturedRectangleWithSize:andPivot:andTessellation:</a> (CGSize rectSize,[andPivot] CGPoint pivot,[andTessellation] ccGridSize facesPerSide)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a9872aced2bf86dcc192457d1fb1a56b5">populateAsWireBox:</a> (<a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a> box)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a0bf58ada0895f6d057fc98e7bd0a5e7d">repeatTexture:</a> (ccTex2F repeatFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a4ae2877853694867b97ebf78b33126b5">setTextureRectangle:forTextureUnit:</a> (CGRect aRect,[forTextureUnit] GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a6b79e7c92b6a77ec18dbdee5d007d610">setVertexColor4B:at:</a> (ccColor4B aColor,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ad1d7f5a839a3b00f6a5e1859d6250408">setVertexColor4F:at:</a> (ccColor4F aColor,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a5ab34fb95e763b49392102572336e091">setVertexIndex:at:</a> (GLushort vertexIndex,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a8d9e80c3c224f8674fb9c62dd7cf7350">setVertexLocation:at:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aLocation,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#afacf68a203820d1ee4fe372c91e1d242">setVertexNormal:at:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aNormal,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#aed8b5c07945af57a59f254e90fb4ebb7">setVertexTexCoord2F:at:</a> (ccTex2F aTex2F,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a14d4c3ada0ad471dc04c0a2cd210693c">setVertexTexCoord2F:at:forTextureUnit:</a> (ccTex2F aTex2F,[at] GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a62118cf69cb4b1565710b72afbf4bea0">setVertexTexCoord2F:forTextureUnit:at:</a> (ccTex2F aTex2F,[forTextureUnit] GLuint texUnit,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#abf62b261e4c4bcf4dddc439502c6deb1">textureRectangleForTextureUnit:</a> (GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a410d15616e85748ce08b77ea5da8decb">updateVertexColorsGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a8c64fe8a5ada06497266bcd8f0c59d6e">updateVertexIndicesGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#aa22ed6c99ab406bb6db4ceb4761df6a4">updateVertexLocationsGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a5d40646aecf0cfc154f301e51d30188c">updateVertexNormalsGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ad44d62a32b1f5a178fb72dc557e18c53">updateVertexTextureCoordinatesGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a42d1058314a48ed8219f10ffb21e1fbb">updateVertexTextureCoordinatesGLBufferForTextureUnit:</a> (GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a8cdc654b1b7b9c5d6bd7cc43f4b48854">vertexColor4BAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#adb59f427e74e4c91e491127b2c5334b0">vertexColor4FAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a580a2158248a5502239a469cf5d4bd41">vertexIndexAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a5e938fe4af9e968d54b03bcf20180741">vertexLocationAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#abe085d7a7651f24a84b0351203225efc">vertexNormalAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTex2F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#acff9e22dd21e4a1fc10cc8fd1227bb7f">vertexTexCoord2FAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTex2F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a337da566060400aacd1015d1831a3a87">vertexTexCoord2FAt:forTextureUnit:</a> (GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTex2F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ad0268f81b9c11ee435683f6b2e70da79">vertexTexCoord2FForTextureUnit:at:</a> (GLuint texUnit,[at] GLsizei index)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ab4521a811bbadf0fc5077d70e2b696f4">depthFunction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_node_8h.html#a4bed21b96ced6e7ff2d912800ab99bba">CC3NormalScaling</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a99927d686b53cd38f0adfff1dd694083">normalScalingMethod</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a0a2dcf49d0997083a838a366d7a026d1">shouldCullBackFaces</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#aba9c33476284294c99a718a0259c4c9a">shouldCullFrontFaces</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a36ab2366c2f8cb77f6898c7a6a65f682">shouldDisableDepthMask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a8710a0a76335e1cffa53c0304214a036">shouldDisableDepthTest</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a4a416a1c347b2e7808aaae647a3d7ede">shouldUseClockwiseFrontFaceWinding</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ae8856e39d188accad9ad49dbd40649f2">shouldUseSmoothShading</a></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a9386e779eac298341f6516010931b514">ambientColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccBlendFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a0014822499c656bc65edffcc1ddeb032">blendFunc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor3B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a06c3e0690e2999a93919ba2d28e29193">color</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_mesh_model.html">CC3MeshModel</a> *meshModel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a4d20b4f99edba78e678636b6138497a2">DEPRECATED_ATTRIBUTE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a1c4476ee10e9dad251c00b0723ef7ba7">diffuseColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a27945960af75a269569cb02f687e151b">emissionColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a09ac6d16d320cecc66c0917979a92b3e">globalLightLocation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ac754a405d9012e05421e24989865f7c4">isOpaque</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_material.html">CC3Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ad2c0fcf674357d22301cc5402cb4d21f">material</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a0602b5efbec034a0385d306b549a183e">mesh</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLubyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#af790e70c1f94c040dea7e7229c28b851">opacity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a38e40a48403707d3934a935271ce8c98">podMaterialIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a0acd881192a53c06b30cab629a849832">pureColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#ab3f2190eb12f133a7d2d35ba8173952d">shouldDrawLowAlpha</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a32c89a1b1bdb7ec9ebb2bbaafd5a53d9">shouldUseLighting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#add17365ad2a6a86b4a75b63b12b8bcfc">specularColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#abbfb00b5c05dee12ae7dec23c79f4829">texture</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CGRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#abe70cbf2b2075f510361eaa7441f0f7e">textureRectangle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_mesh_node.html#a7b583556730377b5e838e0dfcfb3d8ac">vertexCount</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> that draws a 3D mesh. </p>
<p>This class forms the base of all visible 3D mesh models in the 3D world.</p>
<p><a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> is a type of <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a>, and will often participate in a structural node assembly. An instance can be the child of another node, and the mesh node itself can have child nodes.</p>
<p>CC3MeshNodes encapsulate a <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> instance, and can also encapsulate either a <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance, or a pure color. The <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> instance contains the mesh vertex data. The <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance describes the material and texture properties covering the mesh, which are affected by lighting conditions. Alternately, instead of a material, the mesh may be colored by a single pure color via the pureColor property.</p>
<p>There are a number of populateAs... parametric population methods available in the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> (ParametricShapes) category extension. These methods can be used to populate the vertices of the mesh contained in a new mesh node to create interesting and useful parametric shapes and surfaces.</p>
<p>When this node is drawn, it delegates to the mesh instance to render the mesh vertices. If a material is defined, before drawing the mesh, it delegates to the material to configure the covering of the mesh. If no material is defined, the node establishes its pure color before rendering the mesh. The pure color is only used if the node has no material attached. And the pure color may in turn be overridden by the mesh data if vertex coloring is in use.</p>
<p>Each <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> can have only one material or pure color. For large, complicated meshes that are covered by more than one material, or colored with more than one color, the mesh must be broken into smaller meshes, each of which are covered by a single material or color. These smaller sub-meshes are sometimes referred to as "vertex groups". Each such sub-mesh is then wrapped in its own <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instance, along with the material that covers that sub-mesh.</p>
<p>These <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instances can then be added as child nodes to a single parent <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> instance. This parent <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> can then be moved, rotated and scaled, and all of its child nodes will transform in sync. The assembly will behave and be seen as a single object.</p>
<p>When the mesh is set in the mesh property, the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instance creates and builds a <a class="el" href="interface_c_c3_node_bounding_volume.html" title="Bounding volumes are used by CC3Nodes to determine whether a node interset the camera&#39;s frustum...">CC3NodeBoundingVolume</a> instance from the mesh data, and sets it into its boundingVolume property.</p>
<p>When a copy is made of a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instance using the copy method, a copy is made of the material, but the mesh is simply assigned by reference, and is not copied. The result is that the the new and original nodes will have different materials, but will share the same mesh. This design avoids creating multiple copies of volumnious and static mesh data when creating copies of nodes.</p>
<p>Normally, the front faces of a mesh are displayed, and the back faces are culled and not displayed. You can change this behaviour if you need to be changing the values of the shouldCullFrontFaces and shouldCullBackFaces properties. An example might be if you wanted to show the back-side of a planar sign, or if you wanted to show the inside faces of a skybox.</p>
<p>However, be aware that culling is a significant performance-improving technique. You should avoid disabling backface culling except where specifically needed for visual effect. And when you do, if you only need the back faces, turn on front face culling for that mesh by setting the shouldCullFrontFaces property to YES. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a38e50d04d8d52734b33246590fdded38"></a><!-- doxytag: member="CC3MeshNode::alignInvertedTextures" ref="a38e50d04d8d52734b33246590fdded38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::alignInvertedTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the texture coordinates of the mesh with the textures held in the material. </p>
<p>The texture coordinates are aligned assuming that the texture is inverted in the Y-direction. Certain texture formats are inverted during loading, and this method can be used to compensate.</p>
<p>This method can be useful when the width and height of the textures in the material are not a power-of-two. Under iOS, when loading a texture that is not a power-of-two, the texture will be converted to a size whose width and height are a power-of-two. The result is a texture that can have empty space on the top and right sides. If the texture coordinates of the mesh do not take this into consideration, the result will be that only the lower left of the mesh will be covered by the texture.</p>
<p>When this occurs, invoking this method will adjust the texture coordinates of the mesh to map to the original width and height of the texturesa.</p>
<p>If the mesh is using multi-texturing, this method will adjust the texture coordinates array for each texture unit, using the corresponding texture for that texture unit in the specified material.</p>
<p>Care should be taken when using this method, as it changes the actual vertex data. This method should only be invoked once on any mesh, and it may cause mapping conflicts if the same mesh is shared by other CC3MeshNodes that use different textures.</p>
<p>This method will also invoke the superclass behaviour to invoke the same method on each child node.</p>
<p>To adjust the texture coordinates of only a single mesh, without adjusting the texture coordinates of any descendant nodes, invoke the alignWithInvertedTexturesIn: method of the <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> held in this mesh node. To adjust the texture coordinates of only a single texture coordinates array within the mesh, invoke the alignWithInvertedTexture: method on the appropriate instance of <a class="el" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices.">CC3VertexTextureCoordinates</a>. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a5b69b89f01d7c98c0303f1e03d976558">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a943e5c901a964ec7a421f7f38b7046de"></a><!-- doxytag: member="CC3MeshNode::alignTextures" ref="a943e5c901a964ec7a421f7f38b7046de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::alignTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aligns the texture coordinates of the mesh with the textures held in the material. </p>
<p>This method can be useful when the width and height of the textures in the material are not a power-of-two. Under iOS, when loading a texture that is not a power-of-two, the texture will be converted to a size whose width and height are a power-of-two. The result is a texture that can have empty space on the top and right sides. If the texture coordinates of the mesh do not take this into consideration, the result will be that only the lower left of the mesh will be covered by the texture.</p>
<p>When this occurs, invoking this method will adjust the texture coordinates of the mesh to map to the original width and height of the textures.</p>
<p>If the mesh is using multi-texturing, this method will adjust the texture coordinates array for each texture unit, using the corresponding texture for that texture unit in the specified material.</p>
<p>Care should be taken when using this method, as it changes the actual vertex data. This method should only be invoked once on any mesh, and it may cause mapping conflicts if the same mesh is shared by other CC3MeshNodes that use different textures.</p>
<p>This method will also invoke the superclass behaviour to invoke the same method on each child node.</p>
<p>To adjust the texture coordinates of only a single mesh, without adjusting the texture coordinates of any descendant nodes, invoke the alignWithTexturesIn: method of the <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> held in this mesh node. To adjust the texture coordinates of only a single texture coordinates array within the mesh, invoke the alignWithTexture: method on the appropriate instance of <a class="el" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices.">CC3VertexTextureCoordinates</a>. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a6ba26fe792bf02227f68e7e22d3a56cb">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a8a15c4a11e9d1075a623105fe81b96f9"></a><!-- doxytag: member="CC3MeshNode::drawWithVisitor:" ref="a8a15c4a11e9d1075a623105fe81b96f9" args="(CC3NodeDrawingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::drawWithVisitor: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws the local content of this mesh node by following these steps: </p>
<ol type="1">
<li>If the shouldDecorateNode property of the visitor is YES, and this node has a material, invokes the drawWithVisitor method of the material. Otherwise, invokes the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> class-side unbind method.</li>
<li>Invokes the drawWithVisitor: method of the encapsulated mesh.</li>
</ol>
<p>This method is called automatically from the transformAndDrawWithVisitor: method of this node. Usually, the application never needs to invoke this method directly. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a883c0a80269bd598483d19480b8276ec">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="ae2233ea892001bf075a2affc7f73c174"></a><!-- doxytag: member="CC3MeshNode::movePivotTo:" ref="ae2233ea892001bf075a2affc7f73c174" args="(CC3Vector aLocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::movePivotTo: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aLocation</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the mesh data so that the pivot point of the mesh will be at the specified location. </p>
<p>The pivot point of the mesh is the location in the local coordinate system around which all transforms are performed. A vertex at the pivot point would have local coordinates (0,0,0).</p>
<p>This method can be used to adjust the mesh structure to make it easier to apply transformations, by moving the origin of the transformations to a more convenient location in the mesh.</p>
<p>This method changes the location component of every vertex in the mesh data. This can be quite costly, and should only be performed once to adjust a mesh so that it is easier to manipulate.</p>
<p>Do not use this method to move your model around. Instead, use the transform properties (location, rotation and scale) of this node, and let the GL engine do the heavy lifting of transforming the mesh vertices.</p>
<p>Since the new mesh locations will change the bounding box of the mesh, this method invokes the rebuildBoundingVolume method on the boundingVolume of this node, to ensure that the boundingVolume encompasses the new vertex locations.</p>
<p>This method also ensures that the GL VBO that holds the vertex data is updated. </p>

</div>
</div>
<a class="anchor" id="aea4ca7e6c9b44d00590248713b9d1ca2"></a><!-- doxytag: member="CC3MeshNode::movePivotToCenterOfGeometry" ref="aea4ca7e6c9b44d00590248713b9d1ca2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::movePivotToCenterOfGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the mesh data so that the pivot point of the mesh will be at the center of geometry of the mesh vertices. </p>
<p>The pivot point of the mesh is the location in the local coordinate system around which all transforms are performed. A vertex at the pivot point would have local coordinates (0,0,0).</p>
<p>This method can be used to adjust the mesh structure to make it easier to apply transformations, by moving the origin of the transformations to the center of the mesh.</p>
<p>This method changes the location component of every vertex in the mesh data. This can be quite costly, and should only be performed once to adjust a mesh so that it is easier to manipulate.</p>
<p>Do not use this method to move your model around. Instead, use the transform properties (location, rotation and scale) of this node, and let the GL engine do the heavy lifting of transforming the mesh vertices.</p>
<p>Since the new mesh locations will change the bounding box of the mesh, this method invokes the rebuildBoundingVolume method on the boundingVolume of this node, to ensure that the boundingVolume encompasses the new vertex locations.</p>
<p>This method also ensures that the GL VBO that holds the vertex data is updated. </p>

</div>
</div>
<a class="anchor" id="ae57f208fe2dc911287f9872f7862deec"></a><!-- doxytag: member="CC3MeshNode::populateAsCenteredRectangleWithSize:" ref="ae57f208fe2dc911287f9872f7862deec" args="(CGSize rectSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsCenteredRectangleWithSize: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, centered at the origin, and laid out on the X-Y plane. </p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking populateAsCenteredRectangleWithSize:andTessellation: with the facesPerSide argument set to {1,1}.</p>
<p>You can add a material or pureColor as desired to establish how the look of the rectangle. </p>

</div>
</div>
<a class="anchor" id="ad4f35b8a4c99fdf8089492b05ffe963e"></a><!-- doxytag: member="CC3MeshNode::populateAsCenteredRectangleWithSize:andTessellation:" ref="ad4f35b8a4c99fdf8089492b05ffe963e" args="(CGSize rectSize,[andTessellation] ccGridSize facesPerSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsCenteredRectangleWithSize:andTessellation: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTessellation] ccGridSize&#160;</td>
          <td class="paramname"><em>facesPerSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, centered at the origin, and laid out on the X-Y plane. </p>
<p>The large rectangle can be broken down into many smaller faces. Building a rectanglular surface from more than one face can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The facesPerSide argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the facesPerSide argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the facesPerSide argument.</p>
<p>For example, a value of {5,5} for the facesPerSide argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid.</p>
<p>You can add a material or pureColor as desired to establish how the look of the rectangle. </p>

</div>
</div>
<a class="anchor" id="a9a3a3efa2c63efb1398eb271d4b5f80d"></a><!-- doxytag: member="CC3MeshNode::populateAsCenteredRectangleWithSize:andTessellation:withTexture:invertTexture:" ref="a9a3a3efa2c63efb1398eb271d4b5f80d" args="(CGSize rectSize,[andTessellation] ccGridSize facesPerSide,[withTexture] CC3Texture *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsCenteredRectangleWithSize:andTessellation:withTexture:invertTexture: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTessellation] ccGridSize&#160;</td>
          <td class="paramname"><em>facesPerSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[invertTexture] BOOL&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Use the populateAsCenteredTexturedRectangleWithSize:andTessellation: method instead, and then use the texture property of this node to set the texture.</dd></dl>
<p>When using that replacement method, if your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture. </p>

</div>
</div>
<a class="anchor" id="ae89822fc38fc4772a110bb1b8b35cfb7"></a><!-- doxytag: member="CC3MeshNode::populateAsCenteredRectangleWithSize:withTexture:invertTexture:" ref="ae89822fc38fc4772a110bb1b8b35cfb7" args="(CGSize rectSize,[withTexture] CC3Texture *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsCenteredRectangleWithSize:withTexture:invertTexture: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[invertTexture] BOOL&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use the populateAsCenteredTexturedRectangleWithSize: method instead, and then use the texture property of this node to set the texture.</dd></dl>
<p>When using that replacement method, if your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture. </p>

</div>
</div>
<a class="anchor" id="a1e87161b0e6fc10f35206ee6704c7343"></a><!-- doxytag: member="CC3MeshNode::populateAsCenteredTexturedRectangleWithSize:" ref="a1e87161b0e6fc10f35206ee6704c7343" args="(CGSize rectSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsCenteredTexturedRectangleWithSize: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a rectangular mesh of the specified size, centered at the origin, laid out on the X-Y plane, and that can be covered by a texture. </p>
<p>Use the texture property of this node to set the texture.</p>
<p>If your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture.</p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking populateAsCenteredTexturedRectangleWithSize:andTessellation: with the facesPerSide argument set to {1,1}. </p>

</div>
</div>
<a class="anchor" id="ad1bce9ea33dc76b7f06df1b97f4db15c"></a><!-- doxytag: member="CC3MeshNode::populateAsCenteredTexturedRectangleWithSize:andTessellation:" ref="ad1bce9ea33dc76b7f06df1b97f4db15c" args="(CGSize rectSize,[andTessellation] ccGridSize facesPerSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsCenteredTexturedRectangleWithSize:andTessellation: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTessellation] ccGridSize&#160;</td>
          <td class="paramname"><em>facesPerSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a rectangular mesh of the specified size, centered at the origin, laid out on the X-Y plane, and that can be covered by a texture. </p>
<p>Use the texture property of this node to set the texture.</p>
<p>If your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture.</p>
<p>The large rectangle can be broken down into many smaller faces. Building a rectanglular surface from more than one face can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The facesPerSide argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the facesPerSide argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the facesPerSide argument.</p>
<p>For example, a value of {5,5} for the facesPerSide argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid. </p>

</div>
</div>
<a class="anchor" id="a32ede9a6cbd5b1ee51fd2fe58e9b5934"></a><!-- doxytag: member="CC3MeshNode::populateAsLineStripWith:vertices:andRetain:" ref="a32ede9a6cbd5b1ee51fd2fe58e9b5934" args="(GLshort vertexCount,[vertices] CC3Vector *vertices,[andRetain] BOOL shouldRetainVertices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsLineStripWith:vertices:andRetain: </td>
          <td>(</td>
          <td class="paramtype">GLshort&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[vertices] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andRetain] BOOL&#160;</td>
          <td class="paramname"><em>shouldRetainVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a line strip with the specified number of vertex points. </p>
<p>The data for the points that define the end-points of the lines are contained within the specified vertices array. The vertices array must contain at least vertexCount elements.</p>
<p>The lines are specified and rendered as a strip, where each line is connected to the previous and following lines. Each line starts at the point where the previous line ended, and that point is defined only once in the vertices array. Therefore, the number of lines drawn is equal to one less than the specified vertexCount.</p>
<p>The shouldRetainVertices flag indicates whether the data in the vertices array should be retained by this instance. If this flag is set to YES, the data in the vertices array will be copied to an internal array that is managed by this instance. If this flag is set to NO, the data is not copied internally and, instead, a reference to the vertices data is established. In this case, it is up to you to manage the lifespan of the data contained in the vertices array.</p>
<p>If you are defining the vertices data dynamically in another method, you may want to set this flag to YES to have this instance copy and manage the data. If the vertices array is a static array, you can set this flag to NO.</p>
<p>You can add a material or pureColor as desired to establish the color of the lines. If a material is used, the appearance of the lines will be affected by the lighting conditions. If a pureColor is used, the appearance of the lines will not be affected by the lighting conditions, and the wire-frame box will always appear in the same pure, solid color, regardless of the lighting sources.</p>
<p>As this node is translated, rotate and scaled, the line strip will be re-oriented in 3D space.</p>
<p>This is a convenience method for creating a simple, but useful, shape. </p>

</div>
</div>
<a class="anchor" id="a2372988a089bf02820974644e2acc98e"></a><!-- doxytag: member="CC3MeshNode::populateAsRectangleWithSize:andPivot:" ref="a2372988a089bf02820974644e2acc98e" args="(CGSize rectSize,[andPivot] CGPoint pivot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsRectangleWithSize:andPivot: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andPivot] CGPoint&#160;</td>
          <td class="paramname"><em>pivot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, with the specified pivot point at the origin, and laid out on the X-Y plane. </p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking populateAsRectangleWithSize:andPivot:andTessellation: with the facesPerSide argument set to {1,1}.</p>
<p>You can add a material or pureColor as desired to establish how the look of the rectangle.</p>
<p>The pivot point can be any point within the rectangle's size. For example, if the pivot point is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. Or, if the pivot point is in the center of the rectangle's size, the rectangle will be laid out centered on the origin, as in the populateAsCenteredRectangleWithSize: method. </p>

</div>
</div>
<a class="anchor" id="aff9d8831e7ec49299b31910ab0b1dc19"></a><!-- doxytag: member="CC3MeshNode::populateAsRectangleWithSize:andPivot:andTessellation:" ref="aff9d8831e7ec49299b31910ab0b1dc19" args="(CGSize rectSize,[andPivot] CGPoint pivot,[andTessellation] ccGridSize facesPerSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsRectangleWithSize:andPivot:andTessellation: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andPivot] CGPoint&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTessellation] ccGridSize&#160;</td>
          <td class="paramname"><em>facesPerSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a simple rectangular mesh of the specified size, with the specified pivot point at the origin, and laid out on the X-Y plane. </p>
<p>The large rectangle can be broken down into many smaller faces. Building a rectanglular surface from more than one face can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The facesPerSide argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the facesPerSide argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the facesPerSide argument.</p>
<p>For example, a value of {5,5} for the facesPerSide argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid.</p>
<p>You can add a material or pureColor as desired to establish how the look of the rectangle.</p>
<p>The pivot point can be any point within the rectangle's size. For example, if the pivot point is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. Or, if the pivot point is in the center of the rectangle's size, the rectangle will be laid out centered on the origin, as in the populateAsCenteredRectangleWithSize method. </p>

</div>
</div>
<a class="anchor" id="a978a5f54ea2eb24c8afa37976f867e01"></a><!-- doxytag: member="CC3MeshNode::populateAsRectangleWithSize:andPivot:andTessellation:withTexture:invertTexture:" ref="a978a5f54ea2eb24c8afa37976f867e01" args="(CGSize rectSize,[andPivot] CGPoint pivot,[andTessellation] ccGridSize facesPerSide,[withTexture] CC3Texture *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsRectangleWithSize:andPivot:andTessellation:withTexture:invertTexture: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andPivot] CGPoint&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTessellation] ccGridSize&#160;</td>
          <td class="paramname"><em>facesPerSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[invertTexture] BOOL&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Use the populateAsCenteredTexturedRectangleWithSize:andPivot:andTessellation: method instead, and then use the texture property of this node to set the texture.</dd></dl>
<p>When using that replacement method, if your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture. </p>

</div>
</div>
<a class="anchor" id="ac299281c24bf0531d0ab639a3048006a"></a><!-- doxytag: member="CC3MeshNode::populateAsRectangleWithSize:andPivot:withTexture:invertTexture:" ref="ac299281c24bf0531d0ab639a3048006a" args="(CGSize rectSize,[andPivot] CGPoint pivot,[withTexture] CC3Texture *texture,[invertTexture] BOOL DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsRectangleWithSize:andPivot:withTexture:invertTexture: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andPivot] CGPoint&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withTexture] <a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[invertTexture] BOOL&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Use the populateAsTexturedRectangleWithSize:andPivot: method instead, and then use the texture property of this node to set the texture.</dd></dl>
<p>When using that replacement method, if your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture. </p>

</div>
</div>
<a class="anchor" id="a1ea6896b09a8a424b09452283b8b6702"></a><!-- doxytag: member="CC3MeshNode::populateAsSolidBox:" ref="a1ea6896b09a8a424b09452283b8b6702" args="(CC3BoundingBox box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsSolidBox: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a>&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners. </p>
<p>You can add a material or pureColor as desired to establish how the color of the box.</p>
<p>This is a convenience method for creating a simple, but useful shape, which can be used to create simple structures in your 3D world. </p>

</div>
</div>
<a class="anchor" id="aa47ab37ab2c849a5f6e98d7ac1b2e078"></a><!-- doxytag: member="CC3MeshNode::populateAsTexturedBox:" ref="aa47ab37ab2c849a5f6e98d7ac1b2e078" args="(CC3BoundingBox box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsTexturedBox: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a>&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box, and configures the mesh texture coordinates so that the entire box can be wrapped in a single texture. </p>
<p>Use the texture property of this node to set the texture.</p>
<p>Since the single texture is wrapped around all six sides of the box, the texture should have a specific layout, which you can see illustrated in the texture file BoxTexture.png.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping the texture around the box, this method assumes that the natural shape of the box is a cube. The box can be created with any relative dimensions, but if it is not a cube, the texture may appear stretched or shrunk on two or more sides. The texture will still fully wrap all six sides of the box, but the texture is stretched or shrunk to fit each side according to its dimension relative to the other sides. The appearance will be as if you had started with a textured cube and then pulled one of the dimensions out further.</p>
<p>For higher fidelity in applying textures to non-cube boxes, so that the texture will not be stretched to fit, use the populateAsTexturedBox:withCorner: method.</p>
<p>If your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture.</p>
<p>Thanks to cocos3d user andyman for contributing the prototype code and texture template file for this method. </p>

</div>
</div>
<a class="anchor" id="a2476d68c1449e1b8c27daa3ff343ebb7"></a><!-- doxytag: member="CC3MeshNode::populateAsTexturedBox:withCorner:" ref="a2476d68c1449e1b8c27daa3ff343ebb7" args="(CC3BoundingBox box,[withCorner] CGPoint corner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsTexturedBox:withCorner: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a>&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withCorner] CGPoint&#160;</td>
          <td class="paramname"><em>corner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a simple rectangular box mesh from the specified bounding box, which contains two of the diagonal corners of the box, and configures the mesh texture coordinates so that the entire box can be wrapped in a single texture. </p>
<p>Use the texture property of this node to set the texture.</p>
<p>Since the single texture is wrapped around all six sides of the box, the texture should have a specific layout, which you can see illustrated in the texture file BoxTexture.png.</p>
<p>The "front" of the box is the side that faces towards the positive-Z axis, the "top" of the box is the side that faces towards the positive-Y axis, and the "right" side of the box is the side that faces towards the positive-X axis.</p>
<p>For the purposes of wrapping the texture around the box, the corner argument is used to indicate the relative dimensions of the box. Specifically, the corner argument specifies the point in the texture that is at the juncture of the "left" "front" and "bottom" sides of the texture (see the BoxTexture.png image for a better understanding of this point), and is specified as a fraction in each of the S &amp; T dimensions of the texture. In the CGPoint that specifies the corner, the x &amp; y elements of the CGPoint correspond to the S &amp; T dimensions of the juncture of the "left", "front" and "bottom" sides in the texture.</p>
<p>Since, by definition, opposite sides of the box have the same dimensions, this single corner point identifies the S &amp; T dimensions of all six of the sides of the box. A value of (1/4, 1/3) for the corner is used when the box is a cube. A smaller value for the x-element would move the corner to the left in the texture layout, indicating that the left and right sides are shallower than they are in a cube, and that the front and back are wider than in a cube, and vice-versa for a larger value in the x-element of the corner. Similarly for the y-element. A y-element that is smaller than 1/3, moves the corner point downwards on the texture, indicating that the bottom and top are shallower than they are in a cube, or that the front and back are higher than they are in a cube.</p>
<p>The two axes defined by the corner are interrelated, because the sides need to be the same depth as the top and bottom. The best way to determine the values to use in the corner is to use the measure of this point (where the "left", "front", and "bottom" sides meet) from the layout of the texture.</p>
<p>If your texture is not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture.</p>
<p>Thanks to cocos3d user andyman for contributing the prototype code and texture template file for this method. </p>

</div>
</div>
<a class="anchor" id="a66ea3d7d7c60f53b84ed804b1c07e4ec"></a><!-- doxytag: member="CC3MeshNode::populateAsTexturedRectangleWithSize:andPivot:" ref="a66ea3d7d7c60f53b84ed804b1c07e4ec" args="(CGSize rectSize,[andPivot] CGPoint pivot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsTexturedRectangleWithSize:andPivot: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andPivot] CGPoint&#160;</td>
          <td class="paramname"><em>pivot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a rectangular mesh of the specified size, with the specified pivot point at the origin, laid out on the X-Y plane, and that can be covered by a texture. </p>
<p>Use the texture property of this node to set the texture.</p>
<p>If your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture.</p>
<p>The pivot point can be any point within the rectangle's size. For example, if the pivot point is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. Or, if the pivot point is in the center of the rectangle's size, the rectangle will be laid out centered on the origin, as in the populateAsCenteredTexturedRectangleWithSize: method.</p>
<p>The rectangular mesh contains only one face with two triangles. The result is the same as invoking populateAsCenteredTexturedRectangleWithSize:andPivot:andTessellation: with the facesPerSide argument set to {1,1}. </p>

</div>
</div>
<a class="anchor" id="a5e8eddffb318b7294082a8972d2c6dbc"></a><!-- doxytag: member="CC3MeshNode::populateAsTexturedRectangleWithSize:andPivot:andTessellation:" ref="a5e8eddffb318b7294082a8972d2c6dbc" args="(CGSize rectSize,[andPivot] CGPoint pivot,[andTessellation] ccGridSize facesPerSide)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsTexturedRectangleWithSize:andPivot:andTessellation: </td>
          <td>(</td>
          <td class="paramtype">CGSize&#160;</td>
          <td class="paramname"><em>rectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andPivot] CGPoint&#160;</td>
          <td class="paramname"><em>pivot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTessellation] ccGridSize&#160;</td>
          <td class="paramname"><em>facesPerSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a rectangular mesh of the specified size, with the specified pivot point at the origin, laid out on the X-Y plane, and that can be covered by a texture. </p>
<p>Use the texture property of this node to set the texture.</p>
<p>If your texture does not have both dimensions as power-of-two dimensions, you can use either of the alignTextures or alignInvertedTextures methods to adjust the mesh texture coordinates to make use of only the usable portion of the texture.</p>
<p>The pivot point can be any point within the rectangle's size. For example, if the pivot point is {0, 0}, the rectangle will be laid out so that the bottom-left corner is at the origin. Or, if the pivot point is in the center of the rectangle's size, the rectangle will be laid out centered on the origin, as in the populateAsCenteredTexturedRectangleWithSize: method.</p>
<p>The large rectangle can be broken down into many smaller faces. Building a rectanglular surface from more than one face can dramatically improve realism when the surface is illuminated with specular lighting or a tightly focused spotlight, because increasing the face count increases the number of vertices that interact with the specular or spot lighting.</p>
<p>The facesPerSide argument indicates how to break this large rectangle into multiple faces. The X &amp; Y elements of the facesPerSide argument indicate how each axis if the rectangle should be divided into faces. The total number of faces in the rectangle will therefore be the multiplicative product of the X &amp; Y elements of the facesPerSide argument.</p>
<p>For example, a value of {5,5} for the facesPerSide argument will result in the rectangle being divided into 25 faces, arranged into a 5x5 grid. </p>

</div>
</div>
<a class="anchor" id="a9872aced2bf86dcc192457d1fb1a56b5"></a><!-- doxytag: member="CC3MeshNode::populateAsWireBox:" ref="a9872aced2bf86dcc192457d1fb1a56b5" args="(CC3BoundingBox box)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(ParametricShapes)::populateAsWireBox: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_bounding_box.html">CC3BoundingBox</a>&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as a wire-frame box with the specified dimensions. </p>
<p>You can add a material or pureColor as desired to establish the color of the lines of the wire-frame. If a material is used, the appearance of the lines will be affected by the lighting conditions. If a pureColor is used, the appearance of the lines will not be affected by the lighting conditions, and the wire-frame box will always appear in the same pure, solid color, regardless of the lighting sources.</p>
<p>As this node is translated, rotate and scaled, the wire-frame box will be re-oriented in 3D space.</p>
<p>This is a convenience method for creating a simple, but useful, shape. </p>

</div>
</div>
<a class="anchor" id="a0bf58ada0895f6d057fc98e7bd0a5e7d"></a><!-- doxytag: member="CC3MeshNode::repeatTexture:" ref="a0bf58ada0895f6d057fc98e7bd0a5e7d" args="(ccTex2F repeatFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::repeatTexture: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>repeatFactor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the mesh so that a texture applied to this mesh will be repeated the specified number of times across the mesh, in each dimension. </p>
<p>The repeatFactor argument contains two numbers, corresponding to how many times in each dimension the texture should be repeated.</p>
<p>As an example, a value of (1, 2) for the repeatValue indicates that the texture should repeat twice vertically, but not repeat horizontally.</p>
<p>When a texture is repeated, the corresponding side of the texture covering this mesh must have a length that is a power-of-two, otherwise the padding added by iOS to convert it to a power-of-two length internally will be visible in the repeating pattern across the mesh.</p>
<p>For a side that is not repeating, the corresponding side of the texture covering this mesh does not require a length that is a power-of-two.</p>
<p>The textureParameters property of any texture covering this mesh should include the GL_REPEAT setting in each of its texture wrap components that correspond to a repeatFactor greater than one. The GL_REPEAT setting is the default setting for <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a>.</p>
<p>For example, if you want to repeat your texture twice in one dimension, but only once in the other, then you would use a repeatFactor of (1, 2) or (2, 1). For the side that is repeating twice, the length of that side of the texture must be a power-of-two. But the other side may have any dimension. The textureParameters property of the <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a> should include the GL_REPEAT setting for the corresponding texture dimension.</p>
<p>If your texture requires aligning with the mesh (typically if one of the texture dimensions is not a power-of-two), you should invoke either the alignTextures or alignInvertedTextures method before invoking this method.</p>
<p>In the example above, you would invoke one of those methods before invoking this method, to first align the mesh with that non-power-of-two side.</p>
<p>The dimensions of the repeatFactor are independent of the size derived from the texture by the alignTextures or alignInvertedTextures methods. A value of 1.0 for an element in the specified repeatFactor will automatically take into consideration the adjustment made to the mesh by those methods, and will display only the part of the texture defined by them.</p>
<p>You can specify a fractional value for either of the components of the repeatFactor to expand the texture in that dimension so that only part of the texture appears in that dimension, while potentially repeating multiple times in the other dimension. </p>

</div>
</div>
<a class="anchor" id="a4ae2877853694867b97ebf78b33126b5"></a><!-- doxytag: member="CC3MeshNode::setTextureRectangle:forTextureUnit:" ref="a4ae2877853694867b97ebf78b33126b5" args="(CGRect aRect,[forTextureUnit] GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setTextureRectangle:forTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">CGRect&#160;</td>
          <td class="paramname"><em>aRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the textureRectangle property from the texture coordinates that are mapping the specified texture unit index. </p>
<p>See the notes for the textureRectangle property of this class for an explanation of the use of this property. </p>

</div>
</div>
<a class="anchor" id="a6b79e7c92b6a77ec18dbdee5d007d610"></a><!-- doxytag: member="CC3MeshNode::setVertexColor4B:at:" ref="a6b79e7c92b6a77ec18dbdee5d007d610" args="(ccColor4B aColor,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexColor4B:at: </td>
          <td>(</td>
          <td class="paramtype">ccColor4B&#160;</td>
          <td class="paramname"><em>aColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexColorsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="ad1d7f5a839a3b00f6a5e1859d6250408"></a><!-- doxytag: member="CC3MeshNode::setVertexColor4F:at:" ref="ad1d7f5a839a3b00f6a5e1859d6250408" args="(ccColor4F aColor,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexColor4F:at: </td>
          <td>(</td>
          <td class="paramtype">ccColor4F&#160;</td>
          <td class="paramname"><em>aColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the color element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexColorsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a5ab34fb95e763b49392102572336e091"></a><!-- doxytag: member="CC3MeshNode::setVertexIndex:at:" ref="a5ab34fb95e763b49392102572336e091" args="(GLushort vertexIndex,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexIndex:at: </td>
          <td>(</td>
          <td class="paramtype">GLushort&#160;</td>
          <td class="paramname"><em>vertexIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the index element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexIndicesGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a8d9e80c3c224f8674fb9c62dd7cf7350"></a><!-- doxytag: member="CC3MeshNode::setVertexLocation:at:" ref="a8d9e80c3c224f8674fb9c62dd7cf7350" args="(CC3Vector aLocation,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexLocation:at: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the location element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>Since the new vertex location may change the bounding box of the mesh, when all vertex changes have been made, be sure to invoke the rebuildBoundingVolume method on this node, to ensure that the boundingVolume encompasses the new vertex locations.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexLocationsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="afacf68a203820d1ee4fe372c91e1d242"></a><!-- doxytag: member="CC3MeshNode::setVertexNormal:at:" ref="afacf68a203820d1ee4fe372c91e1d242" args="(CC3Vector aNormal,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexNormal:at: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the normal element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexNormalsGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="aed8b5c07945af57a59f254e90fb4ebb7"></a><!-- doxytag: member="CC3MeshNode::setVertexTexCoord2F:at:" ref="aed8b5c07945af57a59f254e90fb4ebb7" args="(ccTex2F aTex2F,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexTexCoord2F:at: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>aTex2F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the texture coordinate element at the specified index in the vertex data, at the commonly used texture unit zero, to the specified texture coordinate value. </p>
<p>This is a convenience method that delegates to the setVertexTexCoord2F:forTextureUnit:at: method, passing in zero for the texture unit index.</p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexTextureCoordinatesGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a14d4c3ada0ad471dc04c0a2cd210693c"></a><!-- doxytag: member="CC3MeshNode::setVertexTexCoord2F:at:forTextureUnit:" ref="a14d4c3ada0ad471dc04c0a2cd210693c" args="(ccTex2F aTex2F,[at] GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexTexCoord2F:at:forTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>aTex2F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use the setVertexTexCoord2F:forTextureUnit:at: method instead, </dd></dl>

</div>
</div>
<a class="anchor" id="a62118cf69cb4b1565710b72afbf4bea0"></a><!-- doxytag: member="CC3MeshNode::setVertexTexCoord2F:forTextureUnit:at:" ref="a62118cf69cb4b1565710b72afbf4bea0" args="(ccTex2F aTex2F,[forTextureUnit] GLuint texUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::setVertexTexCoord2F:forTextureUnit:at: </td>
          <td>(</td>
          <td class="paramtype">ccTex2F&#160;</td>
          <td class="paramname"><em>aTex2F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the texture coordinate element at the specified index in the vertex data, at the specified texture unit index, to the specified texture coordinate value. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateVertexTextureCoordinatesGLBufferForTextureUnit: method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="abf62b261e4c4bcf4dddc439502c6deb1"></a><!-- doxytag: member="CC3MeshNode::textureRectangleForTextureUnit:" ref="abf62b261e4c4bcf4dddc439502c6deb1" args="(GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGRect CC3MeshNode::textureRectangleForTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the textureRectangle property from the texture coordinates that are mapping the specified texture unit index. </p>
<p>See the notes for the textureRectangle property of this class for an explanation of the use of this property. </p>

</div>
</div>
<a class="anchor" id="a410d15616e85748ce08b77ea5da8decb"></a><!-- doxytag: member="CC3MeshNode::updateVertexColorsGLBuffer" ref="a410d15616e85748ce08b77ea5da8decb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::updateVertexColorsGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex color data in this mesh. </p>

</div>
</div>
<a class="anchor" id="a8c64fe8a5ada06497266bcd8f0c59d6e"></a><!-- doxytag: member="CC3MeshNode::updateVertexIndicesGLBuffer" ref="a8c64fe8a5ada06497266bcd8f0c59d6e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::updateVertexIndicesGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex index data in this mesh. </p>

</div>
</div>
<a class="anchor" id="aa22ed6c99ab406bb6db4ceb4761df6a4"></a><!-- doxytag: member="CC3MeshNode::updateVertexLocationsGLBuffer" ref="aa22ed6c99ab406bb6db4ceb4761df6a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::updateVertexLocationsGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex location data in this mesh. </p>

</div>
</div>
<a class="anchor" id="a5d40646aecf0cfc154f301e51d30188c"></a><!-- doxytag: member="CC3MeshNode::updateVertexNormalsGLBuffer" ref="a5d40646aecf0cfc154f301e51d30188c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::updateVertexNormalsGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex normal data in this mesh. </p>

</div>
</div>
<a class="anchor" id="ad44d62a32b1f5a178fb72dc557e18c53"></a><!-- doxytag: member="CC3MeshNode::updateVertexTextureCoordinatesGLBuffer" ref="ad44d62a32b1f5a178fb72dc557e18c53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::updateVertexTextureCoordinatesGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex texture coord data from texture unit zero in this mesh. </p>

</div>
</div>
<a class="anchor" id="a42d1058314a48ed8219f10ffb21e1fbb"></a><!-- doxytag: member="CC3MeshNode::updateVertexTextureCoordinatesGLBufferForTextureUnit:" ref="a42d1058314a48ed8219f10ffb21e1fbb" args="(GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3MeshNode::updateVertexTextureCoordinatesGLBufferForTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the vertex texture coord data from the specified texture unit in this mesh. </p>

</div>
</div>
<a class="anchor" id="a8cdc654b1b7b9c5d6bd7cc43f4b48854"></a><!-- doxytag: member="CC3MeshNode::vertexColor4BAt:" ref="a8cdc654b1b7b9c5d6bd7cc43f4b48854" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4B CC3MeshNode::vertexColor4BAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the color element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="adb59f427e74e4c91e491127b2c5334b0"></a><!-- doxytag: member="CC3MeshNode::vertexColor4FAt:" ref="adb59f427e74e4c91e491127b2c5334b0" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3MeshNode::vertexColor4FAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the color element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a580a2158248a5502239a469cf5d4bd41"></a><!-- doxytag: member="CC3MeshNode::vertexIndexAt:" ref="a580a2158248a5502239a469cf5d4bd41" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLushort CC3MeshNode::vertexIndexAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a5e938fe4af9e968d54b03bcf20180741"></a><!-- doxytag: member="CC3MeshNode::vertexLocationAt:" ref="a5e938fe4af9e968d54b03bcf20180741" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3MeshNode::vertexLocationAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the location element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="abe085d7a7651f24a84b0351203225efc"></a><!-- doxytag: member="CC3MeshNode::vertexNormalAt:" ref="abe085d7a7651f24a84b0351203225efc" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3MeshNode::vertexNormalAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the normal element at the specified index from the vertex data. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="acff9e22dd21e4a1fc10cc8fd1227bb7f"></a><!-- doxytag: member="CC3MeshNode::vertexTexCoord2FAt:" ref="acff9e22dd21e4a1fc10cc8fd1227bb7f" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTex2F CC3MeshNode::vertexTexCoord2FAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the texture coordinate element at the specified index from the vertex data at the commonly used texture unit zero. </p>
<p>This is a convenience method that is equivalent to invoking the vertexTexCoord2FForTextureUnit:at: method, with zero as the texture unit index.</p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a337da566060400aacd1015d1831a3a87"></a><!-- doxytag: member="CC3MeshNode::vertexTexCoord2FAt:forTextureUnit:" ref="a337da566060400aacd1015d1831a3a87" args="(GLsizei index,[forTextureUnit] GLuint DEPRECATED_ATTRIBUTE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTex2F CC3MeshNode::vertexTexCoord2FAt:forTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>DEPRECATED_ATTRIBUTE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use the vertexTexCoord2FForTextureUnit:at: method instead, </dd></dl>

</div>
</div>
<a class="anchor" id="ad0268f81b9c11ee435683f6b2e70da79"></a><!-- doxytag: member="CC3MeshNode::vertexTexCoord2FForTextureUnit:at:" ref="ad0268f81b9c11ee435683f6b2e70da79" args="(GLuint texUnit,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTex2F CC3MeshNode::vertexTexCoord2FForTextureUnit:at: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the texture coordinate element at the specified index from the vertex data at the specified texture unit index. </p>
<p>The index refers to vertices, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ab4521a811bbadf0fc5077d70e2b696f4"></a><!-- doxytag: member="CC3MeshNode::depthFunction" ref="ab4521a811bbadf0fc5077d70e2b696f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum <a class="el" href="interface_c_c3_mesh_node.html#ab4521a811bbadf0fc5077d70e2b696f4">CC3MeshNode::depthFunction</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The depth function used by the GL engine when comparing the Z-distance of this node against previously drawn content. </p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>This property must be set to one of the following values:</p>
<ul>
<li>GL_LESS - the content of this node will be drawn if it is closer to the camera than previously drawn content.</li>
<li>GL_LEQUAL - the content of this node will be drawn if it is at least as close to the camera as previously drawn content.</li>
<li>GL_EQUAL - the content of this node will be drawn if it is exactly as close to the camera as previously drawn content.</li>
<li>GL_GEQUAL - the content of this node will be drawn if it is at least as far away from the camera as previously drawn content.</li>
<li>GL_GREATER - the content of this node will be drawn if it is farther away from the camera than previously drawn content.</li>
<li>GL_NOTEQUAL - the content of this node will be drawn if it is not exactly as close to the camera as previously drawn content.</li>
<li>GL_ALWAYS - the content of this node will always be drawn</li>
<li>GL_NEVER - the content of this node will not be drawn</li>
</ul>
<p>The initial value of this property is GL_LEQUAL. In most cases, to draw an accurate scene, this value is the most suitable. However, some special cases, including some particle emitters, may benefit from the use of one of the other depth functions.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns the value of this property from the first descendant mesh node, or will return GL_NEVER if no mesh node are found in the descendants of this node. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a8b5a7a014ef8c5297a0d2a5a74442316">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a99927d686b53cd38f0adfff1dd694083"></a><!-- doxytag: member="CC3MeshNode::normalScalingMethod" ref="a99927d686b53cd38f0adfff1dd694083" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_c3_node_8h.html#a4bed21b96ced6e7ff2d912800ab99bba">CC3NormalScaling</a> <a class="el" href="interface_c_c3_mesh_node.html#a99927d686b53cd38f0adfff1dd694083">CC3MeshNode::normalScalingMethod</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specifies the method to be used to scale vertex normals after they have been transformed during vertex drawing. </p>
<p>Normal vectors should have a unit length. Since normals are vectors in the local coordinate system of the node, they are transformed into world and eye coordinates during drawing.</p>
<p>During transformation, there are several factors that might distort the normal vector:</p>
<ul>
<li>If the normals started out not being of unit length, they will generally be transformed into vectors that are not of unit length.</li>
<li>If the transforms are not rigid, and include scaling, even normals that have unit length in object space will end up shorter or longer than unit length in eye space.</li>
<li>If the transform scaling is not uniform, the normals will shear, and end up shorter or longer than unit length.</li>
</ul>
<p>Normals that are not of unit length, or are sheared, will cause portions of the objects to appear lighter or darker after transformation, or will cause specular highlights to actually be dark, distorting the overall look of the material covering the mesh.</p>
<p>The GL engine can be instructed to compensate for these transforms by setting this property as follows:</p>
<ul>
<li>kCC3NormalScalingNone: No compensating scaling is performed on the normals after they have been transformed. This has the highest performance, but will not adjust the normals if they have been scaled. Use this option if you know that the normals will not be significantly scaled during transformation.</li>
</ul>
<ul>
<li>kCC3NormalScalingRescale: Uses the modelview matrix to scale all normals by the inverse of the node's overall scaling. This does have a processing cost, but is much faster than using kCC3NormalScalingNormalize. However, it is not as accurate if significantly non-uniform scaling has been applied to the node.</li>
</ul>
<ul>
<li>kCC3NormalScalingNormalize: Normalizes each norml vector independently. This is the most accurate method, but is also, by far, the most computationally expensive. Use this method only if selecting one of the other options does not give you the results that you expect.</li>
</ul>
<ul>
<li>kCC3NormalScalingAutomatic: Chooses the most appropriate method based on the scaling that has been applied to the node. If no scaling has been applied to the node, kCC3NormalScalingNone will be used. If only uniform scaling has been applied to the node, kCC3NormalScalingRescale will be used. If non-uniform scaling has been applied to the node, then kCC3NormalScalingNormalize will be used.</li>
</ul>
<p>The initial value of this property is kCC3NormalScalingAutomatic. You can generally leave this property at this default value unless you are not getting the results that you expect.</p>
<p>Setting this property sets the corresponding property in all descendant nodes, and affects the processing of normals in all vertex meshes contained in all descendant nodes.</p>
<p>Querying this property returns the value of this property from the first descendant mesh node, or will return kCC3NormalScalingNone if no mesh node are found in the descendants of this node. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a49f80cf856a152e5c5a9f08efe15b0b1">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a0a2dcf49d0997083a838a366d7a026d1"></a><!-- doxytag: member="CC3MeshNode::shouldCullBackFaces" ref="a0a2dcf49d0997083a838a366d7a026d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_mesh_node.html#a0a2dcf49d0997083a838a366d7a026d1">CC3MeshNode::shouldCullBackFaces</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the back faces should be culled on the meshes contained in descendants of this node. </p>
<p>The initial value is YES, indicating that back faces will not be displayed. You can set this property to NO if you have reason to display the back faces of the mesh (for instance, if you have a rectangular plane and you want to show both sides of it).</p>
<p>Since the normal of the face points out the front face, back faces interact with light the same way the front faces do, and will appear luminated by light that falls on the front face, much like a stained-glass window. This may not be the affect that you are after, and for some lighting conditions, instead of disabling back face culling, you might consider creating a second textured front face, placed back-to-back with the original front face.</p>
<p>Be aware that culling improves performance, so this property should be set to NO only when specifically needed for visual effect, and only on the meshes that need it.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns NO if any of the descendant mesh nodes have this property set to NO. Initially, and in most cases, all mesh nodes have this property set to YES.</p>
<p>For more information about this use of this property, see the class notes for the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> class. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a0a02ef76817887e925c9dc04c0e9826e">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="aba9c33476284294c99a718a0259c4c9a"></a><!-- doxytag: member="CC3MeshNode::shouldCullFrontFaces" ref="aba9c33476284294c99a718a0259c4c9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_mesh_node.html#aba9c33476284294c99a718a0259c4c9a">CC3MeshNode::shouldCullFrontFaces</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the front faces should be culled on the meshes contained in descendants of this node. </p>
<p>The initial value is NO. Normally, you should leave this property with the initial value, unless you have a specific need not to display the front faces.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES. Initially, and in most cases, all mesh nodes have this property set to NO.</p>
<p>For more information about this use of this property, see the class notes for the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> class. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a890865bb4d5cf77011e4e3de7f3d1e17">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a36ab2366c2f8cb77f6898c7a6a65f682"></a><!-- doxytag: member="CC3MeshNode::shouldDisableDepthMask" ref="a36ab2366c2f8cb77f6898c7a6a65f682" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_mesh_node.html#a36ab2366c2f8cb77f6898c7a6a65f682">CC3MeshNode::shouldDisableDepthMask</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance will disable the GL depth mask while drawing the content of this node. </p>
<p>When the depth mask is disabled, drawing activity will not write to the depth buffer.</p>
<p>If this property is set to NO, the Z-distance of this node will be compared against previously drawn content, and the drawing of this node will update the depth buffer, so that subsequent drawing will take into consideration the Z-distance of this node.</p>
<p>If this property is set to YES, the Z-distance of this node will still be compared against previously drawn content, but the drawing of this node will NOT update the depth buffer, and subsequent drawing will NOT take into consideration the Z-distance of this node.</p>
<p>This property only has effect if the shouldDisableDepthTest property is set to NO.</p>
<p>In most cases, to draw an accurate scene, we want depth testing to be performed at all times, and this property is usually set to NO. However, there are some occasions where it is useful to disable writing to the depth buffer during the drawing of a node. One notable situation is with particle systems, where temporarily disabling the depth mask will avoid Z-fighting between individual particles.</p>
<p>The initial value of this property is NO, indicating that the GL depth mask will not be disabled during the drawing of this node, and the depth buffer will be updated during the drawing of this node.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a26a30412b0a1de08a1baae7db25d0790">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a8710a0a76335e1cffa53c0304214a036"></a><!-- doxytag: member="CC3MeshNode::shouldDisableDepthTest" ref="a8710a0a76335e1cffa53c0304214a036" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_mesh_node.html#a8710a0a76335e1cffa53c0304214a036">CC3MeshNode::shouldDisableDepthTest</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance will disable the GL depth test while drawing the content of this node. </p>
<p>When the depth test is disabled, the Z-distance of this node will not be compared against previously drawn content, and drawing activity will not write to the depth buffer.</p>
<p>If this property is set to NO, the Z-distance of this node will be compared against previously drawn content, and the drawing of this node will update the depth buffer, so that subsequent drawing will take into consideration the Z-distance of this node.</p>
<p>If this property is set to YES, the Z-distance of this node will not be compared against previously drawn content and this node will be drawn over all previously drawn content. In addition, the drawing of this node will not update the depth buffer, with the result that subsequent object drawing will not take into consideration the Z-distance of this node.</p>
<p>In most cases, to draw an accurate scene, we want depth testing to be performed at all times, and this property is usually set to NO. However, there are some occasions where it is useful to disable depth testing during the drawing of a node. One notable situation is with particle systems, where temporarily disabling depth testing may help avoid Z-fighting between individual particles.</p>
<p>The initial value of this property is NO, indicating that the GL depth tesing will not be disabled during the drawing of this node, and the depth buffer will be updated during the drawing of this node.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#ae14b782b005ee61d7c12a66669100a1d">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a4a416a1c347b2e7808aaae647a3d7ede"></a><!-- doxytag: member="CC3MeshNode::shouldUseClockwiseFrontFaceWinding" ref="a4a416a1c347b2e7808aaae647a3d7ede" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_mesh_node.html#a4a416a1c347b2e7808aaae647a3d7ede">CC3MeshNode::shouldUseClockwiseFrontFaceWinding</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the edge-widing algorithm used by the GL engine to determine which face of a triangle is the front face should use clockwise winding. </p>
<p>If this property is set to YES, the front face of all triangles in the mesh of this node will be determined using clockwise winding of the edges. If this property is set to NO, the front face of all triangles in the mesh of this node will be determined using counter-clockwise winding of the edges.</p>
<p>The initial value of this property is NO, indicating that the OpenGL-standard counter-clockwise winding will be used by the GL engine to determine the front face of all triangles in the mesh of this node. Unless you have a reason to change this value, you should leave it at the initial value.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns YES if any of the descendant mesh nodes have this property set to YES, otherwise returns NO. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a899c01b0e0a806669d7827112a275ddc">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="ae8856e39d188accad9ad49dbd40649f2"></a><!-- doxytag: member="CC3MeshNode::shouldUseSmoothShading" ref="ae8856e39d188accad9ad49dbd40649f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="interface_c_c3_mesh_node.html#ae8856e39d188accad9ad49dbd40649f2">CC3MeshNode::shouldUseSmoothShading</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the shading of the faces of the mesh of this node should be smoothly shaded, using color interpolation between vertices. </p>
<p>If this property is set to YES, the color of each pixel in any face in the mesh of this node will be interpolated from the colors of all three vertices of the face, using the distance of the pixel to each vertex as the means to interpolate. The result is a smooth gradient of color across the face.</p>
<p>If this property is set to NO, the color of all pixels in any face in the mesh of this node will be determined by the color at the third vertex of the face. All pixels in the face will be painted in the same color.</p>
<p>The initial value is YES. For realistic rendering, you should leave this property with the initial value, unless you have a specific need to render flat color across each face in the mesh, such as to deliberately create a cartoon-like effect on the model.</p>
<p>Setting this value sets the same property on all descendant nodes.</p>
<p>Querying this property returns NO if any of the descendant mesh nodes have this property set to NO. Initially, and in most cases, all mesh nodes have this property set to YES. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#adcf527d032102ac1750699662c0c753d">CC3Node</a>.</p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a9386e779eac298341f6516010931b514"></a><!-- doxytag: member="CC3MeshNode::ambientColor" ref="a9386e779eac298341f6516010931b514" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3MeshNode::ambientColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ambient color of the material of this mesh node. </p>
<p>Material color is initially set to kCC3DefaultMaterialColorAmbient. If this instance has no material, this property will return kCCC4FBlackTransparent.</p>
<p>The value of this property is also affected by changes to the color and opacity properties. See the notes for those properties for more information. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a87fc1dcd7533a6d9f29564116ab7d3fe">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a0014822499c656bc65edffcc1ddeb032"></a><!-- doxytag: member="CC3MeshNode::blendFunc" ref="a0014822499c656bc65edffcc1ddeb032" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccBlendFunc CC3MeshNode::blendFunc<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCBlendProtocol blendFunc property. </p>
<p>This is a convenience property that gets and sets both the sourceBlend and destinationBlend properties of the material used by this node using a single structure. Changes to this property is also passed along to any child nodes. Querying this property returns {GL_ONE, GL_ZERO} if this node has no material. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#af98fb62a333ea1cc0fdbe4d401c0e2aa">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a06c3e0690e2999a93919ba2d28e29193"></a><!-- doxytag: member="CC3MeshNode::color" ref="a06c3e0690e2999a93919ba2d28e29193" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor3B CC3MeshNode::color<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCRGBAProtocol color property. </p>
<p>Querying this property returns the RGB components of the material's diffuseColor property, or of this node's pureColor property if this node has no material. In either case, the RGB values are converted from the floating point range (0 to 1), to the byte range (0 to 255).</p>
<p>When setting this property, the RGB values are each converted to a floating point number between 0 and 1, and are set into both the ambientColor and diffuseColor properties of this node's material, and the pureColor property of this node. The alpha of each of those properties remains unchanged.</p>
<p>Setting this property also sets the same property on all descendant nodes. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a03aece3103f5751908dfda571a5a4145">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a4d20b4f99edba78e678636b6138497a2"></a><!-- doxytag: member="CC3MeshNode::DEPRECATED_ATTRIBUTE" ref="a4d20b4f99edba78e678636b6138497a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_mesh_model.html">CC3MeshModel</a>* meshModel CC3MeshNode::DEPRECATED_ATTRIBUTE<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd><a class="el" href="interface_c_c3_mesh_model.html" title="Deprecated CC3MeshModel renamed to CC3Mesh.">CC3MeshModel</a> renamed to <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a>.</dd></dl>
<p>Use mesh property instead. </p>

</div>
</div>
<a class="anchor" id="a1c4476ee10e9dad251c00b0723ef7ba7"></a><!-- doxytag: member="CC3MeshNode::diffuseColor" ref="a1c4476ee10e9dad251c00b0723ef7ba7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3MeshNode::diffuseColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The diffuse color of the material of this mesh node. </p>
<p>Material color is initially set to kCC3DefaultMaterialColorDiffuse. If this instance has no material, this property will return kCCC4FBlackTransparent.</p>
<p>The value of this property is also affected by changes to the color and opacity properties. See the notes for those properties for more information. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a0bb07b8079bf75af208434b5360cc58b">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a27945960af75a269569cb02f687e151b"></a><!-- doxytag: member="CC3MeshNode::emissionColor" ref="a27945960af75a269569cb02f687e151b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3MeshNode::emissionColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The emission color of the material of this mesh node. </p>
<p>Material color is initially set to kCC3DefaultMaterialColorEmission. If this instance has no material, this property will return kCCC4FBlackTransparent.</p>
<p>The value of this property is also affected by changes to the opacity property. See the notes for the opacity property for more information. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a821370544c7d36e7cbb742988b936102">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a09ac6d16d320cecc66c0917979a92b3e"></a><!-- doxytag: member="CC3MeshNode::globalLightLocation" ref="a09ac6d16d320cecc66c0917979a92b3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3MeshNode::globalLightLocation<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When this mesh node is textured with a DOT3 bump-map (normal map), this property indicates the location, in the global coordinate system, of the light that is illuminating the node. </p>
<p>This global light location is tranformed from a loction in the global coordinate system to a direction in the local coordinate system of this node. This local direction is then applied to the texture of this node, where it interacts with the normals stored in the bump-map texture to determine surface illumination.</p>
<p>This property only needs to be set, and will only have effect when set, when one of the textures of this node is configured as a bump-map. Set the value of this property to the globalLocation of the light source. Bump-map textures may interact with only one light source.</p>
<p>When setting this property, this implementation also sets the same property in all child nodes. When reading this property, this implementation returns a value if this node contains a texture configured for bump-mapping, or the value of the same property from the first descendant node that is a <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> and that contains a texture configured for bump-mapping. Otherwise, this implementation returns kCC3VectorZero. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a2fdfd0ca5824487179b86d45b868c78b">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="ac754a405d9012e05421e24989865f7c4"></a><!-- doxytag: member="CC3MeshNode::isOpaque" ref="ac754a405d9012e05421e24989865f7c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3MeshNode::isOpaque<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the material of this mesh node is opaque. </p>
<p>If this node has a material, returns the value of the same property on the material. If this node has no material, return YES if the alpha component of the pureColor property is 1.0, otherwise returns NO.</p>
<p>Setting this property sets the same property in the material and in all descendants, and sets the alpha component of the pureColor property to 1.0.</p>
<p>See the notes for this property on <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> for more information on how this property interacts with the other material properties.</p>
<p>Setting this property should be thought of as a convenient way to switch between the two most common types of blending combinations. For finer control of blending, set specific blending properties on the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance directly, and avoid making changes to this property. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#ac178e6f33f03b599753ac1692bcf3dce">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c0fcf674357d22301cc5402cb4d21f"></a><!-- doxytag: member="CC3MeshNode::material" ref="ad2c0fcf674357d22301cc5402cb4d21f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_material.html">CC3Material</a> * CC3MeshNode::material<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The material covering this mesh node. </p>

</div>
</div>
<a class="anchor" id="a0602b5efbec034a0385d306b549a183e"></a><!-- doxytag: member="CC3MeshNode::mesh" ref="a0602b5efbec034a0385d306b549a183e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_mesh.html">CC3Mesh</a> * CC3MeshNode::mesh<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The mesh that holds the vertex data for this mesh node. </p>
<p>When this property is set, if this node has a boundingVolume, it is forced to rebuild itself, otherwise, if this node does not have a boundingVolume, a default bounding volume is created from the mesh. </p>

</div>
</div>
<a class="anchor" id="af790e70c1f94c040dea7e7229c28b851"></a><!-- doxytag: member="CC3MeshNode::opacity" ref="af790e70c1f94c040dea7e7229c28b851" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLubyte CC3MeshNode::opacity<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCRGBAProtocol opacity property. </p>
<p>Querying this property returns the alpha component of the material's diffuseColor property, or of this node's pureColor property if this node has no material. In either case, the RGB values are converted from the floating point range (0 to 1), to the byte range (0 to 255).</p>
<p>When setting this property, the value is converted to a floating point number between 0 and 1, and is set into all of the ambientColor, diffuseColor, specularColor, and emissionColor properties of this node's material, and the pureColor property of this node The RGB components of each of those properties remains unchanged.</p>
<p>Setting this property also sets the same property on all descendant nodes.</p>
<p>See the notes for this property on <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> for more information on how this property interacts with the other material properties.</p>
<p>Setting this property should be thought of as a convenient way to switch between the two most common types of blending combinations. For finer control of blending, set specific blending properties on the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance directly, and avoid making changes to this property. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a7c97161a1d0bd50fb265bd390fab9247">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="a38e40a48403707d3934a935271ce8c98"></a><!-- doxytag: member="CC3MeshNode::podMaterialIndex" ref="a38e40a48403707d3934a935271ce8c98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>(PVRPOD)::podMaterialIndex<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The index of the material in the POD file used by this node. </p>

</div>
</div>
<a class="anchor" id="a0acd881192a53c06b30cab629a849832"></a><!-- doxytag: member="CC3MeshNode::pureColor" ref="a0acd881192a53c06b30cab629a849832" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3MeshNode::pureColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The pure, solid color used to paint the mesh if no material is established for this node. </p>
<p>This color is not not be affected by the lighting conditions. The mesh will always appear in the same pure, solid color, regardless of the lighting sources. </p>

</div>
</div>
<a class="anchor" id="ab3f2190eb12f133a7d2d35ba8173952d"></a><!-- doxytag: member="CC3MeshNode::shouldDrawLowAlpha" ref="ab3f2190eb12f133a7d2d35ba8173952d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3MeshNode::shouldDrawLowAlpha<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether alpha testing should be used to determine if pixels with lower alpha values should be drawn. </p>
<p>Setting or reading the value of this property will set or return the value of the same property on the material covering this mesh.</p>
<p>If the value of this property is set to YES, each pixel will be drawn regardless of the value of its alpha component. If the value of this property is set to NO, the value of the alpha component of each pixel will be compared against the value in the alphaTestReference property of the material, and only those pixel alpha values that are greater than that reference value will be drawn. You can set the value of the alphaTestReference property of the material to determine the cutoff level.</p>
<p>The initial value of this property is YES, indicating that pixels with lower alpha values will be drawn.</p>
<p>For most situations, alpha testing is not necessary, and you can leave the value of this property set to YES. Alpha testing can sometimes be useful when drawing overlapping objects that each contain transparency, and it is not possible to rely only on drawing order and depth testing to mediate whether a pixel should be drawn. </p>

</div>
</div>
<a class="anchor" id="a32c89a1b1bdb7ec9ebb2bbaafd5a53d9"></a><!-- doxytag: member="CC3MeshNode::shouldUseLighting" ref="a32c89a1b1bdb7ec9ebb2bbaafd5a53d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3MeshNode::shouldUseLighting<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this value is set to YES, current lighting conditions will be taken into consideration when drawing colors and textures, and the material ambientColor, diffuseColor, specularColor, emissionColor, and shininess properties will have effect. </p>
<p>If this value is set to NO, lighting conditions will be ignored when drawing colors and textures, and the material emissionColor will be applied to the mesh surface without regard to lighting. Blending will still occur, but the other material aspects, including ambientColor, diffuseColor, specularColor, and shininess will be ignored. This is useful for a cartoon effect, where you want a pure color, or the natural colors of the texture, to be included in blending calculations, without having to arrange lighting, or if you want those colors to be displayed in their natural values despite current lighting conditions.</p>
<p>Setting the value of this property sets the same property in the contained material. Reading the value of this property returns the value of the same property in the contained material.</p>
<p>The initial value of this property is YES. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a3cbea6e6582b701b52b7a64d37ce6aa6">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="add17365ad2a6a86b4a75b63b12b8bcfc"></a><!-- doxytag: member="CC3MeshNode::specularColor" ref="add17365ad2a6a86b4a75b63b12b8bcfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3MeshNode::specularColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The specular color of the material of this mesh node. </p>
<p>Material color is initially set to kCC3DefaultMaterialColorSpecular. If this instance has no material, this property will return kCCC4FBlackTransparent.</p>
<p>The value of this property is also affected by changes to the opacity property. See the notes for the opacity property for more information. </p>

<p>Implements <a class="el" href="interface_c_c3_node.html#a12ec9c3ae66471ffdc3eec5612cf4b4e">CC3Node</a>.</p>

</div>
</div>
<a class="anchor" id="abbfb00b5c05dee12ae7dec23c79f4829"></a><!-- doxytag: member="CC3MeshNode::texture" ref="abbfb00b5c05dee12ae7dec23c79f4829" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a>* CC3MeshNode::texture<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When the material covering this mesh contains a single texture, this property references that texture. </p>
<p>When multi-texturing is in use, and the material holds more than one texture, this property references the texture that will be processed by GL texture unit zero.</p>
<p>This property is a convenience. It simply delegates to the same property on the material covering this mesh node.</p>
<p>When setting this property, if a material does not yet exist in this mesh node, a new material will be created and the texture will be attached to it. </p>

</div>
</div>
<a class="anchor" id="abe70cbf2b2075f510361eaa7441f0f7e"></a><!-- doxytag: member="CC3MeshNode::textureRectangle" ref="abe70cbf2b2075f510361eaa7441f0f7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CGRect CC3MeshNode::textureRectangle<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the rectangular area of the textures, for all texture units, that should be mapped to the mesh used by this node. </p>
<p>This property facilitates the use of sprite-sheets, where the mesh is covered by a small fraction of a larger texture. This technique has many uses, including animating a texture onto a mesh, where each section of the full texture is really a different frame of a texture animation, or simply loading one larger texture and using parts of it to texture many different meshes.</p>
<p>The dimensions of this rectangle are taken as fractional portions of the full area of the texture. Therefore, a rectangle with zero origin, and unit size ((0.0, 0.0), (1.0, 1.0)) indicates that the mesh should be covered with the complete texture.</p>
<p>A rectangle of smaller size, and/or a non-zero origin, indicates that the mesh should be covered by a fractional area of the texture. For example, a rectangular value for this property with origin at (0.5, 0.5), and size of (0.5, 0.5) indicates that only the top-right quarter of the texture will be used to cover this mesh.</p>
<p>The bounds of the texture rectangle must fit within a unit rectangle. Both the bottom-left and top-right corners must lie between zero and one in both the X and Y directions.</p>
<p>The dimensions of the rectangle in this property are independent of adjustments made by the alignTextures and alignInvertedTextures methods. A unit rectangle value for this property will automatically take into consideration the adjustment made to the mesh by those methods, and will display only the part of the texture defined by them. Rectangular values for this property that are smaller than the unit rectangle will be relative to the displayable area defined by alignTextures and alignInvertedTextures.</p>
<p>As an example, if the alignWithTexturesIn: method was used to limit the mesh to using only 80% of the texture (perhaps when using a non-POT texture), and this property was set to a rectangle with origin at (0.5, 0.0) and size (0.5, 0.5), the mesh will be covered by the bottom-right quarter of the usable 80% of the overall texture.</p>
<p>This property affects all texture units used by this mesh, to query or change this property for a single texture unit only, use the textureRectangleForTextureUnit: and setTextureRectangle:forTextureUnit: methods.</p>
<p>The initial value of this property is a rectangle with origin at zero, and unit size, indicating that the mesh will be covered with the complete usable area of the texture. </p>

</div>
</div>
<a class="anchor" id="a7b583556730377b5e838e0dfcfb3d8ac"></a><!-- doxytag: member="CC3MeshNode::vertexCount" ref="a7b583556730377b5e838e0dfcfb3d8ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei CC3MeshNode::vertexCount<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of vertices in this mesh. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_mesh_node_8h.html">CC3MeshNode.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_mesh_node.html">CC3MeshNode</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:08 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
