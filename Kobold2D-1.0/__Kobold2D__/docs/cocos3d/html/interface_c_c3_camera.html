<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3Camera Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_camera.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3Camera Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3Camera" --><!-- doxytag: inherits="CC3TargettingNode" -->
<p><code>#include &lt;CC3Camera.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Camera:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_camera__inherit__graph.png" border="0" usemap="#_c_c3_camera_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_camera_inherit__map" id="_c_c3_camera_inherit__map">
<area shape="rect" id="node9" href="interface_c_c3_p_o_d_camera.html" title="A CC3Camera whose content originates from POD resource data." alt="" coords="12,315,125,343"/><area shape="rect" id="node2" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction..." alt="" coords="4,161,133,189"/><area shape="rect" id="node4" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="32,83,105,111"/><area shape="rect" id="node6" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="16,6,123,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3Camera:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_camera__coll__graph.png" border="0" usemap="#_c_c3_camera_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_camera_coll__map" id="_c_c3_camera_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction..." alt="" coords="58,179,187,207"/><area shape="rect" id="node4" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="85,99,159,127"/><area shape="rect" id="node6" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/><area shape="rect" id="node8" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array." alt="" coords="137,6,236,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_camera-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#aa8bff98eb09eb858c676ee3e6aabaf54">buildPerspective</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a2b07b9bbc87b31f35a0e610c7ef18f4e">calculateLocationToShowAllOf:fromDirection:withPadding:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection,[withPadding] GLfloat padding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a384baf192b9c79660eea8d71a2e8d33f">close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a9fd0add570884eb4bd75b7b764d335bd">markProjectionDirty</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a99652a747327243106680e854f065533">moveToShowAllOf:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a44bcbf5a0d6d319a26a5ab886c34e9bf">moveToShowAllOf:fromDirection:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a5035d4372a834ddfe78bfb03562c74e3">moveToShowAllOf:fromDirection:withPadding:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection,[withPadding] GLfloat padding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#ae1a7e835df13bcd22176fcb2054254f5">moveToShowAllOf:withPadding:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[withPadding] GLfloat padding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a39f017f94c2319f2eb935afb3b88c26a">moveWithDuration:toShowAllOf:</a> (ccTime t,[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#abb8480e6b0572d9f95cfd031edc434f5">moveWithDuration:toShowAllOf:fromDirection:</a> (ccTime t,[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a564dffa3635e2c663ad543eb8c50ab0a">moveWithDuration:toShowAllOf:fromDirection:withPadding:</a> (ccTime t,[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection,[withPadding] GLfloat padding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a73b585ab26e6b59228e08acfcb3658f8">moveWithDuration:toShowAllOf:withPadding:</a> (ccTime t,[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode,[withPadding] GLfloat padding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#afee86c1a0699c4b7ff4c9e37e37a2c5b">open</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a1899ddd174df5fc78f1bbb4b82b265b7">projectLocation:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> a3DLocation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#adcc121548cd5bde83bc81a56e75f0d38">projectNode:</a> (<a class="el" href="interface_c_c3_node.html">CC3Node</a> *aNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_ray.html">CC3Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a9ed4facde99ae62c2063740798e17834">unprojectPoint:</a> (CGPoint cc2Point)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a426694924d2c5f76c304b7f8717e9a25">unprojectPoint:ontoPlane:</a> (CGPoint cc2Point,[ontoPlane] <a class="el" href="struct_c_c3_plane.html">CC3Plane</a> plane)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5f16d1ce6dd639428068e96f6c37e66"></a><!-- doxytag: member="CC3Camera::isProjectionDirty" ref="ae5f16d1ce6dd639428068e96f6c37e66" args="" -->
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>isProjectionDirty</b></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#ae4471dee865493cfe3be7292c3b18c51">farClippingPlane</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#ad9f808685004fa2c48af48240d351e49">fieldOfView</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_frustum.html">CC3Frustum</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a76546e898f27e8fc8665b0b02c2d33cc">frustum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a89c14ac272e49437406aa9b382f7b5bb">isUsingParallelProjection</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a9c696571b5d0575727d615bf1a07ed22">modelviewMatrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a6f7c7ea7029e0cc2b68570e09d821893">nearClippingPlane</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_camera.html#a9c1f626dc55792105895cd4a91c79641">projectionMatrix</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> represents the camera viewing the 3D world. </p>
<p><a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> is a type of <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a>, and can therefore participate in a structural node assembly. An instance can be the child of another node, and the camera itself can have child nodes. For example, a camera can be mounted on a boom object or truck, and will move along with the parent node. Or the camera node itself might have a light node attached as a child, so that the light will move along with the camera, and point where the camera points.</p>
<p>However, when adding a camera to an assembly of nodes, be aware of whether the parent nodes use scaling. To construct the modelviewMatrix, the camera makes heavy use of matrix inversion of the cummulative transform matrix of the camera's transforms and the transforms of all its ancestors. If scaling has not been added to any ancestor nodes, the cummulative transform will be a Rigid transform. Inverting a Rigid transform matrix is much, much faster (orders of magnitude) than inverting a matrix that contains scaling and is therefore not rigid. If possible, try to avoid applying scaling to the ancestor nodes of this camera.</p>
<p><a class="el" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world.">CC3Camera</a> is also a type of <a class="el" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction...">CC3TargettingNode</a>, and can be pointed in a particular direction, or can be made to track a target node as that node moves, or the camera moves.</p>
<p>The camera can be configured for either perspective or parallel projection, using the isUsingParallelProjection property. By default, the camera will use perspective projection.</p>
<p>You can use the projectLocation: and projectNode: methods to project global locations within the 3D world into 2D view coordinates, indicating where on the screen a 3D object appears.</p>
<p>You can use the unprojectPoint: and unprojectPoint:ontoPlane: methods to project a 2D screen position into either a ray (a line) in the 3D world, or into a specific intersection location on a 3D plane.</p>
<p>You can use the moveToShowAllOf:... or moveWithDuration:toShowAllOf: family of methods to have the camera automatically focus on, and display all of, a particular node, or even the whole world itself.</p>
<p>Scaling a camera is a null operation because it scales everything, including the size of objects, but also the distance from the camera to those objects. The effects cancel out, and visually it appears that nothing has changed.</p>
<p>Therefore, for cameras, the scale and uniformScale properties are not applied to the transform matrix. Instead, the uniformScale property acts as a zoom factor (as if the camera lens is zoomed in or out), and influences the fieldOfView property accordingly. See the description of the fieldOfView property for more information about zooming.</p>
<p>If you find that objects in the periphery of your view appear elongated, you can adjust the fieldOfView and/or uniformScale properties to reduce this "fish-eye" effect. See the notes of the fieldOfView property for more on this. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa8bff98eb09eb858c676ee3e6aabaf54"></a><!-- doxytag: member="CC3Camera::buildPerspective" ref="aa8bff98eb09eb858c676ee3e6aabaf54" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::buildPerspective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the transformMatrix and modelviewMatrix if the target has moved, builds the projectionMatrix if needed, and updates the frustum if needed. </p>
<p>This method is invoked automatically from the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> after all updates have been made to the models in the 3D world. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a2b07b9bbc87b31f35a0e610c7ef18f4e"></a><!-- doxytag: member="CC3Camera::calculateLocationToShowAllOf:fromDirection:withPadding:" ref="a2b07b9bbc87b31f35a0e610c7ef18f4e" args="(CC3Node *aNode,[fromDirection] CC3Vector aDirection,[withPadding] GLfloat padding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Camera::calculateLocationToShowAllOf:fromDirection:withPadding: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withPadding] GLfloat&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates and returns where to position this camera along a line extending in the specified direction from the center of the specified node, so that the camera will show the entire content of the node, including any descendant nodes. </p>
<p>The entire node can then be shown by positioning the camera at the returned location and setting the forwardDirection of the camera to the negated specified direction.</p>
<p>The padding argument indicates the empty-space padding to add around the bounding box of the node when it is framed in the camera. This value is expressed as a fraction of the size of the bounding box of the node. For example, if the padding value is set to 0.1, then this method will locate the camera so that there will be 10% empty space around the node when it is framed by the camera. A negative padding value will cause the node to expand to more fully fill the camera frame, or even expand beyond it.</p>
<p>By setting <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> as the specified node, you can use this method to determine where to position the camera in order to show the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="a384baf192b9c79660eea8d71a2e8d33f"></a><!-- doxytag: member="CC3Camera::close" ref="a384baf192b9c79660eea8d71a2e8d33f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes the camera for drawing operations. </p>
<p>This method is called automatically by the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> at the end of each frame drawing cycle. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a9fd0add570884eb4bd75b7b764d335bd"></a><!-- doxytag: member="CC3Camera::markProjectionDirty" ref="a9fd0add570884eb4bd75b7b764d335bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::markProjectionDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that the projection matrix is dirty and needs to be recalculated. </p>
<p>This method is invoked automatically as needed. Usually the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a99652a747327243106680e854f065533"></a><!-- doxytag: member="CC3Camera::moveToShowAllOf:" ref="a99652a747327243106680e854f065533" args="(CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveToShowAllOf: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line between the center of the specified node and this camera, so that the camera will show the entire content of the node, including any descendant nodes, with minimal padding. </p>
<p>The camera will point back towards the node along the line between itself and the center of the node.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="a44bcbf5a0d6d319a26a5ab886c34e9bf"></a><!-- doxytag: member="CC3Camera::moveToShowAllOf:fromDirection:" ref="a44bcbf5a0d6d319a26a5ab886c34e9bf" args="(CC3Node *aNode,[fromDirection] CC3Vector aDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveToShowAllOf:fromDirection: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line extending in the specified direction from the center of the specified node, so that the camera will show the entire content of the node, including any descendant nodes, with minimal padding. </p>
<p>The camera will point back towards the center of the node along the specified direction.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="a5035d4372a834ddfe78bfb03562c74e3"></a><!-- doxytag: member="CC3Camera::moveToShowAllOf:fromDirection:withPadding:" ref="a5035d4372a834ddfe78bfb03562c74e3" args="(CC3Node *aNode,[fromDirection] CC3Vector aDirection,[withPadding] GLfloat padding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveToShowAllOf:fromDirection:withPadding: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withPadding] GLfloat&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line extending in the specified direction from the center of the specified node, so that the camera will show the entire content of the node, including any descendant nodes. </p>
<p>The camera will point back towards the center of the node along the specified direction.</p>
<p>The padding argument indicates the empty-space padding to add around the bounding box of the node when it is framed in the camera. This value is expressed as a fraction of the size of the bounding box of the node. For example, if the padding value is set to 0.1, then this method will locate the camera so that there will be 10% empty space around the node when it is framed by the camera. A negative padding value will cause the node to expand to more fully fill the camera frame, or even expand beyond it.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="ae1a7e835df13bcd22176fcb2054254f5"></a><!-- doxytag: member="CC3Camera::moveToShowAllOf:withPadding:" ref="ae1a7e835df13bcd22176fcb2054254f5" args="(CC3Node *aNode,[withPadding] GLfloat padding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveToShowAllOf:withPadding: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withPadding] GLfloat&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line between the center of the specified node and this camera, so that the camera will show the entire content of the node, including any descendant nodes. </p>
<p>The camera will point back towards the node along the line between itself and the center of the node.</p>
<p>The padding argument indicates the empty-space padding to add around the bounding box of the node when it is framed in the camera. This value is expressed as a fraction of the size of the bounding box of the node. For example, if the padding value is set to 0.1, then this method will locate the camera so that there will be 10% empty space around the node when it is framed by the camera. A negative padding value will cause the node to expand to more fully fill the camera frame, or even expand beyond it.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="a39f017f94c2319f2eb935afb3b88c26a"></a><!-- doxytag: member="CC3Camera::moveWithDuration:toShowAllOf:" ref="a39f017f94c2319f2eb935afb3b88c26a" args="(ccTime t,[toShowAllOf] CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveWithDuration:toShowAllOf: </td>
          <td>(</td>
          <td class="paramtype">ccTime&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line between the center of the specified node and this camera, so that the camera will show the entire content of the node, including any descendant nodes, with minimal padding. </p>
<p>The camera will point back towards the node along the line between itself and the center of the node.</p>
<p>The camera's movement will take the specified amount of time, starting at its current location and orientation, and ending at the calculated location and oriented to point back towards the center of the node.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="abb8480e6b0572d9f95cfd031edc434f5"></a><!-- doxytag: member="CC3Camera::moveWithDuration:toShowAllOf:fromDirection:" ref="abb8480e6b0572d9f95cfd031edc434f5" args="(ccTime t,[toShowAllOf] CC3Node *aNode,[fromDirection] CC3Vector aDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveWithDuration:toShowAllOf:fromDirection: </td>
          <td>(</td>
          <td class="paramtype">ccTime&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line extending in the specified direction from the center of the specified node, so that the camera will show the entire content of the node, including any descendant nodes. </p>
<p>The camera will point back towards the center of the node along the specified direction.</p>
<p>The camera's movement will take the specified amount of time, starting at its current location and orientation, and ending at the calculated location and oriented to point back towards the center of the node.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="a564dffa3635e2c663ad543eb8c50ab0a"></a><!-- doxytag: member="CC3Camera::moveWithDuration:toShowAllOf:fromDirection:withPadding:" ref="a564dffa3635e2c663ad543eb8c50ab0a" args="(ccTime t,[toShowAllOf] CC3Node *aNode,[fromDirection] CC3Vector aDirection,[withPadding] GLfloat padding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveWithDuration:toShowAllOf:fromDirection:withPadding: </td>
          <td>(</td>
          <td class="paramtype">ccTime&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromDirection] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withPadding] GLfloat&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line extending in the specified direction from the center of the specified node, so that the camera will show the entire content of the node, including any descendant nodes, with minimal padding. </p>
<p>The camera will point back towards the center of the node along the specified direction.</p>
<p>The camera's movement will take the specified amount of time, starting at its current location and orientation, and ending at the calculated location and oriented to point back towards the center of the node.</p>
<p>The padding argument indicates the empty-space padding to add around the bounding box of the node when it is framed in the camera. This value is expressed as a fraction of the size of the bounding box of the node. For example, if the padding value is set to 0.1, then this method will locate the camera so that there will be 10% empty space around the node when it is framed by the camera. A negative padding value will cause the node to expand to more fully fill the camera frame, or even expand beyond it.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="a73b585ab26e6b59228e08acfcb3658f8"></a><!-- doxytag: member="CC3Camera::moveWithDuration:toShowAllOf:withPadding:" ref="a73b585ab26e6b59228e08acfcb3658f8" args="(ccTime t,[toShowAllOf] CC3Node *aNode,[withPadding] GLfloat padding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::moveWithDuration:toShowAllOf:withPadding: </td>
          <td>(</td>
          <td class="paramtype">ccTime&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[toShowAllOf] <a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withPadding] GLfloat&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves this camera to a location along a line between the center of the specified node and this camera, so that the camera will show the entire content of the node, including any descendant nodes. </p>
<p>The camera will point back towards the node along the line between itself and the center of the node.</p>
<p>The camera's movement will take the specified amount of time, starting at its current location and orientation, and ending at the calculated location and oriented to point back towards the center of the node.</p>
<p>The padding argument indicates the empty-space padding to add around the bounding box of the node when it is framed in the camera. This value is expressed as a fraction of the size of the bounding box of the node. For example, if the padding value is set to 0.1, then this method will locate the camera so that there will be 10% empty space around the node when it is framed by the camera. A negative padding value will cause the node to expand to more fully fill the camera frame, or even expand beyond it.</p>
<p>The specified node may be the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, in which case, the camera will be located to display the entire scene.</p>
<p>This method can be useful during development to troubleshoot scene display issues.</p>
<p>Since the camera points to the center of the node, when displayed, the node may not extend to both sides (or top &amp; bottom) of the scene equally, due to perspective. In addition, in some cases, if the bounds of the node are fluid because of movement, or billboards that rotate as the camera moves into position, one or more corners of the node may extend slightly out of the camera's view.</p>
<p>This method requires that the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> is attached to a <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a> that has a valid contentSize. This is necessary so that the frustum of the camera has been set from the contentSize of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>. </p>

</div>
</div>
<a class="anchor" id="afee86c1a0699c4b7ff4c9e37e37a2c5b"></a><!-- doxytag: member="CC3Camera::open" ref="afee86c1a0699c4b7ff4c9e37e37a2c5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Camera::open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens the camera for drawing operations. </p>
<p>This method is called automatically by the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> at the beginning of each frame drawing cycle. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a1899ddd174df5fc78f1bbb4b82b265b7"></a><!-- doxytag: member="CC3Camera::projectLocation:" ref="a1899ddd174df5fc78f1bbb4b82b265b7" args="(CC3Vector a3DLocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Camera::projectLocation: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>a3DLocation</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects the specified global 3D world location onto a 2D position in the viewport coordinate space, indicating where on the screen this 3D location will be seen. </p>
<p>The 2D position can be read from the X and Y components of the returned 3D location.</p>
<p>The specified location should be in global coordinates. If you are invoking this method to project the location of a <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a>, you should use the globalLocation property of the node. For objects that are moving, the updated globalLocation is available in the updateAfterTransform: method of your customized <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>.</p>
<p>The Z-component of the returned location indicates the distance from the camera to the specified location, with a positive value indicating that the specified location is in front of the camera, and a negative value indicating that the specified location is behind the camera.</p>
<p>Any 3D world location can be either in front of or behind the camera, and both cases will be projected onto the 2D space of the viewport plane. If you are only interested in the case when the specified location is in front of the camera (potentially visible to the camera), check that the Z-component of the returned location is positive.</p>
<p>This method takes into account the orientation of the device (portrait, landscape). </p>

</div>
</div>
<a class="anchor" id="adcc121548cd5bde83bc81a56e75f0d38"></a><!-- doxytag: member="CC3Camera::projectNode:" ref="adcc121548cd5bde83bc81a56e75f0d38" args="(CC3Node *aNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Camera::projectNode: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node.html">CC3Node</a> *&#160;</td>
          <td class="paramname"><em>aNode</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects the globalLocation of the specified node onto a 2D position in the viewport coordinate space, by invoking the projectLocation: method of this camera, passing the node's globalLocation. </p>
<p>See the notes of the projectLocation: method for more info about the content of the returned vector.</p>
<p>During any frame update, for objects that are moving, the updated globalLocation is available in the updateAfterTransform: method of your customized <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>.</p>
<p>In addition to returning the projected 2D location, this method also sets that value into the projectedLocation property of the node, for future access. </p>

</div>
</div>
<a class="anchor" id="a9ed4facde99ae62c2063740798e17834"></a><!-- doxytag: member="CC3Camera::unprojectPoint:" ref="a9ed4facde99ae62c2063740798e17834" args="(CGPoint cc2Point)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_ray.html">CC3Ray</a> CC3Camera::unprojectPoint: </td>
          <td>(</td>
          <td class="paramtype">CGPoint&#160;</td>
          <td class="paramname"><em>cc2Point</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects a 2D point, which is specified in the local coordinates of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, into a ray extending from the camera into the 3D world. </p>
<p>The returned ray contains a starting location and a direction.</p>
<p>If this camera is using perspective projection, the ray will start at the globalLocation of this camera and extend in a direction that passes through the specified point as it is mampped to a global location on the near clipping plane.</p>
<p>If this camera is using parallel projection, the ray will start at the specified point as it is mampped to a global location on the near clipping plane, and will be directed straight out from the camera, in the same direction as the camera's forwardDirection.</p>
<p>This method is the compliment to the projectLocation: method. You can use this method to map touch events to the 3D world space for activities such as dropping objects into the 3D world at a location under user finger touch control.</p>
<p>Any object that lies anywhere along the ray in 3D space will appear at the specified 2D point on the view. If you are trying to place an object at a 3D location corresponding to the 2D view point (eg- a finger touch point), you need to choose a specific location on the returned ray.</p>
<p>For example, you might determine where that ray intersects a particular plane, and place the object there. Or you might choose a location a certain distance from the camera, and place the object there. </p>

</div>
</div>
<a class="anchor" id="a426694924d2c5f76c304b7f8717e9a25"></a><!-- doxytag: member="CC3Camera::unprojectPoint:ontoPlane:" ref="a426694924d2c5f76c304b7f8717e9a25" args="(CGPoint cc2Point,[ontoPlane] CC3Plane plane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> CC3Camera::unprojectPoint:ontoPlane: </td>
          <td>(</td>
          <td class="paramtype">CGPoint&#160;</td>
          <td class="paramname"><em>cc2Point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[ontoPlane] <a class="el" href="struct_c_c3_plane.html">CC3Plane</a>&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Projects a 2D point, which is specified in the local coordinates of the <a class="el" href="interface_c_c3_layer.html" title="CC3Layer is a cocos2d CCLayer that supports full 3D rendering in combination with normal cocos2d 2D r...">CC3Layer</a>, to a 3D location on the specified plane. </p>
<p>You can use this method to map touch events to the plane in the 3D world space for activities such as dropping objects onto the plane at a location under user finger touch control.</p>
<p>The returned result is a 4D vector, where the x, y &amp; z components give the intersection location in 3D space, and the w component gives the distance from the camera to the intersection location. If the w component is negative, the intersection point is behind the camera, which is an indication that the camera is looking away from the plane.</p>
<p>If the ray from the camera through the specified point is parallel to the plane, no intersection occurs, and the returned 4D vector will be zeroed (equal to kCC3Vector4Zero).</p>
<p>You should therefore test the w component value to make sure it is positive and non-zero before proceeding with an activity such as dropping an object on the plane. If the plane has bounds in your world, you should also check whether the returned intersection is within those bounds. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="ae4471dee865493cfe3be7292c3b18c51"></a><!-- doxytag: member="CC3Camera::farClippingPlane" ref="ae4471dee865493cfe3be7292c3b18c51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Camera::farClippingPlane<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The distance from the camera to the clipping plane of the camera's frustrum that is farthest from the camera. </p>
<p>Initially set to kCC3DefaultFarClippingPlane. </p>

</div>
</div>
<a class="anchor" id="ad9f808685004fa2c48af48240d351e49"></a><!-- doxytag: member="CC3Camera::fieldOfView" ref="ad9f808685004fa2c48af48240d351e49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Camera::fieldOfView<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The nominal field of view of this camera, in degrees. </p>
<p>The initial value of this property is set to kCC3DefaultFieldOfView.</p>
<p>The effective field of view is influenced by the value of the uniformScale property, which, for cameras, acts as a zoom factor (as if the camera lens is zoomed in or out).</p>
<p>Once a nominal field of view has been set in this property, changing the scale or uniformScale properties will change the effective field of view accordingly (although the value of the fieldOfView property remains the same). Scales greater than one zoom in (objects appear larger), and scales between one and zero zoom out (objects appear smaller).</p>
<p>Like real-world cameras, larger values for fieldOfView can sometimes result in a "fish-eye" effect, where objects at the periphery of the view can appear elongated. To reduce this effect, lower the value of fieldOfView property, or increase the value of the uniformScale property. In doing so, you may need to move your camera further away from the scene, so that your view will continue to include the same objects. </p>

</div>
</div>
<a class="anchor" id="a76546e898f27e8fc8665b0b02c2d33cc"></a><!-- doxytag: member="CC3Camera::frustum" ref="a76546e898f27e8fc8665b0b02c2d33cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_frustum.html">CC3Frustum</a> * CC3Camera::frustum<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The frustum of the camera. </p>
<p>This is constructed automatically from the field of view and the clipping plane properties. Usually the application never has need to set this property directly. </p>

</div>
</div>
<a class="anchor" id="a89c14ac272e49437406aa9b382f7b5bb"></a><!-- doxytag: member="CC3Camera::isUsingParallelProjection" ref="a89c14ac272e49437406aa9b382f7b5bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Camera::isUsingParallelProjection<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this camera uses parallel projection. </p>
<p>If this value is set to NO, the projection matrix will be configured for perspective projection, which is typical for 3D worlds. If this value is set to YES, the projection matrix will be configured for parallel/isometric/orthographic projection.</p>
<p>The initial value of this property is NO, indicating that perspective projection will be used. </p>

</div>
</div>
<a class="anchor" id="a9c696571b5d0575727d615bf1a07ed22"></a><!-- doxytag: member="CC3Camera::modelviewMatrix" ref="a9c696571b5d0575727d615bf1a07ed22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> * CC3Camera::modelviewMatrix<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The matrix that holds the transform from model space to view space. </p>
<p>This matrix is distinct from the camera's transformMatrix, which, like that of all nodes, reflects the location, rotation and scale of the camera node in the 3D world space.</p>
<p>In contrast, the modelviewMatrix combines the inverse of the camera's transformMatrix (because any movement of the camera in world space has the opposite effect on the view), with the deviceRotationMatrix from the viewportManager of the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a>, to account for the impact of device orientation on the view. </p>

</div>
</div>
<a class="anchor" id="a6f7c7ea7029e0cc2b68570e09d821893"></a><!-- doxytag: member="CC3Camera::nearClippingPlane" ref="a6f7c7ea7029e0cc2b68570e09d821893" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Camera::nearClippingPlane<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The distance from the camera to the clipping plane of the camera's frustrum that is nearest to the camera. </p>
<p>Initially set to kCC3DefaultNearClippingPlane. </p>

</div>
</div>
<a class="anchor" id="a9c1f626dc55792105895cd4a91c79641"></a><!-- doxytag: member="CC3Camera::projectionMatrix" ref="a9c1f626dc55792105895cd4a91c79641" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a>* CC3Camera::projectionMatrix<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The projection matrix that takes the camera's modelview and projects it to the viewport. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_camera_8h.html">CC3Camera.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_camera.html">CC3Camera</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:07 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
