<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3Material Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_material.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3Material Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3Material" --><!-- doxytag: inherits="CC3Identifiable" -->
<p><code>#include &lt;CC3Material.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3Material:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_material__inherit__graph.png" border="0" usemap="#_c_c3_material_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_material_inherit__map" id="_c_c3_material_inherit__map">
<area shape="rect" id="node5" href="interface_c_c3_p_o_d_material.html" title="A CC3Material whose content originates from POD resource data." alt="" coords="5,161,123,189"/><area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="10,6,117,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3Material:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_material__coll__graph.png" border="0" usemap="#_c_c3_material_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_material_coll__map" id="_c_c3_material_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,6,112,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_material-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ae6ae5aa8d01f7ee4718764d825a8a45d">addTexture:</a> (<a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *aTexture)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a2cf7b4f23c2d86fde33e4054a0676894">drawWithVisitor:</a> (<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#aebd9670e3268299c4de24a5b7354d8ba">getTextureNamed:</a> (NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#aeef261147b2559fb4a282d8d71ff91fe">removeAllTextures</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#aca53fca1d8b7b40a937f6592ee668b3d">removeTexture:</a> (<a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *aTexture)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ace937216a1762002c5178e06173250de">setTexture:forTextureUnit:</a> (<a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *aTexture,[forTextureUnit] GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#aa32362b80cdbb948368a31a43fea7b7b">textureForTextureUnit:</a> (GLuint texUnit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#acc08aa7c02cd4b0e6c2025f95cb3ccdb">unbind</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccBlendFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a3a5a7844f2c06f38f0ec4b2d685d110d">defaultBlendFunc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ac7b3c9ac975cc5a4608c04b5890ecdec">material</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#acfbc5f5237b301ef0d6d2b61cd60e3b5">materialWithName:</a> (NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#aa362cc91fe53baf5d4b013d8a7f679ea">materialWithTag:</a> (GLuint aTag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ab395e6105d3b9c98f0d79283272408fc">materialWithTag:withName:</a> (GLuint aTag,[withName] NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a35731ec0fe4765bc1caa303b546195c9">resetSwitching</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a893183d57ebc88523759ae2d4d8efc69">setDefaultBlendFunc:</a> (ccBlendFunc aBlendFunc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a0dac6222240307b9265d8925e1a85ade">shiny</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a5d4c41233629f3940333122d2888c0ef">shinyWhite</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#acc08aa7c02cd4b0e6c2025f95cb3ccdb">unbind</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8db853713ad99b0f42e585bf065e756"></a><!-- doxytag: member="CC3Material::textureOverlays" ref="ae8db853713ad99b0f42e585bf065e756" args="" -->
CCArray *&#160;</td><td class="memItemRight" valign="bottom"><b>textureOverlays</b></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a9f7f6b0c7fbd2704bfe55d6811c461d2">alphaTestFunction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a76876ec68366bc046eb16dd3ae7eadfb">alphaTestReference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ab7846ec0d2ae3410fe84acc424ac5ceb">ambientColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccBlendFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#afe43489aee0ba07a343b235db8235b0a">blendFunc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor3B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a93431d16cadeed4a09e077e8f31b1d67">color</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ad0627fd29fa0f6382cfd0ca8df6398f9">destinationBlend</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a919a8cef853de8f25572cc5552c2a15c">diffuseColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ad55970a3cf2c59d4eceb284b130554d1">emissionColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#afd63ee59a294524a191376db150a5c02">hasBumpMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a4448709cd5fdec222a4a045e689727a5">isOpaque</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a0a38e6cb6cc7d9174be38db4ec37f90d">lightDirection</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLubyte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ad276a69a937c94607600c32c86ac80a6">opacity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#aa09ebe1c19c1ca60388f16657ebff415">shininess</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a46b21c61e69df46542568e3502a02b5f">shouldDrawLowAlpha</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a0ef77d2693dce9fbcff5495bcfa1f482">shouldUseLighting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#ad02c0e1797b037dd6c8af8707fd44889">sourceBlend</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccColor4F&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a150d153b442cd047327a63c840d19492">specularColor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a71569bea158450f0dbad1da10128c402">texture</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_material.html#a1bbe2552c8c7eaa364926306a4228b00">textureCount</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> manages information about a material that is used to cover one or more meshes. </p>
<p>This includes:</p>
<ul>
<li>color</li>
<li>texture</li>
<li>interaction with lighting</li>
<li>opacity, translucency, and blending with background objects</li>
</ul>
<p><a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> supports two levels of control for blending and translucency:</p>
<ul>
<li>To achieve the highest level of detail, accuracy and realism, you can individually set the explicit ambientColor, diffuseColor, specularColor, emissiveColor, shininess, sourceBlend, and destinationBlend properties. This suite of properties gives you the most complete control over the appearance of the material and its interaction with lighting conditions and the colors of the objects behind it, allowing you to generate rich visual effects. In addition, the isOpaque property sets the most commonly used blending combinations, and can be used to simplify your management of blending opaque or transparent materials, while still providing fine control of the ambient, diffuse and specular coloring.</li>
<li>At a simpler level, <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> also supports the cocos2d &lt;CCRGBAProtocol&gt; protocol. You can use the color and opacity properties of this protocol to set the most commonly used coloring and blending characteristics simply and easily. Setting the color property changes both the ambient and diffuse colors of the material in tandem. Setting the opacity property also automatically sets the source and destination blend functions to appropriate values for the opacity level. By using the color and opacity properties, you will not be able to achieve the complexity and realism that you can by using the more detailed properties, but you can achieve good effect with much less effort. And by supporting the &lt;CCRGBAProtocol&gt; protocol, the coloring and translucency of nodes with materials can be changed using standard cocos2d CCTint and CCFade actions, making it easier for you to add dynamic coloring effects to your nodes.</li>
</ul>
<p><a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> also supports alpha testing, where the alpha value of each pixel can be tested to determine whether or not it should be drawn. By default, alpha testing is disabled, but alpha testing can sometimes be useful when drawing overlapping objects each contain transparency and it is not possible to rely only on drawing order and depth testing to mediate whether a pixel should be drawn.</p>
<p>Textures are optional. In some cases, if simple solid coloring is to be used, the material may hold no texture at all. This solid coloring will still interact with lighting, creating a realistic surface.</p>
<p>More commonly, a material will hold a single instance of <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a> in the texture property to provide a simple single-texture surface. This is the most common application of textures to a material.</p>
<p>For more sophisticated surfaces, materials also support multi-texturing, where more than one instance of <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a> is added to the material using the addTexture: method. Using multi-texturing, these textures can be combined in flexible, customized fashion, permitting sophisticated surface effects.</p>
<p>With OpenGL, multi-texturing is processed by a chain of texture units. The material's first texture is processed by the first texture unit (texture unit zero), and subsequent textures held in the material are processed by subsequent texture units, in the order in which the textures were added to the material.</p>
<p>Each texture unit combines its texture with the output of the previous texture unit in the chain. Combining textures is quite flexible under OpenGL, and there are many ways that each texture can be combined with the output of the previous texture unit. The way that a particular texture combines with the previous textures is defined by an instance of <a class="el" href="interface_c_c3_texture_unit.html" title="CC3TextureUnit is used by CC3Texture to configure the GL texture unit to which the texture is being a...">CC3TextureUnit</a>, held in the textureUnit property of each texture that was added to the material.</p>
<p>For example, to configure a material for bump-mapping, add a texture that contains a normal vector at each pixel instead of a color, and set the textureUnit property of the texture to a <a class="el" href="interface_c_c3_bump_map_texture_unit.html" title="A texture unit configured for DOT3 bump-mapping.">CC3BumpMapTextureUnit</a>. You can then combine the output of this bump-mapping with an additional texture that contains the image that will be visible, to provide a detailed 3D bump-mapped surface. To do so, add that second texture to the material, with a texture unit that defines how that addtional texture is to be combined with the output of the bump-mapped texture.</p>
<p>The maximum number of texture units is platform dependent, and can be read from [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine].platform.maxTextureUnits.value. This effectively defines how many textures you can add to a material.</p>
<p>You'll notice that there are two ways to assign textures to a material: through the texture propety, and through the addTexture: method. The texture property exists for the common case where only one texture is attached to a material. The addTexture: method is used when more than one texture is to be added to the material. However, for the first texture, the two mechanisms are synonomous. The texture property corresponds to the first texture added using the addTexture: method, and for that first texture, you can use either the texture property or the addTexture: method. When multi-texturing, for consistency and simplicity, you would likely just use the addTexture: method for all textures added to the material, including the first texture.</p>
<p>Each <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instance references an instance of <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a>. Many <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> instances may reference the same instance of <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a>, allowing many objects to be covered by the same material.</p>
<p>When being drawn, the <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> invokes the draw method on the <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance prior to drawing the associated mesh.</p>
<p>When drawing the material to the GL engine, this class remembers which material was last drawn, and only binds the material data to the GL engine when a different material is drawn. This allows the application to organize the CC3MeshNodes within the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> so that nodes using the same material are drawn together, before moving on to other materials. This strategy can minimize the number of mesh switches in the GL engine, which improves performance. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae6ae5aa8d01f7ee4718764d825a8a45d"></a><!-- doxytag: member="CC3Material::addTexture:" ref="ae6ae5aa8d01f7ee4718764d825a8a45d" args="(CC3Texture *aTexture)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::addTexture: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td>
          <td class="paramname"><em>aTexture</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>In most situations, the material will use a single <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a> in the texture property. </p>
<p>However, if multi-texturing is used, additional <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a> instances can be provided by adding them using this method.</p>
<p>When multiple textures are attached to a material, when drawing, the material will combine these textures together using configurations contained in the textureUnit property of each texture.</p>
<p>As a consistency convenience, if the texture property has not yet been set directly, the first texture added using this method will appear in that property.</p>
<p>Textures are processed by GL texture units in the order they are added to the material. The first texture added (or set directly into the texture property) will be processed by GL texture unit zero. Subsequent textures added with this method will be processed by subsequent texture units, in the order they were added.</p>
<p>The maximum number of texture units available is platform dependent, but will be at least two. The maximum number of texture units available can be read from [<a class="el" href="interface_c_c3_open_g_l_e_s11_engine.html" title="CC3OpenGLES11Engine manages the state of the OpenGL ES 1.1.">CC3OpenGLES11Engine</a> engine].platform.maxTextureUnits.value. If you attempt to add more than this number of textures to the material, the additional textures will be ignored, and an informational message to that fact will be logged. </p>

</div>
</div>
<a class="anchor" id="a3a5a7844f2c06f38f0ec4b2d685d110d"></a><!-- doxytag: member="CC3Material::defaultBlendFunc" ref="a3a5a7844f2c06f38f0ec4b2d685d110d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccBlendFunc CC3Material::defaultBlendFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the default GL material source and destination blend function used for new instances. </p>
<p>The initial value is {GL_ONE GL_ZERO}. </p>

</div>
</div>
<a class="anchor" id="a2cf7b4f23c2d86fde33e4054a0676894"></a><!-- doxytag: member="CC3Material::drawWithVisitor:" ref="a2cf7b4f23c2d86fde33e4054a0676894" args="(CC3NodeDrawingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::drawWithVisitor: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies this material to the GL engine. </p>
<p>The specified visitor encapsulates the frustum of the currently active camera, and certain drawing options.</p>
<p>This implementation first determines if this material is different than the material that was last bound to the GL engine. If this material is indeed different, this method applies the material to the GL engine, otherwise it does nothing.</p>
<p>Draws this texture to the GL engine as follows:</p>
<ul>
<li>Applies the blending properties to the GL engine</li>
<li>Applies the various lighting and color properties to the GL engine</li>
<li>Binds the texture property to the GL engine as texture unit zero.</li>
<li>Binds any additional textures added using addTexture: to additional texture units.</li>
<li>Disables any unused texture units.</li>
</ul>
<p>If the texture property is nil, and there are no overlays, all texture units in the GL engine will be disabled.</p>
<p>This method is invoked automatically during node drawing. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="aebd9670e3268299c4de24a5b7354d8ba"></a><!-- doxytag: member="CC3Material::getTextureNamed:" ref="aebd9670e3268299c4de24a5b7354d8ba" args="(NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a>* CC3Material::getTextureNamed: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the texture with the specified name, that was added either via the texture property or via the addTexture: method. </p>
<p>Returns nil if such a texture cannot be found. </p>

</div>
</div>
<a class="anchor" id="ac7b3c9ac975cc5a4608c04b5890ecdec"></a><!-- doxytag: member="CC3Material::material" ref="ac7b3c9ac975cc5a4608c04b5890ecdec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Material::material </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="acfbc5f5237b301ef0d6d2b61cd60e3b5"></a><!-- doxytag: member="CC3Material::materialWithName:" ref="acfbc5f5237b301ef0d6d2b61cd60e3b5" args="(NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Material::materialWithName: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified name and an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="aa362cc91fe53baf5d4b013d8a7f679ea"></a><!-- doxytag: member="CC3Material::materialWithTag:" ref="aa362cc91fe53baf5d4b013d8a7f679ea" args="(GLuint aTag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Material::materialWithTag: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an unnamed autoreleased instance with the specified tag. </p>

</div>
</div>
<a class="anchor" id="ab395e6105d3b9c98f0d79283272408fc"></a><!-- doxytag: member="CC3Material::materialWithTag:withName:" ref="ab395e6105d3b9c98f0d79283272408fc" args="(GLuint aTag,[withName] NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Material::materialWithTag:withName: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withName] NSString *&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified tag and name. </p>

</div>
</div>
<a class="anchor" id="aeef261147b2559fb4a282d8d71ff91fe"></a><!-- doxytag: member="CC3Material::removeAllTextures" ref="aeef261147b2559fb4a282d8d71ff91fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::removeAllTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all textures from this material. </p>

</div>
</div>
<a class="anchor" id="aca53fca1d8b7b40a937f6592ee668b3d"></a><!-- doxytag: member="CC3Material::removeTexture:" ref="aca53fca1d8b7b40a937f6592ee668b3d" args="(CC3Texture *aTexture)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::removeTexture: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td>
          <td class="paramname"><em>aTexture</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified texture from this material. </p>
<p>If the specified texture is that in the texture property, that property is set to nil. </p>

</div>
</div>
<a class="anchor" id="a35731ec0fe4765bc1caa303b546195c9"></a><!-- doxytag: member="CC3Material::resetSwitching" ref="a35731ec0fe4765bc1caa303b546195c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::resetSwitching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the tracking of the material switching functionality. </p>
<p>This is invoked automatically by the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> at the beginning of each frame drawing cycle. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a893183d57ebc88523759ae2d4d8efc69"></a><!-- doxytag: member="CC3Material::setDefaultBlendFunc:" ref="a893183d57ebc88523759ae2d4d8efc69" args="(ccBlendFunc aBlendFunc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::setDefaultBlendFunc: </td>
          <td>(</td>
          <td class="paramtype">ccBlendFunc&#160;</td>
          <td class="paramname"><em>aBlendFunc</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the default GL material source and destination blend function used for new instances. </p>

</div>
</div>
<a class="anchor" id="ace937216a1762002c5178e06173250de"></a><!-- doxytag: member="CC3Material::setTexture:forTextureUnit:" ref="ace937216a1762002c5178e06173250de" args="(CC3Texture *aTexture,[forTextureUnit] GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::setTexture:forTextureUnit: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> *&#160;</td>
          <td class="paramname"><em>aTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forTextureUnit] GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the texture that will be processed by the texture unit with the specified index, which should be a number between zero, and the value of the textureCount property. </p>
<p>If the specified index is less than the number of texture units added already, the specified texture will replace the one assigned to that texture unit. Otherwise, this implementation will invoke the addTexture: method to add the texture to this material.</p>
<p>If the specified texture unit index is zero, the value of the texture property will be changed to the specified texture. </p>

</div>
</div>
<a class="anchor" id="a0dac6222240307b9265d8925e1a85ade"></a><!-- doxytag: member="CC3Material::shiny" ref="a0dac6222240307b9265d8925e1a85ade" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Material::shiny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag.</p>
<p>The returned instance will have a specularColor of { 1.0, 1.0, 1.0, 1.0 } and a shininess of 75.0. </p>

</div>
</div>
<a class="anchor" id="a5d4c41233629f3940333122d2888c0ef"></a><!-- doxytag: member="CC3Material::shinyWhite" ref="a5d4c41233629f3940333122d2888c0ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3Material::shinyWhite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag.</p>
<p>The returned instance will have both diffuseColor and specularColor set to { 1.0, 1.0, 1.0, 1.0 } and a shininess of 75.0. </p>

</div>
</div>
<a class="anchor" id="aa32362b80cdbb948368a31a43fea7b7b"></a><!-- doxytag: member="CC3Material::textureForTextureUnit:" ref="aa32362b80cdbb948368a31a43fea7b7b" args="(GLuint texUnit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a>* CC3Material::textureForTextureUnit: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>texUnit</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the texture that will be processed by the texture unit with the specified index, which should be a number between zero, and one less than the value of the textureCount property. </p>
<p>The value returned will be nil if there are no textures. </p>

</div>
</div>
<a class="anchor" id="acc08aa7c02cd4b0e6c2025f95cb3ccdb"></a><!-- doxytag: member="CC3Material::unbind" ref="acc08aa7c02cd4b0e6c2025f95cb3ccdb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unbinds the GL engine from any materials. </p>
<p>This implementation simply delegates to the unbind class method. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="acc08aa7c02cd4b0e6c2025f95cb3ccdb"></a><!-- doxytag: member="CC3Material::unbind" ref="acc08aa7c02cd4b0e6c2025f95cb3ccdb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3Material::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unbinds the GL engine from any materials. </p>
<p>Disables material blending in the GL engine, and invokes the unbind class method of <a class="el" href="interface_c_c3_texture.html" title="Each instance of CC3Texture wraps a cocos2d CCTexture2D instance, and manages applying that texture t...">CC3Texture</a> to disable all texturing.</p>
<p>This method is invoked automatically from the <a class="el" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh...">CC3Node</a> instance. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a9f7f6b0c7fbd2704bfe55d6811c461d2"></a><!-- doxytag: member="CC3Material::alphaTestFunction" ref="a9f7f6b0c7fbd2704bfe55d6811c461d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum CC3Material::alphaTestFunction<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the alpha test function that is used to determine if a pixel should be drawn, based on the value of its alpha component. </p>
<p>The value of this property must be one of the following values:</p>
<ul>
<li>GL_ALWAYS: The pixel is always drawn, regardless of its alpha value.</li>
<li>GL_GREATER - The pixel is drawn only if its alpha value is greater than the value in the reference property.</li>
<li>GL_GEQUAL - The pixel is drawn only if its alpha value is greater than or equal to the value in the reference property.</li>
<li>GL_LESS - The pixel is drawn only if its alpha value is less than the value in the reference property.</li>
<li>GL_LEQUAL - The pixel is drawn only if its alpha value is less than or equal to the value in the reference property.</li>
<li>GL_EQUAL - The pixel is drawn only if its alpha value is equal to the value in the reference property.</li>
<li>GL_NOTEQUAL - The pixel is drawn only if its alpha value is not equal to the value in the reference property.</li>
<li>GL_NEVER: The pixel is never drawn.</li>
</ul>
<p>The initial value of this property is GL_ALWAYS, indicating that each pixel will always be drawn, regardless of its alpha value.</p>
<p>For most situations, alpha testing is not necessary, and you can leave the value of this property at its initial value. Alpha testing can sometimes be useful when drawing overlapping objects that each contain transparency, and it is not possible to rely only on drawing order and depth testing to mediate whether a pixel should be drawn.</p>
<p>Although you can set this property directly, since the most common values are either GL_ALWAYS or GL_GREATER, you can use the shouldDrawLowAlpha property as a shortcut to switch between these two values.</p>
<p>Alpha testing within the GL engine is automatically disabled if this property is set to GL_ALWAYS, and enabled for any other value. </p>

</div>
</div>
<a class="anchor" id="a76876ec68366bc046eb16dd3ae7eadfb"></a><!-- doxytag: member="CC3Material::alphaTestReference" ref="a76876ec68366bc046eb16dd3ae7eadfb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Material::alphaTestReference<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the reference value used by the alpha test function to compare against the alpha value of each pixel to determine if it should be drawn. </p>
<p>The value of this property must be between zero and one, inclusive. The value is clamped by the GL engine if it is set to a value outside this range.</p>
<p>The initial value of this property is zero.</p>
<p>The value of this property has no effect if the value of the alphaTestFunction property is either GL_ALWAYS or GL_NEVER.</p>
<p>See the notes for the alphaTestFunction property for more information on alpha testing. </p>

</div>
</div>
<a class="anchor" id="ab7846ec0d2ae3410fe84acc424ac5ceb"></a><!-- doxytag: member="CC3Material::ambientColor" ref="ab7846ec0d2ae3410fe84acc424ac5ceb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Material::ambientColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The color of this material under ambient lighting. </p>
<p>Initially set to kCC3DefaultMaterialColorAmbient.</p>
<p>The value of this property is also affected by changes to the color and opacity properties. See the notes for those properties for more information. </p>

</div>
</div>
<a class="anchor" id="afe43489aee0ba07a343b235db8235b0a"></a><!-- doxytag: member="CC3Material::blendFunc" ref="afe43489aee0ba07a343b235db8235b0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccBlendFunc CC3Material::blendFunc<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCBlendProtocol blendFunc property. </p>
<p>This is a convenience property that gets and sets both the sourceBlend and destinationBlend properties using a single structure. </p>

</div>
</div>
<a class="anchor" id="a93431d16cadeed4a09e077e8f31b1d67"></a><!-- doxytag: member="CC3Material::color" ref="a93431d16cadeed4a09e077e8f31b1d67" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor3B CC3Material::color<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCRGBAProtocol color property. </p>
<p>Querying this property returns the RGB components of the material's diffuseColor property, converted from the floating point range (0 to 1), to the byte range (0 to 255).</p>
<p>When setting this property, the RGB values are each converted to a floating point number between 0 and 1, and are set into both the ambientColor and diffuseColor properties. The alpha of each of those properties remains the same. </p>

</div>
</div>
<a class="anchor" id="ad0627fd29fa0f6382cfd0ca8df6398f9"></a><!-- doxytag: member="CC3Material::destinationBlend" ref="ad0627fd29fa0f6382cfd0ca8df6398f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum CC3Material::destinationBlend<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The blending function for the destination material. </p>
<p>This property must be set to one of the valid GL blending functions.</p>
<p>The value in this property combines with the value in the sourceBlend property to determine the way that materials are combined when one (the source) is drawn over another (the destination). Features such as transparency can cause the two to blend together in various ways.</p>
<p>If you want the source to completely cover the destination, set destinationBlend to GL_ZERO.</p>
<p>If you want to have the destination show through the source, either by setting the diffuse alpha below one, or by covering this material with a texture that contains an alpha channel ( (including pre-multiplied alpha channel), set the destinationBlend to GL_ONE_MINUS_SRC_ALPHA.</p>
<p>Opaque materials can be managed slightly more efficiently than translucent materials. If a material really does not allow other materials to be seen behind it, you should ensure that the sourceBlend and destinationBlend properties are set to GL_ONE and GL_ZERO, respectively, to optimize rendering performance. The performance improvement is small, but can add up if a large number of opaque objects are rendered as if they were translucent.</p>
<p>The initial value is determined by the value of the class-side property defaultBlendFunc, which can be modified by the setDefaultBlendFunc: method.</p>
<p>The value of this property is also affected by changes to the isOpaque and opacity properties. See the notes for those properties for more information. </p>

</div>
</div>
<a class="anchor" id="a919a8cef853de8f25572cc5552c2a15c"></a><!-- doxytag: member="CC3Material::diffuseColor" ref="a919a8cef853de8f25572cc5552c2a15c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Material::diffuseColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The color of this material under ambient lighting. </p>
<p>Initially set to kCC3DefaultMaterialColorDiffuse.</p>
<p>The value of this property is also affected by changes to the color and opacity properties. See the notes for those properties for more information. </p>

</div>
</div>
<a class="anchor" id="ad55970a3cf2c59d4eceb284b130554d1"></a><!-- doxytag: member="CC3Material::emissionColor" ref="ad55970a3cf2c59d4eceb284b130554d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Material::emissionColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The emission color of this material. </p>
<p>Initially set to kCC3DefaultMaterialColorEmission.</p>
<p>The value of this property is also affected by changes to the opacity property. See the notes for the opacity property for more information. </p>

</div>
</div>
<a class="anchor" id="afd63ee59a294524a191376db150a5c02"></a><!-- doxytag: member="CC3Material::hasBumpMap" ref="afd63ee59a294524a191376db150a5c02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Material::hasBumpMap<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether this material contains a texture that is configured as a bump-map. </p>
<p>Returns YES only if one of the textures that was added to this material (either through the texture property or the addTexture: method) returns YES from its isBumpMap property. Otherwise, this property returns NO. </p>

</div>
</div>
<a class="anchor" id="a4448709cd5fdec222a4a045e689727a5"></a><!-- doxytag: member="CC3Material::isOpaque" ref="a4448709cd5fdec222a4a045e689727a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Material::isOpaque<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this material is opaque. </p>
<p>This method returns YES if the values of the sourceBlend and destinationBlend properties are GL_ONE and GL_ZERO, respectively, otherwise this method returns NO.</p>
<p>Setting this property to YES sets the value of the sourceBlend property to GL_ONE and the value of the destinationBlend to GL_ZERO. Setting this property to YES is a convenient way to force the source to completely cover the destination, even if the diffuse alpha value is less than one, and even if the texture contains alpha.</p>
<p>Setting this property to NO sets the value of the destinationBlend property to GL_ONE_MINUS_SRC_ALPHA, and sets the sourceBlend property to GL_SRC_ALPHA, unless the diffuse alpha value is equal to one AND this material has a texture that contains pre-multiplied alpha, in which case sourceBlend is set to GL_ONE.</p>
<p>Setting the value of this property does not change the alpha values of any of the material colors.</p>
<p>The state of this property is also affected by setting the opacity property. As a convenience, changing the opacity property to less than 255 will automatically cause the isOpaque property to be set to NO, which in turn will change the sourceBlend and destinationBlend properties, so that the translucency will be blended correctly.</p>
<p>However, changing the opacity property to 255 will NOT automatically cause the isOpaque property to be set to YES, Even if the opacity of the material is full, the texture may contain translucency, which would be ignored if the isOpaque property were to be set to YES.</p>
<p>Setting this property should be thought of as a convenient way to switch between the two most common types of blending combinations. For finer control of blending, set the sourceBlend and destinationBlend properties and the alpha values of the individual material colors directly, and avoid making changes to this property.</p>
<p>Opaque materials can be managed slightly more efficiently than translucent materials. If a material really does not allow other materials to be seen behind it, you should ensure that this property is set to YES. The performance improvement is small, but can add up if a large number of opaque objects are rendered as if they were translucent. </p>

</div>
</div>
<a class="anchor" id="a0a38e6cb6cc7d9174be38db4ec37f90d"></a><!-- doxytag: member="CC3Material::lightDirection" ref="a0a38e6cb6cc7d9174be38db4ec37f90d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3Material::lightDirection<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The direction, in local tangent coordinates, of the light source that is to interact with any texture contained in this material that has been configured as a bump-map. </p>
<p>Bump-maps are textures that store a normal vector (XYZ coordinates) in the RGB components of each texture pixel, instead of color information. These per-pixel normals interact with the value of this lightDirection property (through a dot-product), to determine the luminance of the pixel.</p>
<p>Setting this property sets the equivalent property in all textures contained within this material.</p>
<p>Reading this value returns the value of the equivalent property in the first texture that is configrued as a bump-map. Otherwise kCC3VectorZero is returned.</p>
<p>The value of this property must be in the tangent-space coordinates associated with the texture UV space, in practice, this property is typically not set directly. Instead, you can use the globalLightLocation property of the mesh node that is making use of this texture. </p>

</div>
</div>
<a class="anchor" id="ad276a69a937c94607600c32c86ac80a6"></a><!-- doxytag: member="CC3Material::opacity" ref="ad276a69a937c94607600c32c86ac80a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLubyte CC3Material::opacity<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the CCRGBAProtocol opacity property. </p>
<p>Querying this property returns the alpha component of the material's diffuseColor property, converted from the floating point range (0 to 1), to the byte range (0 to 255).</p>
<p>When setting this property, the value is converted to a floating point number between 0 and 1, and is set into all of the ambientColor, diffuseColor, specularColor, and emissionColor properties. The RGB components of each of those properties remains unchanged.</p>
<p>Changing this property may also affect the isOpaque property. As a convenience, changing the opacity property to less than 255 will automatically cause the isOpaque property to be set to NO, which in turn will change the sourceBlend and destinationBlend properties, so that the translucency will be blended correctly.</p>
<p>However, changing the opacity property to 255 will NOT automatically cause the isOpaque property to be set to YES, Even if the opacity of the material is full, the texture may contain translucency, which would be ignored if the isOpaque property were to be set to YES.</p>
<p>Setting this property should be thought of as a convenient way to make simple changes to the opacity of a material, using the two most common types of blending combinations. For finer control of blending, set the sourceBlend and destinationBlend properties and the alpha values of the individual material colors directly, and avoid making changes to this property. </p>

</div>
</div>
<a class="anchor" id="aa09ebe1c19c1ca60388f16657ebff415"></a><!-- doxytag: member="CC3Material::shininess" ref="aa09ebe1c19c1ca60388f16657ebff415" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3Material::shininess<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The shininess of this material. </p>
<p>This value is clamped to between zero and kCC3MaximumMaterialShininess. Initially set to kCC3DefaultMaterialShininess. </p>

</div>
</div>
<a class="anchor" id="a46b21c61e69df46542568e3502a02b5f"></a><!-- doxytag: member="CC3Material::shouldDrawLowAlpha" ref="a46b21c61e69df46542568e3502a02b5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Material::shouldDrawLowAlpha<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether alpha testing should be used to determine if pixels with lower alpha values should be drawn. </p>
<p>This property is really a shortcut for setting the alphaTestFunction to either of its two most common values. Setting this property to YES will set the alphaTestFunction propery to GL_ALWAYS. Setting this property to NO will set the alphaTestFunction property to GL_GREATER.</p>
<p>If the value of this property is set to YES, each pixel will be drawn regardless of the value of its alpha component. If the value of this property is set to NO, the value of the alpha component of each pixel will be compared against the value in the alphaTestReference property, and only those pixel alpha values that are greater than that reference value will be drawn. You can set the value of the alphaTestReference property to determine the cutoff level.</p>
<p>Reading the value of this property will return YES if the value of the alphaTestFunction is any of GL_ALWAYS, GL_LESS or GL_LEQUAL, otherwise it returns NO.</p>
<p>The initial value of this property is YES, indicating that pixels with lower alpha values will be drawn.</p>
<p>For most situations, alpha testing is not necessary, and you can leave the value of this property set to YES. Alpha testing can sometimes be useful when drawing overlapping objects that each contain transparency, and it is not possible to rely only on drawing order and depth testing to mediate whether a pixel should be drawn. </p>

</div>
</div>
<a class="anchor" id="a0ef77d2693dce9fbcff5495bcfa1f482"></a><!-- doxytag: member="CC3Material::shouldUseLighting" ref="a0ef77d2693dce9fbcff5495bcfa1f482" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3Material::shouldUseLighting<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this value is set to YES, current lighting conditions will be taken into consideration when drawing colors and textures, and the ambientColor, diffuseColor, specularColor, emissionColor, and shininess properties will interact with lighting settings. </p>
<p>If this value is set to NO, lighting conditions will be ignored when drawing colors and textures, and the emissionColor will be applied to the mesh surface without regard to lighting. Blending will still occur, but the other material aspects, including ambientColor, diffuseColor, specularColor, and shininess will be ignored. This is useful for a cartoon effect, where you want a pure color, or the natural colors of the texture, to be included in blending calculations, without having to arrange lighting, or if you want those colors to be displayed in their natural values despite current lighting conditions.</p>
<p>The initial value of this property is YES. </p>

</div>
</div>
<a class="anchor" id="ad02c0e1797b037dd6c8af8707fd44889"></a><!-- doxytag: member="CC3Material::sourceBlend" ref="ad02c0e1797b037dd6c8af8707fd44889" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum CC3Material::sourceBlend<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The blending function for the source material (this material). </p>
<p>This property must be set to one of the valid GL blending functions.</p>
<p>The value in this property combines with the value in the destinationBlend property to determine the way that materials are combined when one (the source) is drawn over another (the destination). Features such as transparency can cause the two to blend together in various ways.</p>
<p>If you want the source to completely cover the destination, set sourceBlend to GL_ONE.</p>
<p>If you want to have the destination show through the source, either by setting the diffuse alpha below one, or by covering this material with a texture that contains an alpha channel set the sourceBlend to GL_ONE_MINUS_SRC_ALPHA.</p>
<p>However, watch out for textures with a pre-multiplied alpha channel. If this material has a texture with a pre-multiplied alpha channel AND you are NOT trying to make this material translucent by setting diffuse alpha below one, set sourceBlend to GL_ONE, so that the pre-multiplied alpha of the source will blend with the destination correctly.</p>
<p>Opaque materials can be managed slightly more efficiently than translucent materials. If a material really does not allow other materials to be seen behind it, you should ensure that the sourceBlend and destinationBlend properties are set to GL_ONE and GL_ZERO, respectively, to optimize rendering performance. The performance improvement is small, but can add up if a large number of opaque objects are rendered as if they were translucent.</p>
<p>The initial value is determined by the value of the class-side property defaultBlendFunc, which can be modified by the setDefaultBlendFunc: method.</p>
<p>The value of this property is also affected by changes to the isOpaque and opacity properties. See the notes for those properties for more information. </p>

</div>
</div>
<a class="anchor" id="a150d153b442cd047327a63c840d19492"></a><!-- doxytag: member="CC3Material::specularColor" ref="a150d153b442cd047327a63c840d19492" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccColor4F CC3Material::specularColor<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The color of this material under ambient lighting. </p>
<p>Initially set to kCC3DefaultMaterialColorSpecular.</p>
<p>The value of this property is also affected by changes to the opacity property. See the notes for the opacity property for more information. </p>

</div>
</div>
<a class="anchor" id="a71569bea158450f0dbad1da10128c402"></a><!-- doxytag: member="CC3Material::texture" ref="a71569bea158450f0dbad1da10128c402" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_texture.html">CC3Texture</a> * CC3Material::texture<code> [read, write, retain]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When using a single texture for this material, this property holds that texture. </p>
<p>This property may be left nil if no texture is needed.</p>
<p>When using multiple textures for this material, this property holds the first texture. You can add additional textures using the addTexture: method.</p>
<p>As a convenience, this property can also be set using the addTexture: method, which will set this property if it has not been set already. This is useful when using multi-texturing, because it allows all textures attached to this material to be handled the same way.</p>
<p>The texture held by this property will be processed by the first GL texture unit (texture unit zero). </p>

</div>
</div>
<a class="anchor" id="a1bbe2552c8c7eaa364926306a4228b00"></a><!-- doxytag: member="CC3Material::textureCount" ref="a1bbe2552c8c7eaa364926306a4228b00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint CC3Material::textureCount<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of textures attached to this material, regardless of whether the textures were attached using the texture property or the addTexture: method. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_material_8h.html">CC3Material.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_material.html">CC3Material</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:07 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
