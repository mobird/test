<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3VertexArray Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_vertex_array.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3VertexArray Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3VertexArray" --><!-- doxytag: inherits="CC3Identifiable" -->
<p><code>#include &lt;CC3VertexArrays.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3VertexArray:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_vertex_array__inherit__graph.png" border="0" usemap="#_c_c3_vertex_array_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_vertex_array_inherit__map" id="_c_c3_vertex_array_inherit__map">
<area shape="rect" id="node5" href="interface_c_c3_drawable_vertex_array.html" title="This abstract subclass of CC3VertexArray adds the functionality to draw the vertex data to the displa..." alt="" coords="335,31,500,59"/><area shape="rect" id="node13" href="interface_c_c3_vertex_colors.html" title="A CC3VertexArray that manages the per&#45;vertex color aspect of an array of vertices." alt="" coords="359,83,476,111"/><area shape="rect" id="node15" href="interface_c_c3_vertex_matrix_indices.html" title="A CC3VertexArray that manages a collection of indices used by each vertex to point to a collection of..." alt="" coords="339,135,496,163"/><area shape="rect" id="node17" href="interface_c_c3_vertex_normals.html" title="A CC3VertexArray that manages the normal aspect of an array of vertices." alt="" coords="353,187,481,215"/><area shape="rect" id="node19" href="interface_c_c3_vertex_point_sizes.html" title="A CC3VertexArray that manages the point sizes aspect of an array of point sprite vertices." alt="" coords="348,239,487,267"/><area shape="rect" id="node21" href="interface_c_c3_vertex_texture_coordinates.html" title="A CC3VertexArray that manages the texture coordinates aspect of an array of vertices." alt="" coords="323,291,511,319"/><area shape="rect" id="node23" href="interface_c_c3_vertex_weights.html" title="A CC3VertexArray that manages a collection of weights used by each vertex during vertex skinning..." alt="" coords="354,343,481,371"/><area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="5,187,112,215"/><area shape="rect" id="node7" href="interface_c_c3_vertex_indices.html" title="A CC3VertexArray that manages the drawing indices of an array of vertices." alt="" coords="568,6,688,34"/><area shape="rect" id="node11" href="interface_c_c3_vertex_locations.html" title="A CC3VertexArray that manages the location aspect of an array of vertices." alt="" coords="561,58,695,86"/><area shape="rect" id="node9" href="interface_c_c3_vertex_run_length_indices.html" title="An index array that manages the drawing indices of an array of vertices, treating the index array as ..." alt="" coords="744,6,925,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3VertexArray:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_vertex_array__coll__graph.png" border="0" usemap="#_c_c3_vertex_array_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_vertex_array_coll__map" id="_c_c3_vertex_array_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="8,6,115,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_vertex_array-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLvoid *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#aa5d22d9b90fd2c0cbbcd5d3b3aefea34">addressOfElement:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLvoid *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a58b0cf003164ca50b846e67a18dc3296">allocateElements:</a> (GLsizei elemCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#abdc6f5cbdadeaafe9392c448b22d83d8">bindWithVisitor:</a> (<a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *visitor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a2b837623f0311aa4ae96d237ba1621c7">createGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a6706497258798d6680f7a1c2b8a057f5">deallocateElements</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a9d37942763061edb9e840b2435cfa127">deleteGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a50d9bd2a907d45c55a63d407f9f162f7">initFromCPODData:fromSPODMesh:</a> (<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a65a1a1916860ff530310204c0470b2f6">PODClassPtr</a> aCPODData,[fromSPODMesh] <a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a> aSPODMesh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a49f0a98b8a59f9425c8507929dee01db">initFromSPODMesh:</a> (<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a> aSPODMesh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a11b53c891d936d54f8f31ef612875c2f">releaseRedundantData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a38655c1c1ba82e7c163fa9ecf9f38e37">unbind</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a523216f26f2445d7d77aa7dfb2743909">updateGLBuffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#ab57e37aba82b51dd52f216668f1295e0">updateGLBufferStartingAt:forLength:</a> (GLuint offsetIndex,[forLength] GLsizei vertexCount)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5ae339f0616990464b473bcf96a02f62">arrayFromSPODMesh:</a> (<a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a> aSPODMesh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5305c10231dafae45925549e93d867b2">resetAllSwitching</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a7882f1d19f09727193d8175b64020b9d">resetSwitching</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a38655c1c1ba82e7c163fa9ecf9f38e37">unbind</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#af2d91c9e3248eb0a35117dcb8fda01e5">vertexArray</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a0aa8b3c366b0778c5de69b3141869aa9">vertexArrayWithName:</a> (NSString *aName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a9a8e76de5f48794068b4f4cfedc1d02c">vertexArrayWithTag:</a> (GLuint aTag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#ada8d3ddfc39938f055af9a259435da22">vertexArrayWithTag:withName:</a> (GLuint aTag,[withName] NSString *aName)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8cfb738cdcc7212adc058471c30d020"></a><!-- doxytag: member="CC3VertexArray::elementsAreRetained" ref="aa8cfb738cdcc7212adc058471c30d020" args="" -->
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>elementsAreRetained</b></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a5f149c521086bd292fb8e623986fa1f5">bufferID</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a44bb7095577ea63c833c2394800f7c2c">bufferTarget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#aada83be4106cb3e5142660ce8fb9b659">bufferUsage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a9c116e53b61dceb5c2d780d57202afa9">elementCount</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a74fbc055d207e6cbd4cc1b871d7c8682">elementOffset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLvoid *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#aaf394185e2790d304424836ece9633a5">elements</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a2513170e3be6dcae78a8d3a0905683e1">elementSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#ae9c5e04a4edea7a4533290d18ef24b1e">elementStride</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a0585afe3cd645ef4443bb296be440d4d">elementType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#ab1a2cb56553c8f4cff1557372174d57e">shouldAllowVertexBuffering</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_vertex_array.html#a7d1933cbeaf396a5aec9d51b87509ca0">shouldReleaseRedundantData</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> manages the data associated with an aspect of a vertex. </p>
<p><a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> is an abstract implementation, and there are several sublcasses, each specialized to manage the vertex data for a different vertex aspect (locations, normals, colors, texture mapping, indices...).</p>
<p>Each instance of a subclass of <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> maintains a reference to the underlying vertex data in memory, along with various parameters describing the underlying data, such as its type, element size, stride, etc.</p>
<p>The underlying data can be interleaved and shared by several <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> subclasses, each looking at a different aspect of the data for each vertex. In this case, the elements property of each of those vertex array instances will reference the same underlying data memory, and the elementOffset property of each <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instance will indicate at which offset in each vertex data the datum of interest to that instance is located.</p>
<p>The <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instance also manages buffering the data to the GL engine, including loading it into a server-side GL vertex buffer object (VBO) if desired. Once loaded into the GL engine buffers, the underlying data can be released from the <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instance, thereby freeing memory, by using the releaseRedundantData method.</p>
<p>The <a class="el" href="interface_c_c3_drawable_vertex_array.html" title="This abstract subclass of CC3VertexArray adds the functionality to draw the vertex data to the displa...">CC3DrawableVertexArray</a> abstract subclass adds the functionality to draw the vertex data to the display through the GL engine.</p>
<p>When drawing the vertices to the GL engine, each subclass remembers which vertices were last drawn, and only binds the vertices to the GL engine when a different set of vertices of the same type are drawn. This allows the application to organize the CC3MeshNodes within the <a class="el" href="interface_c_c3_world.html" title="CC3World is a CC3Node that manages a 3D scene.">CC3World</a> so that nodes using the same mesh vertices are drawn together, before moving on to other meshes. This strategy can minimize the number of vertex pointer switches in the GL engine, which improves performance.</p>
<p>Vertex arrays support the NSCopying protocol, but in normal operation, the need to create copies of vertex arrays is rare.</p>
<p>By default, when a mesh node is copied, it does not make a separate copy of its model. Both the original and the copy make use of the same mesh instance. Similarly, when a mesh is copied, it does not make separate copies of its vertex arrays. Instead, both the original and the copy make use of the same vertex array instances.</p>
<p>However, in some cases, such as populating a mesh from a template and then manipulating the contents of each resulting mesh individually, creating copies of vertex arrays can be useful.</p>
<p>If you do find need to create a copy of a vertex array, you can do so by invoking the copy method. However, you should take care to understand several points about copying vertex arrays:</p>
<ul>
<li>Copying a vertex array creates a full copy of the vertex data. This may consume significant memory.</li>
<li>The vertex data is copied for each vertex array copy. If several vertex arrays share interleaved data, multiple copies of that data will be created. This is almost never what you intend to do, and results in significant redundant data in memory. Instead, consider creating a copy of one of the vertex arrays, and then manually populating the others so that the interleaved vertex data can be shared.</li>
<li>If the value of the shouldReleaseRedundantData property of the original vertex array is YES and releaseRedundantData has been invoked, there will be no vertex data to be copied.</li>
<li>The new vertex array will not have a GL vertex buffer object associated with it. To buffer the vertex data of the new vertex array, invoke the createGLBuffer method on the new vertex array. </li>
</ul>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa5d22d9b90fd2c0cbbcd5d3b3aefea34"></a><!-- doxytag: member="CC3VertexArray::addressOfElement:" ref="aa5d22d9b90fd2c0cbbcd5d3b3aefea34" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLvoid* CC3VertexArray::addressOfElement: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the element in the underlying data at the specified index. </p>
<p>The implementation takes into consideration the elementStride and elementOffset properties to locate the aspect of interest in this instance.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, or the index is beyond the elementCount, this method will raise an assertion exception. </p>

</div>
</div>
<a class="anchor" id="a58b0cf003164ca50b846e67a18dc3296"></a><!-- doxytag: member="CC3VertexArray::allocateElements:" ref="a58b0cf003164ca50b846e67a18dc3296" args="(GLsizei elemCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLvoid* CC3VertexArray::allocateElements: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>elemCount</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates underlying memory for the specified number of elements, taking into consideration the elementStride, assigns the elements property to point to the allocated memory, and returns a pointer to the allocated memory. </p>
<p>Specifically, the amount of memory allocated will be (elemCount * self.elementStride) bytes.</p>
<p>If the underlying data is to be interleaved, set the value of the elementStride property to the appropriate value before invoking this method. If the underlying data will not be interleaved, the elementStride property is determined by the elementType and elementSize properties. Therefore, set the correct values of these two properties before invoking this method.</p>
<p>When interleaving data, this method should be invoked on only one of the <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instances that are sharing the underlying data. After allocating on one <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instances, set the elements property of the other instances to be equal to the elements property of the <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instance on which this method was invoked (or just simply to the pointer returned by this method).</p>
<p>It is safe to invoke this method more than once, but understand that any previously allocated memory will be safely freed prior to the allocation of the new memory. The memory allocated earlier will therefore be lost and should not be referenced. </p>

</div>
</div>
<a class="anchor" id="a5ae339f0616990464b473bcf96a02f62"></a><!-- doxytag: member="CC3VertexArray::arrayFromSPODMesh:" ref="a5ae339f0616990464b473bcf96a02f62" args="(PODStructPtr aSPODMesh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a>(PVRPOD)::arrayFromSPODMesh: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>&#160;</td>
          <td class="paramname"><em>aSPODMesh</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance from the specified SPODMesh structure. </p>

</div>
</div>
<a class="anchor" id="abdc6f5cbdadeaafe9392c448b22d83d8"></a><!-- doxytag: member="CC3VertexArray::bindWithVisitor:" ref="abdc6f5cbdadeaafe9392c448b22d83d8" args="(CC3NodeDrawingVisitor *visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::bindWithVisitor: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_node_drawing_visitor.html">CC3NodeDrawingVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binds the GL engine to the underlying vertex data, if needed, in preparation for drawing. </p>
<p>This implementation first invokes the switchingArray method on this instance to determine if this vertex array is different than the vertex array that was last bound to the GL engine. If this vertex array is indeed different, this method invokes the bindGL method, otherwise it does nothing.</p>
<p>This is invoked automatically from the draw method of the <a class="el" href="interface_c_c3_vertex_array_mesh.html" title="A CC3VertexArrayMesh is a mesh whose mesh data is kept in a set of CC3VertexArrays instances...">CC3VertexArrayMesh</a> containing this instance. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a2b837623f0311aa4ae96d237ba1621c7"></a><!-- doxytag: member="CC3VertexArray::createGLBuffer" ref="a2b837623f0311aa4ae96d237ba1621c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::createGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the shouldAllowVertexBuffering property is set to YES, creates a vertex buffer object within the GL engine, copies the data referenced by the elements into the GL engine (which may make use of VRAM), and sets the value of the bufferID property to that of the new GL buffer. </p>
<p>Calling this method is optional. Using GL engine buffers is more efficient than passing arrays on each GL draw call, but is optional. If you choose not to call this method, this instance will pass the mesh data properties to the GL engine on each draw call.</p>
<p>If the GL engine cannot allocate space for any of the buffers, this instance will revert to passing the array data for any unallocated buffer on each draw call.</p>
<p>When using interleaved data, this method should be invoked on only one of the <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> that share the data. The bufferID property of that instance should then be copied to the other instances.</p>
<p>It is safe to invoke this method more than once, but subsequent invocations will do nothing.</p>
<p>This method is invoked automatically by the createGLBuffers method of the mesh class, which also coordinates the invocations across multiple <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instances when interleaved data is shared between them, along with the subsequent copying of the bufferID's. Consider using the createGLBuffers of the mesh class instead of this method. </p>

</div>
</div>
<a class="anchor" id="a6706497258798d6680f7a1c2b8a057f5"></a><!-- doxytag: member="CC3VertexArray::deallocateElements" ref="a6706497258798d6680f7a1c2b8a057f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::deallocateElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates the underlying vertex data memory that was previously allocated with the allocateElements: method. </p>
<p>It is safe to invoke this method more than once, or even if allocateElements: was not previously invoked.</p>
<p>When using interleaved memory, deallocateElements must be invoked on the same <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> instance on which the original allocateElements: was invoked.</p>
<p>Deallocating the elements array does not change the elementCount property, because that property is still used for other operations, including drawing.</p>
<p>This method is invoked automatically when this instance is deallocated. </p>

</div>
</div>
<a class="anchor" id="a9d37942763061edb9e840b2435cfa127"></a><!-- doxytag: member="CC3VertexArray::deleteGLBuffer" ref="a9d37942763061edb9e840b2435cfa127" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::deleteGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the GL engine buffers created with createGLBuffer. </p>
<p>After calling this method, if they have not been released by createGLBuffer, the vertex data will be passed to the GL engine on each subsequent draw operation. It is safe to call this method even if GL buffers have not been created.</p>
<p>This method may be invoked at any time to free up GL memory, but only if this vertex array will not be used again, or if the data was not released by releaseRedundantData. This would be the case if allocateElements: was not invoked.</p>
<p>This method is invoked automatically when this instance is deallocated. </p>

</div>
</div>
<a class="anchor" id="a50d9bd2a907d45c55a63d407f9f162f7"></a><!-- doxytag: member="CC3VertexArray::initFromCPODData:fromSPODMesh:" ref="a50d9bd2a907d45c55a63d407f9f162f7" args="(PODClassPtr aCPODData,[fromSPODMesh] PODStructPtr aSPODMesh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a>(PVRPOD)::initFromCPODData:fromSPODMesh: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_c3_p_v_r_foundation_8h.html#a65a1a1916860ff530310204c0470b2f6">PODClassPtr</a>&#160;</td>
          <td class="paramname"><em>aCPODData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromSPODMesh] <a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>&#160;</td>
          <td class="paramname"><em>aSPODMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes this instance from the specified CPODData structure and the specified SPODMesh structure. </p>

</div>
</div>
<a class="anchor" id="a49f0a98b8a59f9425c8507929dee01db"></a><!-- doxytag: member="CC3VertexArray::initFromSPODMesh:" ref="a49f0a98b8a59f9425c8507929dee01db" args="(PODStructPtr aSPODMesh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id <a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a>(PVRPOD)::initFromSPODMesh: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_c3_p_v_r_foundation_8h.html#a6e92625834f5d9008b3088d31b4cb41a">PODStructPtr</a>&#160;</td>
          <td class="paramname"><em>aSPODMesh</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes this instance from the specified SPODMesh structure. </p>
<p>This abstract implementation does nothing. Category extensions to the concrete subclasses of <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> must override to extract the suitable CPODData structure for the type of array from the specifed SPODMesh structure and then invoke the initFromCPODData:fromSPODMesh: initializer. </p>

</div>
</div>
<a class="anchor" id="a11b53c891d936d54f8f31ef612875c2f"></a><!-- doxytag: member="CC3VertexArray::releaseRedundantData" ref="a11b53c891d936d54f8f31ef612875c2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::releaseRedundantData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Once the elements data has been buffered into a GL vertex buffer object (VBO) within the GL engine, via the createGLBuffer method, this method can be used to release the data in main memory that is now redundant. </p>
<p>If the shouldReleaseRedundantData property is set to NO, or if the elements data has not been successfully buffered to a VBO in the GL engine. this method does nothing. It is safe to invokde this method even if createGLBuffer has not been invoked, and even if VBO buffering was unsuccessful.</p>
<p>Typically, this method is not invoked directly by the application. Instead, consider using the same method on a node assembly in order to release as much memory as possible in one simply method invocation.</p>
<p>Subclasses may extend this behaviour to remove data loaded, for example, from files, but should ensure that data is only released if bufferId is valid (not zero), and the shouldReleaseRedundantData property is set to YES. </p>

</div>
</div>
<a class="anchor" id="a5305c10231dafae45925549e93d867b2"></a><!-- doxytag: member="CC3VertexArray::resetAllSwitching" ref="a5305c10231dafae45925549e93d867b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::resetAllSwitching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the tracking of the vertex array switching functionality for all vertex array subclasses. </p>
<p>This is invoked automatically by the resetSwitching method in <a class="el" href="interface_c_c3_vertex_array_mesh.html" title="A CC3VertexArrayMesh is a mesh whose mesh data is kept in a set of CC3VertexArrays instances...">CC3VertexArrayMesh</a> at the beginning of each frame drawing cycle. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a7882f1d19f09727193d8175b64020b9d"></a><!-- doxytag: member="CC3VertexArray::resetSwitching" ref="a7882f1d19f09727193d8175b64020b9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::resetSwitching </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the tracking of the vertex array switching functionality. </p>
<p>This is invoked automatically by the resetAllSwitching method at the beginning of each frame drawing cycle. Usually, the application never needs to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="a38655c1c1ba82e7c163fa9ecf9f38e37"></a><!-- doxytag: member="CC3VertexArray::unbind" ref="a38655c1c1ba82e7c163fa9ecf9f38e37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unbinds the GL engine from the vertex aspect managed by this instance. </p>
<p>This implementation simply delegates to the unbind class method. Usually, the application never needs to invoke this method directly. </p>

<p>Implemented in <a class="el" href="interface_c_c3_vertex_texture_coordinates.html#a17e737a8e9fe0248301efc8e7625b64d">CC3VertexTextureCoordinates</a>.</p>

</div>
</div>
<a class="anchor" id="a38655c1c1ba82e7c163fa9ecf9f38e37"></a><!-- doxytag: member="CC3VertexArray::unbind" ref="a38655c1c1ba82e7c163fa9ecf9f38e37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unbinds the GL engine from the vertex aspect managed by this class. </p>
<p>This abstract implementation does nothing. Subclasses will override to handle their particular type of vetex aspect.</p>
<p>This method is invoked automatically from the <a class="el" href="interface_c_c3_vertex_array_mesh.html" title="A CC3VertexArrayMesh is a mesh whose mesh data is kept in a set of CC3VertexArrays instances...">CC3VertexArrayMesh</a> instance. Usually, the application never needs to invoke this method directly. </p>

<p>Implemented in <a class="el" href="interface_c_c3_vertex_texture_coordinates.html#a17e737a8e9fe0248301efc8e7625b64d">CC3VertexTextureCoordinates</a>.</p>

</div>
</div>
<a class="anchor" id="a523216f26f2445d7d77aa7dfb2743909"></a><!-- doxytag: member="CC3VertexArray::updateGLBuffer" ref="a523216f26f2445d7d77aa7dfb2743909" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::updateGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with all of the element data contained in this array. </p>

</div>
</div>
<a class="anchor" id="ab57e37aba82b51dd52f216668f1295e0"></a><!-- doxytag: member="CC3VertexArray::updateGLBufferStartingAt:forLength:" ref="ab57e37aba82b51dd52f216668f1295e0" args="(GLuint offsetIndex,[forLength] GLsizei vertexCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3VertexArray::updateGLBufferStartingAt:forLength: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>offsetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[forLength] GLsizei&#160;</td>
          <td class="paramname"><em>vertexCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the element data contained in this array, starting at the vertex at the specified offsetIndex, and extending for the specified number of vertices. </p>

</div>
</div>
<a class="anchor" id="af2d91c9e3248eb0a35117dcb8fda01e5"></a><!-- doxytag: member="CC3VertexArray::vertexArray" ref="af2d91c9e3248eb0a35117dcb8fda01e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3VertexArray::vertexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased unnamed instance with an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a0aa8b3c366b0778c5de69b3141869aa9"></a><!-- doxytag: member="CC3VertexArray::vertexArrayWithName:" ref="a0aa8b3c366b0778c5de69b3141869aa9" args="(NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3VertexArray::vertexArrayWithName: </td>
          <td>(</td>
          <td class="paramtype">NSString *&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified name and an automatically generated unique tag value. </p>
<p>The tag value is generated using a call to nextTag. </p>

</div>
</div>
<a class="anchor" id="a9a8e76de5f48794068b4f4cfedc1d02c"></a><!-- doxytag: member="CC3VertexArray::vertexArrayWithTag:" ref="a9a8e76de5f48794068b4f4cfedc1d02c" args="(GLuint aTag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3VertexArray::vertexArrayWithTag: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an unnamed autoreleased instance with the specified tag. </p>

</div>
</div>
<a class="anchor" id="ada8d3ddfc39938f055af9a259435da22"></a><!-- doxytag: member="CC3VertexArray::vertexArrayWithTag:withName:" ref="ada8d3ddfc39938f055af9a259435da22" args="(GLuint aTag,[withName] NSString *aName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3VertexArray::vertexArrayWithTag:withName: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withName] NSString *&#160;</td>
          <td class="paramname"><em>aName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes an autoreleased instance with the specified tag and name. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a5f149c521086bd292fb8e623986fa1f5"></a><!-- doxytag: member="CC3VertexArray::bufferID" ref="a5f149c521086bd292fb8e623986fa1f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint CC3VertexArray::bufferID<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the underlying data has been loaded into a GL engine vertex buffer object, this property holds the ID of that GL buffer as provided by the GL engine when the createGLBuffer method was invoked. </p>
<p>If the createGLBuffer method was not invoked, and the underlying vertex was not loaded into a GL VBO, this property will be zero. </p>

</div>
</div>
<a class="anchor" id="a44bb7095577ea63c833c2394800f7c2c"></a><!-- doxytag: member="CC3VertexArray::bufferTarget" ref="a44bb7095577ea63c833c2394800f7c2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum CC3VertexArray::bufferTarget<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The GL engine buffer target. </p>
<p>Must be one of GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.</p>
<p>The default value is GL_ARRAY_BUFFER. Subclasses that manage index data will override. </p>

</div>
</div>
<a class="anchor" id="aada83be4106cb3e5142660ce8fb9b659"></a><!-- doxytag: member="CC3VertexArray::bufferUsage" ref="aada83be4106cb3e5142660ce8fb9b659" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum CC3VertexArray::bufferUsage<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The GL engine buffer usage hint, used by the GL engine to arrange data for access when loading data into a server-side vertex buffer object. </p>
<p>The default value is GL_STATIC_DRAW, indicating to the GL engine that the data will generally not be re-accessed after loading. If you will be updating the data frequently, you can change this to GL_DYNAMIC_DRAW. </p>

</div>
</div>
<a class="anchor" id="a9c116e53b61dceb5c2d780d57202afa9"></a><!-- doxytag: member="CC3VertexArray::elementCount" ref="a9c116e53b61dceb5c2d780d57202afa9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei CC3VertexArray::elementCount<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of elements in the underlying data referenced by the elements property. </p>
<p>The elements property must point to an underlying memory space that is large enough to hold the amount of data specified by this elementCount property.</p>
<p>The initial value is zero. </p>

</div>
</div>
<a class="anchor" id="a74fbc055d207e6cbd4cc1b871d7c8682"></a><!-- doxytag: member="CC3VertexArray::elementOffset" ref="a74fbc055d207e6cbd4cc1b871d7c8682" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint CC3VertexArray::elementOffset<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When using interleaved data, this property indicates the offset, within the data for a single vertex, at which the datum managed by this instance is located. </p>
<p>When data is not interleaved, and the elements data is dedicated to this instance, this property will be zero.</p>
<p>The initial value is zero. </p>

</div>
</div>
<a class="anchor" id="aaf394185e2790d304424836ece9633a5"></a><!-- doxytag: member="CC3VertexArray::elements" ref="aaf394185e2790d304424836ece9633a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLvoid * CC3VertexArray::elements<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A pointer to the underlying vertex data. </p>
<p>If the underlying data memory is assigned to this instance using this property directly, the underlying data memory is neither retained nor deallocated by this instance. It is up to the application to manage the allocation and deallocation of the underlying data memory.</p>
<p>Alternately, the method allocateElements: can be used to have this instance allocate and manage the underlying data. When this is done, the underlying data memory will be retained and deallocated by this instance.</p>
<p>The underlying data can be interleaved and shared by several <a class="el" href="interface_c_c3_vertex_array.html" title="CC3VertexArray manages the data associated with an aspect of a vertex.">CC3VertexArray</a> subclasses, each looking at a different aspect of the data for each vertex. In this case, the elements property of each of those vertex array instances will reference the same underlying data memory, and the elementOffset property will indicate at which offset in each vertex data the datum of interest to that instance is located. </p>

</div>
</div>
<a class="anchor" id="a2513170e3be6dcae78a8d3a0905683e1"></a><!-- doxytag: member="CC3VertexArray::elementSize" ref="a2513170e3be6dcae78a8d3a0905683e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint CC3VertexArray::elementSize<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of components associated with each vertex in the underlying data. </p>
<p>As an example, the location of each vertex in 3D space is specified by three components (X,Y &amp; Z), so the value of this property in an instance tracking vertex locations would be three.</p>
<p>The initial value is three. Subclass may override this default. </p>

</div>
</div>
<a class="anchor" id="ae9c5e04a4edea7a4533290d18ef24b1e"></a><!-- doxytag: member="CC3VertexArray::elementStride" ref="ae9c5e04a4edea7a4533290d18ef24b1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei CC3VertexArray::elementStride<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of bytes between consecutive vertices for the vertex aspect being managed by this instance. </p>
<p>If the underlying data is not interleaved, and contains only the data managed by this instance, the value of this property will be the size of a single element of the type of data indicated by the elementType property multiplied by the value of the elementSize property. For example, with the default elementType of GL_FLOAT and elementSize of three, the value of the elementStride property will be (4 * 3) = 12.</p>
<p>If the underlying data is interleaved and contains data for several vertex aspects (location, normals, colors...) interleaved in one memory space, this value should be set by the application to indicate the distance, in bytes, from one element of this aspect to the next.</p>
<p>The initial value of this property is the size of a single element of the type of data indicated by the elementType property multiplied by the value of the elementSize property. </p>

</div>
</div>
<a class="anchor" id="a0585afe3cd645ef4443bb296be440d4d"></a><!-- doxytag: member="CC3VertexArray::elementType" ref="a0585afe3cd645ef4443bb296be440d4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum CC3VertexArray::elementType<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The type of data associated with each component of a vertex. </p>
<p>This must be a valid enumerated GL data type suitable for the type of element.</p>
<p>The initial value is GL_FLOAT. </p>

</div>
</div>
<a class="anchor" id="ab1a2cb56553c8f4cff1557372174d57e"></a><!-- doxytag: member="CC3VertexArray::shouldAllowVertexBuffering" ref="ab1a2cb56553c8f4cff1557372174d57e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3VertexArray::shouldAllowVertexBuffering<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance should allow the vertex data to be copied to a vertex buffer object within the GL engine when the createGLBuffer method is invoked. </p>
<p>The initial value of this property is YES. In most cases, this is appropriate, but for specific meshes, it might make sense to retain data in main memory and submit it to the GL engine during each frame rendering.</p>
<p>As an alternative to setting this property to NO, consider leaving it as YES, and making use of the updateGLBuffer and updateGLBufferStartingAt:forLength: to dynamically update the data in the GL engine buffer. Doing so permits the data to be copied to the GL engine only when it has changed, and permits copying only the range of data that has changed, both of which offer performance improvements over submitting all of the vertex data on each frame render. </p>

</div>
</div>
<a class="anchor" id="a7d1933cbeaf396a5aec9d51b87509ca0"></a><!-- doxytag: member="CC3VertexArray::shouldReleaseRedundantData" ref="a7d1933cbeaf396a5aec9d51b87509ca0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3VertexArray::shouldReleaseRedundantData<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this instance should release the data held in the elments array when the releaseRedundantData method is invoked. </p>
<p>The initial value of this property is YES. In most cases, this is appropriate, but in some circumstances it might make sense to retain some data (usually the vertex locations) in main memory for potantial use in collision detection, etc. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_vertex_arrays_8h.html">CC3VertexArrays.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_vertex_array.html">CC3VertexArray</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:11 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
