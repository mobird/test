<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3PointParticleEmitter Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_point_particle_emitter.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3PointParticleEmitter Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3PointParticleEmitter" --><!-- doxytag: inherits="CC3MeshNode" -->
<p><code>#include &lt;CC3PointParticles.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC3PointParticleEmitter:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_point_particle_emitter__inherit__graph.png" border="0" usemap="#_c_c3_point_particle_emitter_inherit__map" alt="Inheritance graph"/></div>
<map name="_c_c3_point_particle_emitter_inherit__map" id="_c_c3_point_particle_emitter_inherit__map">
<area shape="rect" id="node11" href="interface_c_c3_mortal_point_particle_emitter.html" title="CC3MortalPointParticleEmitter emits particles of type CC3MortalPointParticle." alt="" coords="30,393,220,421"/><area shape="rect" id="node2" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh." alt="" coords="73,238,177,266"/><area shape="rect" id="node4" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="52,161,199,189"/><area shape="rect" id="node6" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="88,83,161,111"/><area shape="rect" id="node8" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="72,6,179,34"/><area shape="rect" id="node13" href="interface_c_c3_point_particle_hose_emitter.html" title="CC3PointParticleHoseEmitter emits CC3UniformMotionParticle particles in a stream, as if from the nozz..." alt="" coords="34,470,216,498"/><area shape="rect" id="node15" href="interface_c_c3_variegated_point_particle_hose_emitter.html" title="CC3VariegatedPointParticleHoseEmitter is a type of CC3PointParticleHoseEmitter whose particles can ha..." alt="" coords="5,547,245,575"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CC3PointParticleEmitter:</div>
<div class="dyncontent">
<div class="center"><img src="interface_c_c3_point_particle_emitter__coll__graph.png" border="0" usemap="#_c_c3_point_particle_emitter_coll__map" alt="Collaboration graph"/></div>
<map name="_c_c3_point_particle_emitter_coll__map" id="_c_c3_point_particle_emitter_coll__map">
<area shape="rect" id="node2" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh." alt="" coords="40,259,144,287"/><area shape="rect" id="node4" href="interface_c_c3_local_content_node.html" title="CC3LocalContentNode is an abstract class that forms the basis for nodes that have local content to dr..." alt="" coords="5,179,152,207"/><area shape="rect" id="node6" href="interface_c_c3_node.html" title="CC3Node and its subclasses form the basis of all 3D artifacts in the 3D world, including visible mesh..." alt="" coords="137,99,211,127"/><area shape="rect" id="node16" href="interface_c_c3_targetting_node.html" title="This is a node class representing a 3D model node that can be pointed in a particular direction..." alt="" coords="176,179,305,207"/><area shape="rect" id="node8" href="interface_c_c3_identifiable.html" title="This is a base subclass for any class that uses tags or names to identify individual instances..." alt="" coords="57,6,164,34"/><area shape="rect" id="node10" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array." alt="" coords="189,6,288,34"/><area shape="rect" id="node12" href="struct_c_c3_vector.html" title="A vector in 3D space." alt="" coords="302,259,383,287"/><area shape="rect" id="node14" href="interface_c_c3_camera.html" title="CC3Camera represents the camera viewing the 3D world." alt="" coords="190,259,276,287"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="interface_c_c3_point_particle_emitter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a42ea51c0f10e51a29b23c2f9b999024a">doNotBufferVertexPointSizes</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#ada104fa3d021a89d7abffcf39ba4707b">emitParticle</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a338de77ea16cad1b4f4ad7367633c5ce">initializeParticle:</a> (<a class="el" href="interface_c_c3_point_particle.html">CC3PointParticle</a> *aParticle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#ada3f720d1f73957d898d9fb552ab91ea">particleClass</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a7042bd13a99e4306764dfc61846bb67a">particleSizeAt:</a> (GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a5a88c02ffb182711e0b646c9d16c0050">pause</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#afbe06be477058888df012897ff373bd8">play</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a250d4778f0dd70d0406b57e7898c0d00">populateForMaxParticles:</a> (GLuint maxParticles)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#ad64029271feb5ef5d8f35ad6a0006462">populateForMaxParticles:containing:</a> (GLuint numParticles,[containing] <a class="el" href="_c_c3_point_particles_8h.html#a618528ed4a53a0b3e2a8b3904eb89d25">CC3PointParticleVertexContent</a> contentTypes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a3eac24110f8c1869ae18e7932245250d">populateForMaxParticles:ofType:</a> (GLuint maxParticles,[ofType] id aParticleClass)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a23364537ecdad0a7f55b14bf463fe766">populateForMaxParticles:ofType:containing:</a> (GLuint numParticles,[ofType] id aParticleClass,[containing] <a class="el" href="_c_c3_point_particles_8h.html#a618528ed4a53a0b3e2a8b3904eb89d25">CC3PointParticleVertexContent</a> contentTypes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#abb9ec8bbdc7a40985565bb1dadb201a7">retainVertexPointSizes</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#aa37fe8fe898c05d8cf44223a685cb381">setParticleSize:at:</a> (GLfloat aSize,[at] GLsizei index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a9712038dfe3527cb2d8e3e57ba16a20b">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a4fb6508b314eb48e88529a09d7b53365">updateParticleSizesGLBuffer</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25d2216000452ecfe8978a17b71716d"></a><!-- doxytag: member="CC3PointParticleEmitter::cachedCamera" ref="aa25d2216000452ecfe8978a17b71716d" args="" -->
<a class="el" href="interface_c_c3_camera.html">CC3Camera</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>cachedCamera</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad831f2d2fd89d7e292c5ca27156d3914"></a><!-- doxytag: member="CC3PointParticleEmitter::globalCameraLocation" ref="ad831f2d2fd89d7e292c5ca27156d3914" args="" -->
<a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>globalCameraLocation</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07d58749fe1c8bdd016b714338801f50"></a><!-- doxytag: member="CC3PointParticleEmitter::timeSinceEmission" ref="a07d58749fe1c8bdd016b714338801f50" args="" -->
ccTime&#160;</td><td class="memItemRight" valign="bottom"><b>timeSinceEmission</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05ccc9477b3208ed82ad2a4dd246f13b"></a><!-- doxytag: member="CC3PointParticleEmitter::verticesAreDirty" ref="a05ccc9477b3208ed82ad2a4dd246f13b" args="" -->
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>verticesAreDirty</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae22057b69ece4f5695424ced21bce7ce"></a><!-- doxytag: member="CC3PointParticleEmitter::wasStarted" ref="ae22057b69ece4f5695424ced21bce7ce" args="" -->
BOOL&#160;</td><td class="memItemRight" valign="bottom"><b>wasStarted</b></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a137a3310525a56a8971c2981e21799a6">elapsedTime</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a054cbdfa4eb587be1f371ce8ba0f0a1b">emissionDuration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ccTime&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#aec8e1fdb0981cc21e0dcaef41130eb03">emissionInterval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a9a59b4f66d70ebd3657d3e62848d4cb7">emissionRate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#afaddd85c3dab13597d045b2b4017990a">isActive</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#acbb46f18f0c2788b20bda2f715109ada">isEmitting</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a51622d5e4eec07a42304f6a1870ea610">isFinished</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#aed759b0b275d8e6f247d6f152e928e61">isFull</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a78bdd37ec092adf16d828c3797b263ad">maxParticles</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a85816caf390b37751deaf059e7454a5c">particleClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_c3_point_particles_8h.html#a618528ed4a53a0b3e2a8b3904eb89d25">CC3PointParticleVertexContent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a81ab56ee34c5382736b379e51064a479">particleContentTypes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a4680550a122959c165b0f14063cd1a0b">particleCount</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_c_c3_point_particle_mesh.html">CC3PointParticleMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#ae41d7261e24a8dc4e262ca20ba23a540">particleMesh</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CCArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a2cf9e00aa8d026851fa2db663f5862bc">particles</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a0abab9370c3aeae50b71574f816d2b44">particleSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_attenuation_coefficients.html">CC3AttenuationCoefficients</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a59498a12883ea05195a688a36aad1a97">particleSizeAttenuationCoefficients</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a09be9c460f38d64f8013d3bafff56a3c">particleSizeMaximum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a5801f18cdfb1517d4c514623ab8b9346">particleSizeMinimum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#af7c664a560b2791ade34a44fe26f41ee">shouldNormalizeParticleSizesToDevice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a50c6cbfc9e94295bf7bff6db629b229b">shouldRemoveOnFinish</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#a0d53b25af3632108f7f5f8b98b96977b">shouldSmoothPoints</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_point_particle_emitter.html#ae3a1a4eb49f322aeb2bd7f16ee1f1de0">unityScaleDistance</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="interface_c_c3_mesh_node.html" title="A CC3Node that draws a 3D mesh.">CC3MeshNode</a> that emits 3D point particles. </p>
<p>Particles emitted by <a class="el" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles.">CC3PointParticleEmitter</a> live in the 3D world, as distinct from the 2D particles available through the cocos2d CCParticleSystem class.</p>
<p>For many particle effects, 2D is sufficient, and can be quite effective. You can use a cocos2d CCParticleSystem instance with a <a class="el" href="interface_c_c3_billboard.html" title="This CC3Node displays a 2D cocos2d CCNode as part of the 3D world.">CC3Billboard</a>, to embed 2D particle systems within a 3D cocos3d world.</p>
<p>However, for applications that need particles to move in three dimensions, you can use this class. Each particle emitted by <a class="el" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles.">CC3PointParticleEmitter</a> has a 3D location, will appear in front of or behind other 3D objects, depending on relative distance from the camera, and can be configured to automatically appear smaller or larger depending on distance from the camera.</p>
<p>Each particle emitted displays the same texture, which is determined by the texture property of this emitter node. Be aware that OpenGL point particles use the entire texture, which you should generally ensure has dimensions that are power-of-two. Non-POT textures will be padded by iOS when loaded, for compatibility with the graphics hardware. Although the padding is generally transparent, it may throw off the expected location of your particle.</p>
<p>Each particle has its own location, and may optionally be configued with its own color and individual size, and each particle may be configured with a vertex normal so that it can interact with light sources. These particle components are determined by the parameters of the populateForMaxParticles:ofType:... initialization methods.</p>
<p>The populateForMaxParticles:ofType:... initialization methods also specify the maximum number of particles that will be emitted concurrently, and the type of particle that will be emitted.</p>
<p>When creating a particle system, you write application-specific subclasses of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> to embody the state and life-cycle behaviour of each particle, and you usually, but not always, write a customized subclass of <a class="el" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles.">CC3PointParticleEmitter</a> to assist with initialization of the particles during emission.</p>
<p>Each particle is an instance of a subclass of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a>, which is an abstract class that manages the basic location, color, size and vertex normal content of particles. Application-specific subclasses define and control particle behaviour, such as life span, velocity, etc.</p>
<p>To define your own particle behaviour, you create a subclass of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> and indicate to the emitter that you want it to use that subclass by passing that class as an argument to one of the populateForMaxParticles:ofType:... methods.</p>
<p>To define the emission characteristics for your particle system, such as minimum and maximum particle lifespans, emission directions, color ranges, etc, you can create a customized subclass of <a class="el" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles.">CC3PointParticleEmitter</a>.</p>
<p>When an emitter first emits a particle of your <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> subclass, it invokes the initializeParticle: method on itself. The default implementation of that method invokes the initializeParticle method on the particle. You should override either or both of these methods to configure the particle, and create the initial conditions and content of a particle, prior to it being emitted.</p>
<p>Subsequently, on each update pass, the emitter will automatically invoke the update: method on the particle. You can override this method to define the behaviour of your particles over time. If your particles have a finite lifespan, you can indicate that a particle has expired by having the particle set its own isAlive property to NO within the update: method.</p>
<p>The isAlive property is automatically set to YES before the initializeParticle method is invoked on the particle, so you don't have to set it there. You can, however, set it to NO during execution of the initializeParticle method, to abort the emission of that particle.</p>
<p>To enhance performance and memory, particles that have expired are retained and reused as further particles are emitted. This is transparent to the particles (and the developer), as the reused particle follow the same life-cycle. The isAlive property is reset to YES, and theinitializeParticle: method of the emitter, and the initializeParticle method of the particle are invoked when the particle is emitted again.</p>
<p>Like all mesh nodes, the emitter contains a <a class="el" href="interface_c_c3_material.html" title="CC3Material manages information about a material that is used to cover one or more meshes...">CC3Material</a> instance that determines how the content will blend with content from other 3D objects that overlap this emitter.</p>
<p>In general, the particles will contain transparent content. As such, you will likely want to set the blendFunc property to one of the following:</p>
<ul>
<li>{GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA} - Standard realistic translucent blending.</li>
<li>{GL_SRC_ALPHA, GL_ONE} - Additive blending, to have overlapping particles build on, and intensify, each other</li>
</ul>
<p>For <a class="el" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles.">CC3PointParticleEmitter</a>, the iniital value of the shouldDisableDepthMask property is YES, so that the particles do not enage in Z-fighting with each other. You can experiment with changing this to NO if your emitter is better suited to it.</p>
<p>You can also experiment with the shouldDisableDepthTest and depthFunction properties to see if change them helps you get the look you are trying to achieve.</p>
<p>You can indicate the rate at which particle are emitted by setting either of the emissionRate or emissionInterval properties. You can set for how long the emitter should emit particles using the emissionDuration property.</p>
<p>For emitters with finite duration, you can set the shouldRemoveOnFinish to YES to indicate that the emitter should remove itself automatically from the 3D world, once all particles have expired, cleaning up all memory usage by the emitter and particles along the way. This features allows you to set a transient particle generator, such as an explosion, going and then forget about it.</p>
<p>You can control characteristics about the sizes of the particles, and how that size should change with distance from the camera, using the particleSize, unityScaleDistance, particleSizeAttenuationCoefficients, particleSizeMinimum, and particleSizeMaximum methods properties.</p>
<p>Once you have initialized the emitter with one of the populateForMaxParticles:ofType:... methods, and set whatever emitter properties you need, you can start the emission of particles using the play method. Particle emission can be paused using the pause method, or stopped altogether using the stop method.</p>
<p>If you do not want to have the emitter automatically emit particles, and want to control directly the creation of new particles, simply avoid invoking the play method (and avoid setting the isEmitting property to YES), and invoke the emitParticle method whenever you want to emit a particle.</p>
<p>You should set the boundingVolumeProperty to some non-zero value to help size the boundingVolume of this node so that particles do not disappear prematurely from the edge of the screen. You can verify your settings during development time by setting the shouldDrawLocalContentWireframeBox property to YES to draw a boundingBox around this emitter and all the particles.</p>
<p>By default, the boundingVolume of the emitter will automatically be recalculated every time a particle moves. Although this is convenient and ensures accuracy, recalculating the bounding volume can often be an expensive operation. To avoid this, you can manually set static boundaries in the boundingVolume of this emitter node and then set the shouldUseFixedBoundingVolume property of this emitter to YES to indicate that you don't want the emitter to recalculate its boundingVolume on each update.</p>
<p>You may be wondering how to determine the correct static boundingVolume boundary properties. You can do this at development time by setting the shouldMaximize property of the boundingVolume of the emitter to YES, and setting the shouldUseFixedBoundingVolume property of this emitter to NO, so that the boundingVolume will be recalculated on each update. After the emitter has finished, output the boundingVolume to the log using LogDeubg to record the maximume size that the bounding volume grew to during particle emission. This will give you an idea of how big to set the static boundary properties of the boundingVolume of your emitter.</p>
<p>The implementation of this <a class="el" href="interface_c_c3_point_particle_emitter.html" title="A CC3MeshNode that emits 3D point particles.">CC3PointParticleEmitter</a> class requires that the mesh property is set with an instance of <a class="el" href="interface_c_c3_point_particle_mesh.html" title="A mesh whose vertices are used to display point particles.">CC3PointParticleMesh</a> mesh (or a subclass), which is tailored for point particles. Further, if that mesh contains color or size data for each vertex in addition to location data, the vertex data must be interleaved, and the interleaveData property of the mesh must be set to YES. Generally, you do not have to worry about this, as the correct type of mesh is automatically created and configured when you invoke one of the populateForMaxParticles:ofType:... methods.</p>
<p>All memory used by the particles and the underlying vertex mesh is managed by the emitter node, and is deallocated automatically when the emitter is released. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a42ea51c0f10e51a29b23c2f9b999024a"></a><!-- doxytag: member="CC3PointParticleEmitter::doNotBufferVertexPointSizes" ref="a42ea51c0f10e51a29b23c2f9b999024a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::doNotBufferVertexPointSizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex point size data to be skipped when createGLBuffers is invoked. </p>
<p>The vertex data is not buffered to a GL VBO, is retained in application memory, and is submitted to the GL engine on each frame render.</p>
<p>Only the vertex point sizes will not be buffered to a GL VBO. Any other vertex data, such as locations, or texture coordinates, will be buffered to a GL VBO when createGLBuffers is invoked.</p>
<p>This method causes the vertex data to be retained in application memory, so, if you have invoked this method, you do NOT also need to invoke the retainVertexPointSizes method. </p>

</div>
</div>
<a class="anchor" id="ada104fa3d021a89d7abffcf39ba4707b"></a><!-- doxytag: member="CC3PointParticleEmitter::emitParticle" ref="ada104fa3d021a89d7abffcf39ba4707b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::emitParticle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emits a particle, using the newParticle method, and initializes it. </p>
<p>to initialize each particle, you should override the initializeParticle: template method in a subclass of this class, and/or the initializeParticle method of your <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> subclass.</p>
<p>If the emitter is set to emit particles automatically, by setting an emissionRate or emissionInterval, and then invoking play, you do not need to invoke this method directly. It will be invoked automatically when it is time to emit a particle. This is the most common situation, and so in most cases, you will never invoke this method directly.</p>
<p>However, there are some situations where the application might want more control over the creation of particles. One example might be if you want to create a quantity of fixed particles, such as a chain, or lights on a tree, that are not emitted at a steady rate. Another example might be that you do not want the particles to be emitted at a steady rate.</p>
<p>In these situations, you can avoid invoking play (and avoid setting the isEmitting flag set to YES), and then invoke the emitParticle method whenever you want to create a new particle.</p>
<p>If the number of particles currently alive, as indicated by the value of the particleCount property has reached the maximum number of particls, as indicated by the value of the maxParticles property, this method will do nothing.</p>
<p>This method returns whether the particle was actually emitted. If the maximum number of particles has been reached, or if the particle itself aborts the emission by setting the isAlive property to NO in the initializeParticle method of the particle, this method will return NO, otherwise it will return YES. </p>

</div>
</div>
<a class="anchor" id="a338de77ea16cad1b4f4ad7367633c5ce"></a><!-- doxytag: member="CC3PointParticleEmitter::initializeParticle:" ref="a338de77ea16cad1b4f4ad7367633c5ce" args="(CC3PointParticle *aParticle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::initializeParticle: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_point_particle.html">CC3PointParticle</a> *&#160;</td>
          <td class="paramname"><em>aParticle</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Template method that initializes the particle. </p>
<p>This method is invoked automatically from the emitParticle method just prior to the emission of the specified particle.</p>
<p>This implementation invokes the initializeParticle method of the particle. Emitter subclasses that need to configure a particle before it is emitted can override this method to do so.</p>
<p>This method is invoked automatically by the emitter when a particle is emitted. Usually the application never has need to invoke this method directly. </p>

<p>Implemented in <a class="el" href="interface_c_c3_mortal_point_particle_emitter.html#a8f4bc283444ff694148ffeed41beec39">CC3MortalPointParticleEmitter</a>.</p>

</div>
</div>
<a class="anchor" id="ada3f720d1f73957d898d9fb552ab91ea"></a><!-- doxytag: member="CC3PointParticleEmitter::particleClass" ref="ada3f720d1f73957d898d9fb552ab91ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3PointParticleEmitter::particleClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the class of particle that is usable by this emitter. </p>
<p>Subclasses may tie their behaviour to a particular type (subclass) of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a>, particularly when initializing the state of the particles. The emitter subclass can use this method to return the type of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> it is expecting.</p>
<p>The populateForMaxParticles:ofType:... methods verify that the specified class is correct, and otherwise raise an assertion.</p>
<p>In all cases, subclasses of the returned Class are acceptable.</p>
<p>This implementation returns the generic <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> class. Subclasses that need to restrict the particle type can return a subclass of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a>. </p>

</div>
</div>
<a class="anchor" id="a7042bd13a99e4306764dfc61846bb67a"></a><!-- doxytag: member="CC3PointParticleEmitter::particleSizeAt:" ref="a7042bd13a99e4306764dfc61846bb67a" args="(GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3PointParticleEmitter::particleSizeAt: </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the particle size element at the specified index from the vertex data. </p>
<p>The index refers to elements, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception.</p>
<p>You typically do not use this method directly. Instead, use the size property of the individual particle from within your custom <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> subclass. </p>

</div>
</div>
<a class="anchor" id="a5a88c02ffb182711e0b646c9d16c0050"></a><!-- doxytag: member="CC3PointParticleEmitter::pause" ref="a5a88c02ffb182711e0b646c9d16c0050" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ceases the emission of particles by setting the isEmitting property to NO. </p>
<p>Particles that have already been emitted will continue to be updated and displayed.</p>
<p>Particle emission can be resumed by invoking the play method again.</p>
<p>As an alternate to stopping emission manually, you can set the emissionDuration property to cause particles to be emitted for a finite time and then stop. </p>

</div>
</div>
<a class="anchor" id="afbe06be477058888df012897ff373bd8"></a><!-- doxytag: member="CC3PointParticleEmitter::play" ref="afbe06be477058888df012897ff373bd8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::play </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins, or resumes, the emission of particles by setting the isEmitting property to YES. </p>

</div>
</div>
<a class="anchor" id="a250d4778f0dd70d0406b57e7898c0d00"></a><!-- doxytag: member="CC3PointParticleEmitter::populateForMaxParticles:" ref="a250d4778f0dd70d0406b57e7898c0d00" args="(GLuint maxParticles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::populateForMaxParticles: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>maxParticles</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares this emitter to manage the specified maximum number of simultaneous particles, each to be instantiated from the class returned by the particleClass method, and containing only the mandatory particle location drawable content. </p>
<p>Memory will be allocated for the specified number of point-particle vertices, each containing the specified particle content.</p>
<p>The texture used to draw each point particle is set using the texture property of this emitter. </p>

</div>
</div>
<a class="anchor" id="ad64029271feb5ef5d8f35ad6a0006462"></a><!-- doxytag: member="CC3PointParticleEmitter::populateForMaxParticles:containing:" ref="ad64029271feb5ef5d8f35ad6a0006462" args="(GLuint numParticles,[containing] CC3PointParticleVertexContent contentTypes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::populateForMaxParticles:containing: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[containing] <a class="el" href="_c_c3_point_particles_8h.html#a618528ed4a53a0b3e2a8b3904eb89d25">CC3PointParticleVertexContent</a>&#160;</td>
          <td class="paramname"><em>contentTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares this emitter to manage the specified maximum number of simultaneous particles, each to be instantiated from the class returned by the particleClass method, and containing the specified drawable content in each particle, in addition to the mandatory particle location content. </p>
<p>The contentTypes parameter is a bitwise-OR of zero or more CC3PointParticleVertexContent values. For example, a value for contentTypes of (kCC3PointParticleContentColor | kCC3PointParticleContentSize) indicates that each particle will be drawn using location, color and size information.</p>
<p>Permitted components for this parameter include:</p>
<ul>
<li>kCC3PointParticleContentLocation</li>
<li>kCC3PointParticleContentNormal</li>
<li>kCC3PointParticleContentColor</li>
<li>kCC3PointParticleContentSize</li>
</ul>
<p>Since location content is mandatory, the kCC3PointParticleContentLocation does not need to be included in the contentTypes bit-map.</p>
<p>For example, a value of (kCC3PointParticleContentColor | kCC3PointParticleContentSize) indicates that each particle vertex will be drawn using location, color and size data.</p>
<p>If kCC3PointParticleContentColor is included, each particle may have its own color. If kCC3PointParticleContentSize is included, each particle may have its own size. If kCC3PointParticleContentNormal is included, each particle will individually interact with light sources, otherwise they will ignore lighting, and the shouldUseLighting</p>
<p>Memory will be allocated for the specified number of point-particle vertices, each containing the specified particle content.</p>
<p>The texture used to draw each point particle is set using the texture property of this emitter. </p>

</div>
</div>
<a class="anchor" id="a3eac24110f8c1869ae18e7932245250d"></a><!-- doxytag: member="CC3PointParticleEmitter::populateForMaxParticles:ofType:" ref="a3eac24110f8c1869ae18e7932245250d" args="(GLuint maxParticles,[ofType] id aParticleClass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::populateForMaxParticles:ofType: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>maxParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[ofType] id&#160;</td>
          <td class="paramname"><em>aParticleClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares this emitter to manage the specified maximum number of simultaneous particles, each to be instantiated from the specified class, and containing only the mandatory particle location drawable content. </p>
<p>The aParticleClass parameter must be a Class that is a subclass of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a>. It is not an instance of a <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> subclass. You would typically specify this parameter as [MyPointParticleSubclass class].</p>
<p>Memory will be allocated for the specified number of point-particle vertices, each containing the specified particle content.</p>
<p>The texture used to draw each point particle is set using the texture property of this emitter. </p>

</div>
</div>
<a class="anchor" id="a23364537ecdad0a7f55b14bf463fe766"></a><!-- doxytag: member="CC3PointParticleEmitter::populateForMaxParticles:ofType:containing:" ref="a23364537ecdad0a7f55b14bf463fe766" args="(GLuint numParticles,[ofType] id aParticleClass,[containing] CC3PointParticleVertexContent contentTypes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::populateForMaxParticles:ofType:containing: </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>numParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[ofType] id&#160;</td>
          <td class="paramname"><em>aParticleClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[containing] <a class="el" href="_c_c3_point_particles_8h.html#a618528ed4a53a0b3e2a8b3904eb89d25">CC3PointParticleVertexContent</a>&#160;</td>
          <td class="paramname"><em>contentTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepares this emitter to manage the specified maximum number of simultaneous particles, each to be instantiated from the specified class, and containing the specified drawable content in each particle, in addition to the mandatory particle location content. </p>
<p>The aParticleClass parameter must be a Class that is a subclass of the Class returned by the particleClass method. This argument is not an instance of that class. You would typically specify this parameter as [MyPointParticleSubclass class].</p>
<p>The contentTypes parameter is a bitwise-OR of zero or more CC3PointParticleVertexContent values. For example, a value for contentTypes of (kCC3PointParticleContentColor | kCC3PointParticleContentSize) indicates that each particle will be drawn using location, color and size information.</p>
<p>Permitted components for this parameter include:</p>
<ul>
<li>kCC3PointParticleContentLocation</li>
<li>kCC3PointParticleContentNormal</li>
<li>kCC3PointParticleContentColor</li>
<li>kCC3PointParticleContentSize</li>
</ul>
<p>Since location content is mandatory, the kCC3PointParticleContentLocation does not need to be included in the contentTypes bit-map.</p>
<p>For example, a value of (kCC3PointParticleContentColor | kCC3PointParticleContentSize) indicates that each particle vertex will be drawn using location, color and size data.</p>
<p>If kCC3PointParticleContentColor is included, each particle may have its own color. If kCC3PointParticleContentSize is included, each particle may have its own size. If kCC3PointParticleContentNormal is included, each particle will individually interact with light sources, otherwise they will ignore lighting, and the shouldUseLighting</p>
<p>Memory will be allocated for the specified number of point-particle vertices, each containing the specified particle content.</p>
<p>The texture used to draw each point particle is set using the texture property of this emitter. </p>

</div>
</div>
<a class="anchor" id="abb9ec8bbdc7a40985565bb1dadb201a7"></a><!-- doxytag: member="CC3PointParticleEmitter::retainVertexPointSizes" ref="abb9ec8bbdc7a40985565bb1dadb201a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::retainVertexPointSizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience method to cause the vertex point size data to be retained in application memory when releaseRedundantData is invoked, even if it has been buffered to a GL VBO. </p>
<p>Only the vertex point sizes will be retained. Any other vertex data, such as locations, or texture coordinates, that has been buffered to GL VBO's, will be released from application memory when releaseRedundantData is invoked.</p>
<p>This method is invoked automatically by the populateForMaxParticles:ofType:... method, if needed. Usually, the application should never have need to invoke this method directly. </p>

</div>
</div>
<a class="anchor" id="aa37fe8fe898c05d8cf44223a685cb381"></a><!-- doxytag: member="CC3PointParticleEmitter::setParticleSize:at:" ref="aa37fe8fe898c05d8cf44223a685cb381" args="(GLfloat aSize,[at] GLsizei index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::setParticleSize:at: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>aSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[at] GLsizei&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the particle size element at the specified index in the vertex data to the specified value. </p>
<p>The index refers to elements, not bytes. The implementation takes into consideration the elementStride and elementOffset properties to access the correct element.</p>
<p>When all vertex changes have been made, be sure to invoke the updateParticleSizesGLBuffer method to ensure that the GL VBO that holds the vertex data is updated.</p>
<p>If the releaseRedundantData method has been invoked and the underlying vertex data has been released, this method will raise an assertion exception.</p>
<p>You typically do not use this method directly. Instead, use the size property of the individual particle from within your custom <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> subclass. </p>

</div>
</div>
<a class="anchor" id="a9712038dfe3527cb2d8e3e57ba16a20b"></a><!-- doxytag: member="CC3PointParticleEmitter::stop" ref="a9712038dfe3527cb2d8e3e57ba16a20b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ceases the emission of particles by setting the isEmitting property to NO. </p>
<p>Particles that have already been emitted will no longer be updated and displayed, effectively causing those particles to abruptly disappear from view.</p>
<p>Particle emission can be restarted by invoking the play method again.</p>
<p>In most cases, for best visual effect, you should use the pause method instead to stop the emission of of new particles, but allow those that have already been emitted to live out their lives.</p>
<p>As an alternate to stopping emission manually, you can set the emissionDuration property to cause particles to be emitted for a finite time and then stop. </p>

</div>
</div>
<a class="anchor" id="a4fb6508b314eb48e88529a09d7b53365"></a><!-- doxytag: member="CC3PointParticleEmitter::updateParticleSizesGLBuffer" ref="a4fb6508b314eb48e88529a09d7b53365" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3PointParticleEmitter::updateParticleSizesGLBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the GL engine buffer with the particle size data in this mesh. </p>
<p>For particle emitters, this method is invoked automatically when particles have been updated from within your <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> subclass. Usually, the application should never have need to invoke this method directly. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a137a3310525a56a8971c2981e21799a6"></a><!-- doxytag: member="CC3PointParticleEmitter::elapsedTime" ref="a137a3310525a56a8971c2981e21799a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTime CC3PointParticleEmitter::elapsedTime<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For emitters with a finite emissionDuration, indicates the length of time that this emitter has been emitting particles. </p>
<p>When the value of this property exceeds the value of the emissionDuration property, the pause method is automatically invoked to cease the emission of particles. </p>

</div>
</div>
<a class="anchor" id="a054cbdfa4eb587be1f371ce8ba0f0a1b"></a><!-- doxytag: member="CC3PointParticleEmitter::emissionDuration" ref="a054cbdfa4eb587be1f371ce8ba0f0a1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTime CC3PointParticleEmitter::emissionDuration<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates the length of time that the emitter will emit particles. </p>
<p>Setting this value to kCC3ParticleInfiniteDuration indicates that the emitter should continue to emit particles forever, or until the pause or stop method are invoked, or until isEmitting is manually set to NO.</p>
<p>The initial value is kCC3ParticleInfiniteDuration. </p>

</div>
</div>
<a class="anchor" id="aec8e1fdb0981cc21e0dcaef41130eb03"></a><!-- doxytag: member="CC3PointParticleEmitter::emissionInterval" ref="aec8e1fdb0981cc21e0dcaef41130eb03" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ccTime CC3PointParticleEmitter::emissionInterval<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The interval between each emission of a particle, expressed in seconds. </p>
<p>You can use this property as an alternate to the emissionRate property.</p>
<p>Emission begins when the play method is invoked.</p>
<p>The initial value of this property is kCC3ParticleInfiniteDuration, indicating that no particles will be automatically emitted.</p>
<p>As an alternate to setting this property to engage automatic emission, you can leave this property at its initial value and manually invoke the emitParticle method whenever you determine that you want to emit a particle. </p>

</div>
</div>
<a class="anchor" id="a9a59b4f66d70ebd3657d3e62848d4cb7"></a><!-- doxytag: member="CC3PointParticleEmitter::emissionRate" ref="a9a59b4f66d70ebd3657d3e62848d4cb7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3PointParticleEmitter::emissionRate<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The rate that particles will be emitted, expressed in particles per second. </p>
<p>You can use this property as an alternate to the emissionInterval property.</p>
<p>Emission begins when the play method is invoked.</p>
<p>The initial value of this property is zero, indicating that no particles will be automatically emitted.</p>
<p>As an alternate to setting this property to engage automatic emission, you can leave this property at its initial value and manually invoke the emitParticle method whenever you determine that you want to emit a particle. </p>

</div>
</div>
<a class="anchor" id="afaddd85c3dab13597d045b2b4017990a"></a><!-- doxytag: member="CC3PointParticleEmitter::isActive" ref="afaddd85c3dab13597d045b2b4017990a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::isActive<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this emitter is active. </p>
<p>It is active if either particles are currently being emitted, or particles have been emitted but have not yet lived out their lives.</p>
<p>Formally, this property returns YES if either the isEmitting property returns YES or the value of the particleCount property is greater than zero. Otherwise this property returns NO.</p>
<p>The stop method can be used to force this emitter to be immediately inactive. </p>

</div>
</div>
<a class="anchor" id="acbb46f18f0c2788b20bda2f715109ada"></a><!-- doxytag: member="CC3PointParticleEmitter::isEmitting" ref="acbb46f18f0c2788b20bda2f715109ada" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::isEmitting<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the emitter is currently emitting particles. </p>
<p>For emitters with a finite emissionDuration, the value of this property will automatically be set to NO once that emissionDuration has passed.</p>
<p>For emitters with infinite emissionDuration, or for emitters with a finite emissionDuration that has not yet passed, setting the value of this property to NO will stop the emitter from emitting any further particles.</p>
<p>Emission can be started or restarted by setting this property to YES. </p>

</div>
</div>
<a class="anchor" id="a51622d5e4eec07a42304f6a1870ea610"></a><!-- doxytag: member="CC3PointParticleEmitter::isFinished" ref="a51622d5e4eec07a42304f6a1870ea610" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::isFinished<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether particle emission has ceased and all particles have lived out their lives. </p>
<p>This will only return YES if all of the following activities have occurred:</p>
<ul>
<li>The play method was previously invoked, or the isEmitting property was set to YES.</li>
<li>The emissionDuration has elapsed or the pause method was invoked.</li>
<li>All particles have been marked as no longer alive within their update: method.</li>
</ul>
<p>The stop method can be used to short-circuit the last two activities. </p>

</div>
</div>
<a class="anchor" id="aed759b0b275d8e6f247d6f152e928e61"></a><!-- doxytag: member="CC3PointParticleEmitter::isFull" ref="aed759b0b275d8e6f247d6f152e928e61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::isFull<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the maximum number of particles has been reached. </p>
<p>This occurs when the value of the particleCount property reaches the value of the maxParticles property. When this occurs, no further particles will be emitted until some particles expire. </p>

</div>
</div>
<a class="anchor" id="a78bdd37ec092adf16d828c3797b263ad"></a><!-- doxytag: member="CC3PointParticleEmitter::maxParticles" ref="a78bdd37ec092adf16d828c3797b263ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint CC3PointParticleEmitter::maxParticles<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum number of particles that will be alive at any one time in the particle system managed by this emitter. </p>
<p>The value of this property is set when one of the populateForMaxParticles:... methods is invoked.</p>
<p>This does not define the maximum number of particles that can be emitted over time. As particles age, you can indicate that a particle has expired by setting the isAlive property of the <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> to NO in the update: method of the particle. This frees up that particle to be re-initialized and re-emitted.</p>
<p>The value of this property defines the amount of memory that will be allocated for particles, and their specifications, used by this emitter. When this emitter is deallocated, that memory will automatically be released. </p>

</div>
</div>
<a class="anchor" id="a85816caf390b37751deaf059e7454a5c"></a><!-- doxytag: member="CC3PointParticleEmitter::particleClass" ref="a85816caf390b37751deaf059e7454a5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3PointParticleEmitter::particleClass<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The customized subclass of <a class="el" href="interface_c_c3_point_particle.html" title="CC3PointParticle is an abstract class that represents a single particle emitted by a CC3PointParticle...">CC3PointParticle</a> used to instantiate new particles that are emitted by this emitter. </p>
<p>This property is initially set by the populateForMaxParticles:... method, and you generally would never change it. However, it is possible to change this property at any time in order to have the emitter emit different types of particles during its lifetime. All of these particles will have to use the same texture, but might enage different behaviours to control their paths or life-cycles. </p>

</div>
</div>
<a class="anchor" id="a81ab56ee34c5382736b379e51064a479"></a><!-- doxytag: member="CC3PointParticleEmitter::particleContentTypes" ref="a81ab56ee34c5382736b379e51064a479" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_c3_point_particles_8h.html#a618528ed4a53a0b3e2a8b3904eb89d25">CC3PointParticleVertexContent</a> CC3PointParticleEmitter::particleContentTypes<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The map of additional types of vertex content, in addtion to the mandatory vertex location content. </p>
<p>The value is a bit-map constructed by OR-ing together zero or more of the following CC3PointParticleVertexContent values:</p>
<ul>
<li>kCC3PointParticleContentNormal</li>
<li>kCC3PointParticleContentColor</li>
<li>kCC3PointParticleContentSize</li>
</ul>
<p>Since location content is mandatory, the kCC3PointParticleContentLocation indicator will not appear in the bit-map in this property.</p>
<p>For example, a value of (kCC3PointParticleContentColor | kCC3PointParticleContentSize) indicates that each particle vertex will be drawn using location, color and size data.</p>
<p>The value of this property is set by invoking one of the populateForMaxParticles:... methods. </p>

</div>
</div>
<a class="anchor" id="a4680550a122959c165b0f14063cd1a0b"></a><!-- doxytag: member="CC3PointParticleEmitter::particleCount" ref="a4680550a122959c165b0f14063cd1a0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint CC3PointParticleEmitter::particleCount<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of particles that are currently alive and being displayed by this emitter. </p>
<p>The value of this property will increase as particles are emitted, and will decrease as particles age and expire. </p>

</div>
</div>
<a class="anchor" id="ae41d7261e24a8dc4e262ca20ba23a540"></a><!-- doxytag: member="CC3PointParticleEmitter::particleMesh" ref="ae41d7261e24a8dc4e262ca20ba23a540" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_c_c3_point_particle_mesh.html">CC3PointParticleMesh</a>* CC3PointParticleEmitter::particleMesh<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The <a class="el" href="interface_c_c3_mesh.html" title="A CC3Mesh holds the 3D mesh for a CC3MeshNode.">CC3Mesh</a> used by this node, cast as a <a class="el" href="interface_c_c3_point_particle_mesh.html" title="A mesh whose vertices are used to display point particles.">CC3PointParticleMesh</a>, for convenience in accessing the additional behavour available to support particle vertices. </p>

</div>
</div>
<a class="anchor" id="a2cf9e00aa8d026851fa2db663f5862bc"></a><!-- doxytag: member="CC3PointParticleEmitter::particles" ref="a2cf9e00aa8d026851fa2db663f5862bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CCArray * CC3PointParticleEmitter::particles<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The array of particles. </p>
<p>The value of this property will be nil until the array is created by invoking one of the populateForMaxParticles:... methods. </p>

</div>
</div>
<a class="anchor" id="a0abab9370c3aeae50b71574f816d2b44"></a><!-- doxytag: member="CC3PointParticleEmitter::particleSize" ref="a0abab9370c3aeae50b71574f816d2b44" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3PointParticleEmitter::particleSize<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the kCC3PointParticleContentSize component was not specified in the populateForMaxParticles:... </p>
<p>method, all particles will be emitted at the same size, which is specified by this property.</p>
<p>If the kCC3PointParticleContentSize component was specified, the size of each particle can be individually set during the initialization of that particle. The size of each particle defaults to this value, if not set to something else during its initialization.</p>
<p>The initial value is kCC3DefaultParticleSize. </p>

</div>
</div>
<a class="anchor" id="a59498a12883ea05195a688a36aad1a97"></a><!-- doxytag: member="CC3PointParticleEmitter::particleSizeAttenuationCoefficients" ref="a59498a12883ea05195a688a36aad1a97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_attenuation_coefficients.html">CC3AttenuationCoefficients</a> CC3PointParticleEmitter::particleSizeAttenuationCoefficients<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The coefficients of the attenuation function that affects the size of a particle based on its distance from the camera. </p>
<p>The sizes of the particles are attenuated according to the formula 1/sqrt(a + (b * r) + (c * r * r)), where r is the radial distance from the particle to the camera, and a, b and c are the coefficients from this property.</p>
<p>As an alternate to setting this property, you can set the unityScaleDistance property to establish standard proportional distance attenuation.</p>
<p>The initial value of this property is kCC3ParticleSizeAttenuationNone, indicating no attenuation with distance. </p>

</div>
</div>
<a class="anchor" id="a09be9c460f38d64f8013d3bafff56a3c"></a><!-- doxytag: member="CC3PointParticleEmitter::particleSizeMaximum" ref="a09be9c460f38d64f8013d3bafff56a3c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3PointParticleEmitter::particleSizeMaximum<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maxiumum size for point particles. </p>
<p>Particle sizes will not be allowed to grow below this value when distance attenuation is engaged.</p>
<p>You can use this property to limit how large particles will become as they approach the camera.</p>
<p>The initial value of this property is kCC3ParticleSizeMaximumNone, indicating that particles will be allowed to grow until clamped by any platform limits. </p>

</div>
</div>
<a class="anchor" id="a5801f18cdfb1517d4c514623ab8b9346"></a><!-- doxytag: member="CC3PointParticleEmitter::particleSizeMinimum" ref="a5801f18cdfb1517d4c514623ab8b9346" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3PointParticleEmitter::particleSizeMinimum<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The miniumum size for point particles. </p>
<p>Particle sizes will not be allowed to shrink below this value when distance attenuation is engaged.</p>
<p>You can use this property to limit how small particles will become as they recede from the camera.</p>
<p>The initial value of this property is kCC3ParticleSizeMinimumNone, indicating that particles will be allowed to shrink to one pixel if needed. </p>

</div>
</div>
<a class="anchor" id="af7c664a560b2791ade34a44fe26f41ee"></a><!-- doxytag: member="CC3PointParticleEmitter::shouldNormalizeParticleSizesToDevice" ref="af7c664a560b2791ade34a44fe26f41ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::shouldNormalizeParticleSizesToDevice<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether the particle sizes should be adjusted so that particles appear to be a consistent size across all device screen resolutions. </p>
<p>The 3D camera frustum is consistent across all devices, making the view of the 3D scene consistent across all devices. However, particle size is defined in terms of pixels, and particles will appear larger or smaller. relative to 3D artifacts, on different screen resolutions.</p>
<p>If this property is set to YES, the actual size of each particle, as submitted to the GL engine, will be adjusted so that it appears to be the same size across all devices, relative to the 3D nodes.</p>
<p>If this property is set to NO, the actual size of each particle will be drawn in the same absolute pixel size across all devices, which may make it appear to be smaller or larger, relative to the 3D artifacts around it, on different devices.</p>
<p>The initial value of this property is YES. </p>

</div>
</div>
<a class="anchor" id="a50c6cbfc9e94295bf7bff6db629b229b"></a><!-- doxytag: member="CC3PointParticleEmitter::shouldRemoveOnFinish" ref="a50c6cbfc9e94295bf7bff6db629b229b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::shouldRemoveOnFinish<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates that this emitter should automatically be removed from its parent, and from the 3D world when it is finished (once the isFinished turns to YES). </p>
<p>The initial value of this property is NO. </p>

</div>
</div>
<a class="anchor" id="a0d53b25af3632108f7f5f8b98b96977b"></a><!-- doxytag: member="CC3PointParticleEmitter::shouldSmoothPoints" ref="a0d53b25af3632108f7f5f8b98b96977b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3PointParticleEmitter::shouldSmoothPoints<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether points should be smoothed (antialiased). </p>
<p>The initial value is NO. </p>

</div>
</div>
<a class="anchor" id="ae3a1a4eb49f322aeb2bd7f16ee1f1de0"></a><!-- doxytag: member="CC3PointParticleEmitter::unityScaleDistance" ref="ae3a1a4eb49f322aeb2bd7f16ee1f1de0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat CC3PointParticleEmitter::unityScaleDistance<code> [read, write, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The distance from the camera, in 3D space, at which the particle will be displayed at unity scale (its natural size). </p>
<p>The value of this property defines how the apparent size of the particle will change as it moves closer to, or farther from, the camera. If the particle is closer to the camera than this distance, the particle will appear proportionally larger than its natural size, and if the particle is farther away from the camera than this distance, the particle will appear proportionally smaller than its natural size.</p>
<p>The natural size of the particle is expressed in pixels and is set either by the particleSize property of this emitter, or by the size property of the individual particle if the particleContentTypes property of this emitter includes the kCC3PointParticleContentSize value.</p>
<p>Setting the value of this property to zero indicates that the size of the particles should stay constant, at their natural size, regardless of how far the particle is from the camera.</p>
<p>Setting this property replaces the need to set the value of the particleSizeAttenuationCoefficients property, which is more complicated to use, but offers a wider range of distance attenuation options.</p>
<p>The initial value of this property is zero, indicating that distance attenuation is not applied, and each particle will appear at its natural size regardless of how far it is from the camera. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_point_particles_8h.html">CC3PointParticles.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_point_particle_emitter.html">CC3PointParticleEmitter</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:10 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
