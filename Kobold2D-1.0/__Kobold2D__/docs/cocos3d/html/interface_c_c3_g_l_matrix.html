<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cocos3d: CC3GLMatrix Interface Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">cocos3d
   &#160;<span id="projectnumber">0.6.3</span>
   </div>
   <div id="projectbrief">Cocos3D API Reference for <a href="http://www.kobold2d.com">Kobold2D</a> developers</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interface_c_c3_g_l_matrix.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">CC3GLMatrix Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CC3GLMatrix" -->
<p><code>#include &lt;CC3GLMatrix.h&gt;</code></p>

<p><a href="interface_c_c3_g_l_matrix-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a594af1b372f4988df4e9cd0f5ca6fb86">extractForwardDirection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a04145aec5a33656c41d767ce4e3e3290">extractQuaternion</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a9866ac7f8f6dc4efdd238dfffafd0223">extractRightDirection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#af158388891c813c27ce6d650eb36aba9">extractRotation</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a73adc27e1d160763a02835a9af5982b4">extractUpDirection</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a5b3a666897bb69a0044ae5cb9a321443">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a35c620bd2a3f6d48e932c5192f0c9a43">initFromGLMatrix:</a> (GLfloat *aGLMtx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ab8cd3a95725332c9455b091fad1fdb7b">initIdentity</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a3001711bb027bec7ff6fd5aa66e83bb0">initOnGLMatrix:</a> (GLfloat *aGLMtx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#afbfdab6ee142333b8c85026e951f2a5b">initWithElements:</a> (GLfloat e00,[,]...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a8c289e7e4c890bbdeac5f04aeac57ef0">invert</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aebaacef6a99b5aaf32e9e14c7f847943">invertAffine</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a031643d629aeb5bf3b512cfa94a0a449">invertRigid</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#af5a858977bf47dfa292446b59e03b515">leftMultiplyByMatrix:</a> (<a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *aMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a1279d3b7c25dd48f88634bc61240a734">multiplyByMatrix:</a> (<a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *aMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a151890a3ff0a35fb24d700d61584c756">populateFrom:</a> (<a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *aMtx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a559996fd7610741f1f526367e8bd3014">populateFromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:</a> (GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a5357cfa424b9571f307f43b287c8a7d4">populateFromGLMatrix:</a> (GLfloat *aGLMtx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a954d52b8b860adbd73ca40deb168bb94">populateFromQuaternion:</a> (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> aQuaternion)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aad800f66966ba6d7637a0f56be296c81">populateFromRotation:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#afa76b8936fa194b1ae8b7f9ed0b96ee9">populateFromScale:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a15cdf556c246f4102561270d42719470">populateFromTranslation:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aef13fa0c6dcf83c09a03aa7251543119">populateIdentity</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a13760ce846b6594eb38b8a921235f1a9">populateOrthoFromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:</a> (GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a3907fcfc6174ebf29c12020a1e6667e4">populateToLookAt:withEyeAt:withUp:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> targetLocation,[withEyeAt] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> eyeLocation,[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> upDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ae4c25be98db908c1557ded9db9cd1ca2">populateToPointTowards:withUp:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> fwdDirection,[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> upDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a64cec56a8c38c471ada687c88106d73a">populateZero</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aa36818d5fafa8b2d47d973a5a18b4442">rotateBy:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a1d568e50e2af9dafd19fa09ea6f5b00f">rotateByQuaternion:</a> (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> aQuaternion)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a8457abfa6c5264a4cb2a0067deb493b1">rotateByX:</a> (GLfloat degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a85d7e2467984a6b9b8b02717f7328de4">rotateByY:</a> (GLfloat degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a388d3f1cf67a98f8ab557a66e4c3f2c7">rotateByZ:</a> (GLfloat degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a37aaba903ed8be0426fcdb4c228052e2">scaleBy:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ace88e0add8dfed5575e8421ed4b8eb56">scaleByX:</a> (GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a1d160af5bbef8313b10fad53c6b40cde">scaleByY:</a> (GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#adaf438e0f5e3413c50f6fc87b55fa94b">scaleByZ:</a> (GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a806f04e72472ab49db9c3104ea77368a">scaleUniformlyBy:</a> (GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#afc70fb7e4b017c0ccf81cedd6a2e0641">transformDirection:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a91f8d25c482b68da9077a383ee31ccad">transformHomogeneousVector:</a> (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a070e8fafc0dac92e7ff2d0544771f40f">transformLocation:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aLocation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a0f5c6b1724592b97b24d0777ea867f93">translateBy:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a895eb121083298cf7c32a680d284f436">translateBy:rotateBy:scaleBy:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> translationVector,[rotateBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> rotationVector,[scaleBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> scaleVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ab7a6fcc39f5894743fcdf8ef5b15272b">translateByX:</a> (GLfloat distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aa3e92638532b0edb07f866a8695240c1">translateByY:</a> (GLfloat distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a94cc218bfa5f67b1992b33a9b947d4dc">translateByZ:</a> (GLfloat distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a89f2cc2b10e43e1f8e8efd3801b40128">transpose</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a3b05b5e0793929fe745bf4c8f26129f5">copyMatrix:into:</a> (GLfloat *srcGLMatrix,[into] GLfloat *destGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a7508e92e9446cd2bf981e611e950fa81">extractForwardDirectionFrom:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aef6d36cde1d653fe65eed0888a95366c">extractQuaternionFromMatrix:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a8eb10c1a85f9b656418a687ebf94aaaf">extractRightDirectionFrom:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#af7facf8173c81ec1de4d5f58726ba152">extractRotationYXZFromMatrix:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ade373e3117386ca344e4b8907b0788dc">extractRotationZYXFromMatrix:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ac1e2f2abdb6330ae2ee26817d5989f71">extractUpDirectionFrom:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#acc74e53ddfbe78d2fa0eaeccb14bc79e">identity</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a6c2d5aef577e09e4d538902f75509a73">invert:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#abf04457213de23d46c4a83e7d0b7733c">invertAffine:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a77c6d1f3521f938932d5181cb6154484">invertRigid:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a2532bfcbbd22650beff3698a3bc7988b">leftMultiply:byMatrix:</a> (GLfloat *aGLMatrix,[byMatrix] GLfloat *anotherGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a81c9d09b678a0700a0abd3df3f9b2f81">matrix</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a8efc53a90d23e62224486fe7f8b6ce7a">matrixFromGLMatrix:</a> (GLfloat *aGLMtx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a05a58a6fccebf116ea8a11d11a1b5d8b">matrixOnGLMatrix:</a> (GLfloat *aGLMtx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ad0fde0dbe8964dbb37456b672c5bec59">matrixWithElements:</a> (GLfloat e00,[,]...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#af66a22a46875bcddf05507682f7cf0f5">multiply:byMatrix:</a> (GLfloat *aGLMatrix,[byMatrix] GLfloat *anotherGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a727d057d13dc57439c279a5c9f128b14">populate:fromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:</a> (GLfloat *aGLMatrix,[fromFrustumLeft] GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#acba047c2f851fcf4810448125637632f">populate:toLookAt:withEyeAt:withUp:</a> (GLfloat *aGLMatrix,[toLookAt] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> targetLocation,[withEyeAt] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> eyeLocation,[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> upDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a1284b1f473ebd48e7592ffe2ff5b8391">populate:toPointTowards:withUp:</a> (GLfloat *aGLMatrix,[toPointTowards] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> fwdDirection,[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> upDirection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a767d98b77fe022014d2e23d8efcdf99a">populateOrtho:fromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:</a> (GLfloat *aGLMatrix,[fromFrustumLeft] GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#add7e134bd1fd8483385b4a236291568b">rotate:byQuaternion:</a> (GLfloat *aGLMatrix,[byQuaternion] <a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> aQuaternion)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aa16e7cc6e951edf57fa4fe786662e370">rotate:byX:</a> (GLfloat *aGLMatrix,[byX] GLfloat degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a1bdec1ecbb5f1784c97fc662a2b930d0">rotate:byY:</a> (GLfloat *aGLMatrix,[byY] GLfloat degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ad7e2cbbfe9c615254fc24cbdf424e71c">rotate:byZ:</a> (GLfloat *aGLMatrix,[byZ] GLfloat degrees)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a6bd3bd8024eab258e85b30f14b10211f">rotateYXZ:by:</a> (GLfloat *aGLMatrix,[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aRotation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a0de5a4e324d38376187712742b11604f">rotateZYX:by:</a> (GLfloat *aGLMatrix,[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aRotation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a420d0548f6f8475a20a42f3298683484">scale:by:</a> (GLfloat *aGLMatrix,[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#af7063a8c67a2a43687ac887a23a38ccb">scale:byX:</a> (GLfloat *aGLMatrix,[byX] GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ac5db3545e11a21e38764ef9cc16f752c">scale:byY:</a> (GLfloat *aGLMatrix,[byY] GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#aa1288fadee0fee4292db280e6ec7c1a6">scale:byZ:</a> (GLfloat *aGLMatrix,[byZ] GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a44c60d64f0a74524ec59830427e3e96e">scale:uniformlyBy:</a> (GLfloat *aGLMatrix,[uniformlyBy] GLfloat scaleFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a47bb4a2109857ee8915520d1a9178bbb">transform:translateBy:rotateBy:scaleBy:</a> (GLfloat *aGLMatrix,[translateBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aTranslation,[rotateBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aRotation,[scaleBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aScale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#acbe6474a29eff1a5b4bb1ca403efb16f">transformDirection:withMatrix:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aDirection,[withMatrix] GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#adda956162c85ae5004dfcc4fdaf90a6c">transformHomogeneousVector:withMatrix:</a> (<a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> aVector,[withMatrix] GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a0ea2431314fe4861c898d3dff4dbb948">transformLocation:withMatrix:</a> (<a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aLocation,[withMatrix] GLfloat *aGLMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a0ff99eef841b459fd4d09f7f989ef4a8">translate:by:</a> (GLfloat *aGLMatrix,[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a> aVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a15e2ace10f171c04fbd6c6d2b39f98b4">translate:byX:</a> (GLfloat *aGLMatrix,[byX] GLfloat distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a1525cb082bf9b581905cc977475d1242">translate:byY:</a> (GLfloat *aGLMatrix,[byY] GLfloat distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a57a3fc704259e966e5019e8b753767a2">translate:byZ:</a> (GLfloat *aGLMatrix,[byZ] GLfloat distance)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a0cd39eb8c54e3dcd5b211ad41327a7b1">transpose:</a> (GLfloat *aGLMatrix)</td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GLfloat *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#a25383bc486461a0b2ad8acffe5f76448">glMatrix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_c_c3_g_l_matrix.html#ae16ba83352ed7b4ff4d6bfed48fd6b30">isIdentity</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A wrapper class for a 4x4 OpenGL matrix array. </p>
<p>This matrix wrapper is implemented as a class cluster design pattern. Different concrete implementation classes are provided to handle different underlying matrix data storage requirements. You do not need to be aware of the concrete classes, which aare selected and instantiated automatically by the class allocation methods. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3b05b5e0793929fe745bf4c8f26129f5"></a><!-- doxytag: member="CC3GLMatrix::copyMatrix:into:" ref="a3b05b5e0793929fe745bf4c8f26129f5" args="(GLfloat *srcGLMatrix,[into] GLfloat *destGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::copyMatrix:into: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>srcGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[into] GLfloat *&#160;</td>
          <td class="paramname"><em>destGLMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies all data from the source matrix to the destination matrix. </p>
<p>Both matrices must be a standard 4x4 OpenGL matrices in column-major order. </p>

</div>
</div>
<a class="anchor" id="a594af1b372f4988df4e9cd0f5ca6fb86"></a><!-- doxytag: member="CC3GLMatrix::extractForwardDirection" ref="a594af1b372f4988df4e9cd0f5ca6fb86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractForwardDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts and returns the 'forward' direction vector from the rotation component of this matrix. </p>

</div>
</div>
<a class="anchor" id="a7508e92e9446cd2bf981e611e950fa81"></a><!-- doxytag: member="CC3GLMatrix::extractForwardDirectionFrom:" ref="a7508e92e9446cd2bf981e611e950fa81" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractForwardDirectionFrom: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts and returns the 'forward' direction vector from the rotation component of the specified matrix. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a04145aec5a33656c41d767ce4e3e3290"></a><!-- doxytag: member="CC3GLMatrix::extractQuaternion" ref="a04145aec5a33656c41d767ce4e3e3290" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> CC3GLMatrix::extractQuaternion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the rotation component of this matrix and returns it as a quaternion. </p>

</div>
</div>
<a class="anchor" id="aef6d36cde1d653fe65eed0888a95366c"></a><!-- doxytag: member="CC3GLMatrix::extractQuaternionFromMatrix:" ref="aef6d36cde1d653fe65eed0888a95366c" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> CC3GLMatrix::extractQuaternionFromMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the rotation component of the specified matrix and returns it as a quaternion. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a9866ac7f8f6dc4efdd238dfffafd0223"></a><!-- doxytag: member="CC3GLMatrix::extractRightDirection" ref="a9866ac7f8f6dc4efdd238dfffafd0223" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractRightDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts and returns the 'right' direction vector from the rotation component of this matrix. </p>

</div>
</div>
<a class="anchor" id="a8eb10c1a85f9b656418a687ebf94aaaf"></a><!-- doxytag: member="CC3GLMatrix::extractRightDirectionFrom:" ref="a8eb10c1a85f9b656418a687ebf94aaaf" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractRightDirectionFrom: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts and returns the 'right' direction vector from the rotation component of the specified matrix. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="af158388891c813c27ce6d650eb36aba9"></a><!-- doxytag: member="CC3GLMatrix::extractRotation" ref="af158388891c813c27ce6d650eb36aba9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the rotation component of this matrix and returns it as an Euler rotation vector, assuming the rotations should be applied in YXZ order, which is the OpenGL default. </p>
<p>Each element of the returned rotation vector represents an Euler angle in degrees. </p>

</div>
</div>
<a class="anchor" id="af7facf8173c81ec1de4d5f58726ba152"></a><!-- doxytag: member="CC3GLMatrix::extractRotationYXZFromMatrix:" ref="af7facf8173c81ec1de4d5f58726ba152" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractRotationYXZFromMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the rotation component of the specified matrix and returns it as an Euler rotation vector, assuming the rotations should be applied in YXZ order, which is the OpenGL default. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. Each element of the returned rotation vector represents an Euler angle in degrees. </p>

</div>
</div>
<a class="anchor" id="ade373e3117386ca344e4b8907b0788dc"></a><!-- doxytag: member="CC3GLMatrix::extractRotationZYXFromMatrix:" ref="ade373e3117386ca344e4b8907b0788dc" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractRotationZYXFromMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the rotation component of the specified matrix and returns it as an Euler rotation vector, assuming the rotations should be applied in ZYX order. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. Each element of the returned rotation vector represents an Euler angle in degrees. </p>

</div>
</div>
<a class="anchor" id="a73adc27e1d160763a02835a9af5982b4"></a><!-- doxytag: member="CC3GLMatrix::extractUpDirection" ref="a73adc27e1d160763a02835a9af5982b4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractUpDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts and returns the 'up' direction vector from the rotation component of this matrix. </p>

</div>
</div>
<a class="anchor" id="ac1e2f2abdb6330ae2ee26817d5989f71"></a><!-- doxytag: member="CC3GLMatrix::extractUpDirectionFrom:" ref="ac1e2f2abdb6330ae2ee26817d5989f71" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::extractUpDirectionFrom: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts and returns the 'up' direction vector from the rotation component of the specified matrix. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="acc74e53ddfbe78d2fa0eaeccb14bc79e"></a><!-- doxytag: member="CC3GLMatrix::identity" ref="acc74e53ddfbe78d2fa0eaeccb14bc79e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and returns an initialized autoreleased instance with all elements populated as an identity matrix (ones on the diagonal, zeros elsewhere). </p>

</div>
</div>
<a class="anchor" id="a5b3a666897bb69a0044ae5cb9a321443"></a><!-- doxytag: member="CC3GLMatrix::init" ref="a5b3a666897bb69a0044ae5cb9a321443" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an initialized instance with all elements set to zero. </p>

</div>
</div>
<a class="anchor" id="a35c620bd2a3f6d48e932c5192f0c9a43"></a><!-- doxytag: member="CC3GLMatrix::initFromGLMatrix:" ref="a35c620bd2a3f6d48e932c5192f0c9a43" args="(GLfloat *aGLMtx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::initFromGLMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMtx</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an initialized instance with all elements copied from the specified GL matrix, which must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="ab8cd3a95725332c9455b091fad1fdb7b"></a><!-- doxytag: member="CC3GLMatrix::initIdentity" ref="ab8cd3a95725332c9455b091fad1fdb7b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::initIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an initialized instance with all elements populated as an identity matrix (ones on the diagonal, zeros elsewhere). </p>

</div>
</div>
<a class="anchor" id="a3001711bb027bec7ff6fd5aa66e83bb0"></a><!-- doxytag: member="CC3GLMatrix::initOnGLMatrix:" ref="a3001711bb027bec7ff6fd5aa66e83bb0" args="(GLfloat *aGLMtx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::initOnGLMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMtx</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an initialized instance that wraps the specified GL matrix, which must be a standard 4x4 OpenGL matrix in column-major order. </p>
<p>Changes to this matrix instance will change the underlying data passed here. This is useful when the matrix data was supplied and loaded by some other mechanism, such as a file loader. Rather than copying the data into a new matrix, resulting in two copies of the matrix data, a <a class="el" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array.">CC3GLMatrix</a> instance can be initialized to wrap the data. </p>

</div>
</div>
<a class="anchor" id="afbfdab6ee142333b8c85026e951f2a5b"></a><!-- doxytag: member="CC3GLMatrix::initWithElements:" ref="afbfdab6ee142333b8c85026e951f2a5b" args="(GLfloat e00,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::initWithElements: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>e00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[,] &#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an initialized instance with elements populated from the specified variable arguments, which must consist of 16 elements in column-major order. </p>

</div>
</div>
<a class="anchor" id="a8c289e7e4c890bbdeac5f04aeac57ef0"></a><!-- doxytag: member="CC3GLMatrix::invert" ref="a8c289e7e4c890bbdeac5f04aeac57ef0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3GLMatrix::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts this matrix by using the algorithm of calculating the classical adjoint and dividing by the determinant. </p>
<p>The contents of the matrix are changed.</p>
<p>Not all matrices are invertable. Returns whether the matrix was inverted. If this method returns NO, then the matrix was not inverted and remains in the state it was when this method was invoked.</p>
<p>Matrix inversion is an computationally-expensive algorithm. If it is known that the matrix contains only rotation and translation, use the invertRigid: method instead, which is between one and two orders of magnitude faster than this method.</p>
<p>Also, be aware that rounding inaccuracies accumulated during the inversion calculations can often result in the inverse matrix that is not affine (the bottom row of the matrix is not {0, 0, 0 1}), even when the initial matrix was affine. These accumulated errors can often be significant when applied to the bottom row and will affect further calculations.</p>
<p>If it is known that a matrix represents an affine transformation, use the invertAffine: method instead, which forces the bottom row back to {0, 0, 0, 1} after the inversion to maintain the inverted matrix as an affine transformation.</p>
<p>Affine transforms include all combinations of rotation, scaling, shearing, translation, and orthographic projection, so all matrices encountered while working with 3D graphics, with the exception of perspective projection, will be affine transforms. </p>

</div>
</div>
<a class="anchor" id="a6c2d5aef577e09e4d538902f75509a73"></a><!-- doxytag: member="CC3GLMatrix::invert:" ref="a6c2d5aef577e09e4d538902f75509a73" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3GLMatrix::invert: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts the specified matrix by using the algorithm of calculating the classical adjoint and dividing by the determinant. </p>
<p>The contents of the matrix are changed. The matrix must be a standard 4x4 OpenGL matrix in column-major order.</p>
<p>Not all matrices are invertable. Returns whether the matrix was inverted. If this method returns NO, then the matrix was not inverted and remains in the state it was when this method was invoked.</p>
<p>Matrix inversion is an computationally-expensive algorithm. If it is known that the matrix contains only rotation and translation, use the invertRigid: method instead, which is between one and two orders of magnitude faster than this method.</p>
<p>Also, be aware that rounding inaccuracies accumulated during the inversion calculations can often result in the inverse matrix that is not affine (the bottom row of the matrix is not {0, 0, 0 1}), even when the initial matrix was affine. These accumulated errors can often be significant when applied to the bottom row and will affect further calculations.</p>
<p>If it is known that a matrix represents an affine transformation, use the invertAffine: method instead, which forces the bottom row back to {0, 0, 0, 1} after the inversion to maintain the inverted matrix as an affine transformation.</p>
<p>Affine transforms include all combinations of rotation, scaling, shearing, translation, and orthographic projection, so all matrices encountered while working with 3D graphics, with the exception of perspective projection, will be affine transforms. </p>

</div>
</div>
<a class="anchor" id="aebaacef6a99b5aaf32e9e14c7f847943"></a><!-- doxytag: member="CC3GLMatrix::invertAffine" ref="aebaacef6a99b5aaf32e9e14c7f847943" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3GLMatrix::invertAffine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts this matrix by using the algorithm of calculating the classical adjoint and dividing by the determinant. </p>
<p>The contents of the matrix are changed.</p>
<p>Not all matrices are invertable. Returns whether the matrix was inverted. If this method returns NO, then the matrix was not inverted and remains in the state it was when this method was invoked.</p>
<p>Matrix inversion is an computationally-expensive algorithm. If it is known that the matrix contains only rotation and translation, use the invertRigid: method instead, which is between one and two orders of magnitude faster than this method.</p>
<p>This method differs from the invert: method in that it assumes that the matrix represents an affine transform (the bottom row of the matrix is {0, 0, 0, 1}), and that accumulated inaccuracies in the inversion calculations should be removed from the bottom row of the resulting inverted matrix. After inversion, the bottom row of the inverted matrix is forced back to {0, 0, 0 1}.</p>
<p>This can be quite useful, as this row is particularly sensitive to the accumulation of inaccuracies and can often have a drastic impact on the accuracy of subsequent matrix and vector calculations. If it is known that a matrix represents an affine transformation, use this method instead of the invert: method.</p>
<p>Affine transforms include all combinations of rotation, scaling, shearing, translation, and orthographic projection, so all matrices encountered while working with 3D graphics, with the exception of perspective projection, will be affine transforms. </p>

</div>
</div>
<a class="anchor" id="abf04457213de23d46c4a83e7d0b7733c"></a><!-- doxytag: member="CC3GLMatrix::invertAffine:" ref="abf04457213de23d46c4a83e7d0b7733c" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3GLMatrix::invertAffine: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts the specified matrix by using the algorithm of calculating the classical adjoint and dividing by the determinant. </p>
<p>The contents of the matrix are changed. The matrix must be a standard 4x4 OpenGL matrix in column-major order.</p>
<p>Not all matrices are invertable. Returns whether the matrix was inverted. If this method returns NO, then the matrix was not inverted and remains in the state it was when this method was invoked.</p>
<p>Matrix inversion is an computationally-expensive algorithm. If it is known that the matrix contains only rotation and translation, use the invertRigid: method instead, which is between one and two orders of magnitude faster than this method.</p>
<p>This method differs from the invert: method in that it assumes that the matrix represents an affine transform (the bottom row of the matrix is {0, 0, 0, 1}), and that accumulated inaccuracies in the inversion calculations should be removed from the bottom row of the resulting inverted matrix. After inversion, the bottom row of the inverted matrix is forced back to {0, 0, 0 1}.</p>
<p>This can be quite useful, as this row is particularly sensitive to the accumulation of inaccuracies and can often have a drastic impact on the accuracy of subsequent matrix and vector calculations. If it is known that a matrix represents an affine transformation, use this method instead of the invert: method.</p>
<p>Affine transforms include all combinations of rotation, scaling, shearing, translation, and orthographic projection, so all matrices encountered while working with 3D graphics, with the exception of perspective projection, will be affine transforms. </p>

</div>
</div>
<a class="anchor" id="a031643d629aeb5bf3b512cfa94a0a449"></a><!-- doxytag: member="CC3GLMatrix::invertRigid" ref="a031643d629aeb5bf3b512cfa94a0a449" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::invertRigid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts this matrix using transposition and translation. </p>
<p>The contents of this matrix are changed.</p>
<p>This method assumes that the matrix represents a rigid transformation, containing only rotation and translation. Use this method only if it is known that this is the case. Inversion of a rigid transform matrix can be accomplished very quickly using transposition and translation, and is consistently one to two orders of magnitude faster than using either the invert: or invertAffine: methods. It is recommended that this method be used wherever possible. </p>

</div>
</div>
<a class="anchor" id="a77c6d1f3521f938932d5181cb6154484"></a><!-- doxytag: member="CC3GLMatrix::invertRigid:" ref="a77c6d1f3521f938932d5181cb6154484" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::invertRigid: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inverts the specified matrix using transposition and translation. </p>
<p>The contents of this matrix are changed. The matrix must be a standard 4x4 OpenGL matrix in column-major order.</p>
<p>This method assumes that the matrix represents a rigid transformation, containing only rotation and translation. Use this method only if it is known that this is the case. Inversion of a rigid transform matrix can be accomplished very quickly using transposition and translation, and is consistently one to two orders of magnitude faster than using either the invert: or invertAffine: methods. It is recommended that this method be used wherever possible. </p>

</div>
</div>
<a class="anchor" id="a2532bfcbbd22650beff3698a3bc7988b"></a><!-- doxytag: member="CC3GLMatrix::leftMultiply:byMatrix:" ref="a2532bfcbbd22650beff3698a3bc7988b" args="(GLfloat *aGLMatrix,[byMatrix] GLfloat *anotherGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::leftMultiply:byMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byMatrix] GLfloat *&#160;</td>
          <td class="paramname"><em>anotherGLMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies a matrix by another matrix, where, in the matrix multiplication equation, the first matrix is on the right and the second matrix is on the left. </p>
<p>The contents of the first matrix are changed. The contents of the second matrix remain unchanged.</p>
<p>Both matrices must be a standard 4x4 OpenGL matrices in column-major order. </p>

</div>
</div>
<a class="anchor" id="af5a858977bf47dfa292446b59e03b515"></a><!-- doxytag: member="CC3GLMatrix::leftMultiplyByMatrix:" ref="af5a858977bf47dfa292446b59e03b515" args="(CC3GLMatrix *aMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::leftMultiplyByMatrix: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td>
          <td class="paramname"><em>aMatrix</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies a matrix by the specified matrix, where, in the matrix multiplication equation, the specified matrix is on the left and this matrix is on the right. </p>
<p>The contents of this matrix are changed. The contents of the specified matrix remain unchanged.</p>
<p>If the specified matrix is nil, it is treated as an identity matrix, and this matrix remains unchanged. </p>

</div>
</div>
<a class="anchor" id="a81c9d09b678a0700a0abd3df3f9b2f81"></a><!-- doxytag: member="CC3GLMatrix::matrix" ref="a81c9d09b678a0700a0abd3df3f9b2f81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and returns an initialized autoreleased instance with all elements set to zero. </p>

</div>
</div>
<a class="anchor" id="a8efc53a90d23e62224486fe7f8b6ce7a"></a><!-- doxytag: member="CC3GLMatrix::matrixFromGLMatrix:" ref="a8efc53a90d23e62224486fe7f8b6ce7a" args="(GLfloat *aGLMtx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::matrixFromGLMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMtx</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and returns an initialized autoreleased instance with all elements copied from the specified GL matrix, which must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a05a58a6fccebf116ea8a11d11a1b5d8b"></a><!-- doxytag: member="CC3GLMatrix::matrixOnGLMatrix:" ref="a05a58a6fccebf116ea8a11d11a1b5d8b" args="(GLfloat *aGLMtx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::matrixOnGLMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMtx</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and returns an initialized autoreleased instance that wraps the specified GL matrix, which must be a standard 4x4 OpenGL matrix in column-major order. </p>
<p>Changes to this matrix instance will change the underlying data passed here. This is useful when the matrix data was supplied and loaded by some other mechanism, such as a file loader. Rather than copying the data into a new matrix, resulting in two copies of the matrix data, a <a class="el" href="interface_c_c3_g_l_matrix.html" title="A wrapper class for a 4x4 OpenGL matrix array.">CC3GLMatrix</a> instance can be initialized to wrap the data. </p>

</div>
</div>
<a class="anchor" id="ad0fde0dbe8964dbb37456b672c5bec59"></a><!-- doxytag: member="CC3GLMatrix::matrixWithElements:" ref="ad0fde0dbe8964dbb37456b672c5bec59" args="(GLfloat e00,[,]...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">id CC3GLMatrix::matrixWithElements: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>e00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[,] &#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and returns an initialized autoreleased instance with elements populated from the specified variable arguments, which must consist of 16 elements in column-major order. </p>

</div>
</div>
<a class="anchor" id="af66a22a46875bcddf05507682f7cf0f5"></a><!-- doxytag: member="CC3GLMatrix::multiply:byMatrix:" ref="af66a22a46875bcddf05507682f7cf0f5" args="(GLfloat *aGLMatrix,[byMatrix] GLfloat *anotherGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::multiply:byMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byMatrix] GLfloat *&#160;</td>
          <td class="paramname"><em>anotherGLMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies a matrix by another matrix, where, in the matrix multiplication equation, the first matrix is on the left and the second matrix is on the right. </p>
<p>The contents of the first matrix are changed. The contents of the second matrix remain unchanged.</p>
<p>Both matrices must be a standard 4x4 OpenGL matrices in column-major order. </p>

</div>
</div>
<a class="anchor" id="a1279d3b7c25dd48f88634bc61240a734"></a><!-- doxytag: member="CC3GLMatrix::multiplyByMatrix:" ref="a1279d3b7c25dd48f88634bc61240a734" args="(CC3GLMatrix *aMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::multiplyByMatrix: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td>
          <td class="paramname"><em>aMatrix</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies a matrix by the specified matrix, where, in the matrix multiplication equation, this matrix is on the left, and the specified matrix is on the right. </p>
<p>The contents of this matrix are changed. The contents of the specified matrix remain unchanged.</p>
<p>If the specified matrix is nil, it is treated as an identity matrix, and this matrix remains unchanged. </p>

</div>
</div>
<a class="anchor" id="a727d057d13dc57439c279a5c9f128b14"></a><!-- doxytag: member="CC3GLMatrix::populate:fromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:" ref="a727d057d13dc57439c279a5c9f128b14" args="(GLfloat *aGLMatrix,[fromFrustumLeft] GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populate:fromFrustumLeft:andRight:andBottom:andTop:andNear:andFar: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromFrustumLeft] GLfloat&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andRight] GLfloat&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andBottom] GLfloat&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTop] GLfloat&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andNear] GLfloat&#160;</td>
          <td class="paramname"><em>near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andFar] GLfloat&#160;</td>
          <td class="paramname"><em>far</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates the specified matrix as a perspective projection matrix with the specified frustum dimensions. </p>
<p>The matrix must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="acba047c2f851fcf4810448125637632f"></a><!-- doxytag: member="CC3GLMatrix::populate:toLookAt:withEyeAt:withUp:" ref="acba047c2f851fcf4810448125637632f" args="(GLfloat *aGLMatrix,[toLookAt] CC3Vector targetLocation,[withEyeAt] CC3Vector eyeLocation,[withUp] CC3Vector upDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populate:toLookAt:withEyeAt:withUp: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[toLookAt] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>targetLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withEyeAt] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>eyeLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>upDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates the specified matrix so that it will transform a vector between the targetLocation and the eyeLocation to point along the negative Z-axis, and transforms the specified upDirection to the positive Y-axis. </p>
<p>The matrix must be a standard 4x4 OpenGL matrix in column-major order.</p>
<p>This transform works in the direction from model-space to view-space, and therefore includes an implied inversion relative to the directToward:withUp: method. When applied to the camera, this has the effect of locating the camera at the eyeLocation and pointing it at the targetLocation, while orienting it so that 'up' appears to be in the upDirection, from the viewer's perspective. </p>

</div>
</div>
<a class="anchor" id="a1284b1f473ebd48e7592ffe2ff5b8391"></a><!-- doxytag: member="CC3GLMatrix::populate:toPointTowards:withUp:" ref="a1284b1f473ebd48e7592ffe2ff5b8391" args="(GLfloat *aGLMatrix,[toPointTowards] CC3Vector fwdDirection,[withUp] CC3Vector upDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populate:toPointTowards:withUp: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[toPointTowards] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>fwdDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>upDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates the specified matrix so that it will transform a vector pointed down the negative Z-axis to point in the specified forwardDirection, and transforms the positive Y-axis to point in the specified upDirection. </p>
<p>The matrix must be a standard 4x4 OpenGL matrix in column-major order.</p>
<p>When applied to a targetting object (such as a camera, light, gun, etc), this has the effect of pointing that object in a direction and orienting it so that 'up' is in the upDirection.</p>
<p>This method works in model-space, and does not include an implied inversion. So, when applied to the camera, this matrix must be subsequently inverted to transform from model-space to view-space. </p>

</div>
</div>
<a class="anchor" id="a151890a3ff0a35fb24d700d61584c756"></a><!-- doxytag: member="CC3GLMatrix::populateFrom:" ref="a151890a3ff0a35fb24d700d61584c756" args="(CC3GLMatrix *aMtx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateFrom: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a> *&#160;</td>
          <td class="paramname"><em>aMtx</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance from data copied from the specified matrix instance. </p>
<p>If the specified matrix is nil, it is treated as the identity matrix, and this matrix will be populated as an identity matrix. </p>

</div>
</div>
<a class="anchor" id="a559996fd7610741f1f526367e8bd3014"></a><!-- doxytag: member="CC3GLMatrix::populateFromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:" ref="a559996fd7610741f1f526367e8bd3014" args="(GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateFromFrustumLeft:andRight:andBottom:andTop:andNear:andFar: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andRight] GLfloat&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andBottom] GLfloat&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTop] GLfloat&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andNear] GLfloat&#160;</td>
          <td class="paramname"><em>near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andFar] GLfloat&#160;</td>
          <td class="paramname"><em>far</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this matrix as a perspective projection matrix with the specified frustum dimensions. </p>

</div>
</div>
<a class="anchor" id="a5357cfa424b9571f307f43b287c8a7d4"></a><!-- doxytag: member="CC3GLMatrix::populateFromGLMatrix:" ref="a5357cfa424b9571f307f43b287c8a7d4" args="(GLfloat *aGLMtx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateFromGLMatrix: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMtx</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance from data copied from the specified GL matrix, which must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a954d52b8b860adbd73ca40deb168bb94"></a><!-- doxytag: member="CC3GLMatrix::populateFromQuaternion:" ref="a954d52b8b860adbd73ca40deb168bb94" args="(CC3Vector4 aQuaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateFromQuaternion: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td>
          <td class="paramname"><em>aQuaternion</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance with the rotation data provided by the specified quaternion. </p>
<p>The resulting matrix can be used to perform rotation operations on other matrices through matrix multiplication. </p>

</div>
</div>
<a class="anchor" id="aad800f66966ba6d7637a0f56be296c81"></a><!-- doxytag: member="CC3GLMatrix::populateFromRotation:" ref="aad800f66966ba6d7637a0f56be296c81" args="(CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateFromRotation: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance with the rotation data provided by the specified rotation vector. </p>
<p>Each element of the rotation vector represents an Euler angle in degrees, and rotation is performed in YXZ order, which is the OpenGL default.</p>
<p>The resulting matrix can be used to perform rotation operations on other matrices through matrix multiplication. </p>

</div>
</div>
<a class="anchor" id="afa76b8936fa194b1ae8b7f9ed0b96ee9"></a><!-- doxytag: member="CC3GLMatrix::populateFromScale:" ref="afa76b8936fa194b1ae8b7f9ed0b96ee9" args="(CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateFromScale: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance with the scaling data provided by the specified scaling vector. </p>
<p>The resulting matrix can be used to perform scaling operations on other matrices through matrix multiplication. </p>

</div>
</div>
<a class="anchor" id="a15cdf556c246f4102561270d42719470"></a><!-- doxytag: member="CC3GLMatrix::populateFromTranslation:" ref="a15cdf556c246f4102561270d42719470" args="(CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateFromTranslation: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance with the translation data provided by the specified translation vector. </p>
<p>The resulting matrix can be used to perform translation operations on other matrices through matrix multiplication. </p>

</div>
</div>
<a class="anchor" id="aef13fa0c6dcf83c09a03aa7251543119"></a><!-- doxytag: member="CC3GLMatrix::populateIdentity" ref="aef13fa0c6dcf83c09a03aa7251543119" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance as an identity matrix (ones on the diagonal, zeros elsewhere). </p>

</div>
</div>
<a class="anchor" id="a767d98b77fe022014d2e23d8efcdf99a"></a><!-- doxytag: member="CC3GLMatrix::populateOrtho:fromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:" ref="a767d98b77fe022014d2e23d8efcdf99a" args="(GLfloat *aGLMatrix,[fromFrustumLeft] GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateOrtho:fromFrustumLeft:andRight:andBottom:andTop:andNear:andFar: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[fromFrustumLeft] GLfloat&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andRight] GLfloat&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andBottom] GLfloat&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTop] GLfloat&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andNear] GLfloat&#160;</td>
          <td class="paramname"><em>near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andFar] GLfloat&#160;</td>
          <td class="paramname"><em>far</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates the specified matrix as a parallel projection matrix with the specified frustum dimensions. </p>
<p>The matrix must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a13760ce846b6594eb38b8a921235f1a9"></a><!-- doxytag: member="CC3GLMatrix::populateOrthoFromFrustumLeft:andRight:andBottom:andTop:andNear:andFar:" ref="a13760ce846b6594eb38b8a921235f1a9" args="(GLfloat left,[andRight] GLfloat right,[andBottom] GLfloat bottom,[andTop] GLfloat top,[andNear] GLfloat near,[andFar] GLfloat far)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateOrthoFromFrustumLeft:andRight:andBottom:andTop:andNear:andFar: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andRight] GLfloat&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andBottom] GLfloat&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andTop] GLfloat&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andNear] GLfloat&#160;</td>
          <td class="paramname"><em>near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[andFar] GLfloat&#160;</td>
          <td class="paramname"><em>far</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this matrix as a parallel projection matrix with the specified frustum dimensions. </p>

</div>
</div>
<a class="anchor" id="a3907fcfc6174ebf29c12020a1e6667e4"></a><!-- doxytag: member="CC3GLMatrix::populateToLookAt:withEyeAt:withUp:" ref="a3907fcfc6174ebf29c12020a1e6667e4" args="(CC3Vector targetLocation,[withEyeAt] CC3Vector eyeLocation,[withUp] CC3Vector upDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateToLookAt:withEyeAt:withUp: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>targetLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withEyeAt] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>eyeLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>upDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this matrix so that it will transform a vector between the targetLocation and the eyeLocation to point along the negative Z-axis, and transforms the specified upDirection to the positive Y-axis. </p>
<p>This transform works in the direction from model-space to view-space, and therefore includes an implied inversion relative to the directToward:withUp: method. When applied to the camera, this has the effect of locating the camera at the eyeLocation and pointing it at the targetLocation, while orienting it so that 'up' appears to be in the upDirection, from the viewer's perspective. </p>

</div>
</div>
<a class="anchor" id="ae4c25be98db908c1557ded9db9cd1ca2"></a><!-- doxytag: member="CC3GLMatrix::populateToPointTowards:withUp:" ref="ae4c25be98db908c1557ded9db9cd1ca2" args="(CC3Vector fwdDirection,[withUp] CC3Vector upDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateToPointTowards:withUp: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>fwdDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withUp] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>upDirection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this matrix so that it will transform a vector pointed down the negative Z-axis to point in the specified forwardDirection, and transforms the positive Y-axis to point in the specified upDirection. </p>
<p>When applied to a targetting object (such as a camera, light, gun, etc), this has the effect of pointing that object in a direction and orienting it so that 'up' is in the upDirection.</p>
<p>This method works in model-space, and does not include an implied inversion. So, when applied to the camera, this matrix must be subsequently inverted to transform from model-space to view-space. </p>

</div>
</div>
<a class="anchor" id="a64cec56a8c38c471ada687c88106d73a"></a><!-- doxytag: member="CC3GLMatrix::populateZero" ref="a64cec56a8c38c471ada687c88106d73a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::populateZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Populates this instance so that all elements are zero. </p>

</div>
</div>
<a class="anchor" id="add7e134bd1fd8483385b4a236291568b"></a><!-- doxytag: member="CC3GLMatrix::rotate:byQuaternion:" ref="add7e134bd1fd8483385b4a236291568b" args="(GLfloat *aGLMatrix,[byQuaternion] CC3Vector4 aQuaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotate:byQuaternion: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byQuaternion] <a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td>
          <td class="paramname"><em>aQuaternion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified matrix by the rotation specified in the given quaternion. </p>
<p>Since this operation rotates a matrix that potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within the specified matrix. If the matrix rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by the matrix.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to the specified matrix.</p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="aa16e7cc6e951edf57fa4fe786662e370"></a><!-- doxytag: member="CC3GLMatrix::rotate:byX:" ref="aa16e7cc6e951edf57fa4fe786662e370" args="(GLfloat *aGLMatrix,[byX] GLfloat degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotate:byX: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byX] GLfloat&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified matrix around the X-axis by the specified number of degrees. </p>
<p>Since this operation rotates a matrix that potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within the specified matrix. If the matrix rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by the matrix.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to the specified matrix.</p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a1bdec1ecbb5f1784c97fc662a2b930d0"></a><!-- doxytag: member="CC3GLMatrix::rotate:byY:" ref="a1bdec1ecbb5f1784c97fc662a2b930d0" args="(GLfloat *aGLMatrix,[byY] GLfloat degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotate:byY: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byY] GLfloat&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified matrix around the Y-axis by the specified number of degrees. </p>
<p>Since this operation rotates a matrix that potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within the specified matrix. If the matrix rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by the matrix.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to the specified matrix.</p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="ad7e2cbbfe9c615254fc24cbdf424e71c"></a><!-- doxytag: member="CC3GLMatrix::rotate:byZ:" ref="ad7e2cbbfe9c615254fc24cbdf424e71c" args="(GLfloat *aGLMatrix,[byZ] GLfloat degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotate:byZ: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byZ] GLfloat&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified matrix around the Z-axis by the specified number of degrees. </p>
<p>Since this operation rotates a matrix that potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within the specified matrix. If the matrix rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by the matrix.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to the specified matrix.</p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="aa36818d5fafa8b2d47d973a5a18b4442"></a><!-- doxytag: member="CC3GLMatrix::rotateBy:" ref="aa36818d5fafa8b2d47d973a5a18b4442" args="(CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotateBy: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this matrix by the specified amount. </p>
<p>Each element of the rotation vector represents an Euler angle in degrees, and rotation is performed in YXZ order, which is the OpenGL default.</p>
<p>Since this matrix may potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within this matrix. If the existing rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by this matrix, which is almost always not the desired effect.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to this matrix. </p>

</div>
</div>
<a class="anchor" id="a1d568e50e2af9dafd19fa09ea6f5b00f"></a><!-- doxytag: member="CC3GLMatrix::rotateByQuaternion:" ref="a1d568e50e2af9dafd19fa09ea6f5b00f" args="(CC3Vector4 aQuaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotateByQuaternion: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td>
          <td class="paramname"><em>aQuaternion</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this matrix by the rotation specified in the given quaternion. </p>
<p>Since this matrix may potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within this matrix. If the existing rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by this matrix, which is almost always not the desired effect.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to this matrix. </p>

</div>
</div>
<a class="anchor" id="a8457abfa6c5264a4cb2a0067deb493b1"></a><!-- doxytag: member="CC3GLMatrix::rotateByX:" ref="a8457abfa6c5264a4cb2a0067deb493b1" args="(GLfloat degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotateByX: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this matrix around the X-axis by the specified number of degrees. </p>
<p>Since this matrix may potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within this matrix. If the existing rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by this matrix, which is almost always not the desired effect.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to this matrix. </p>

</div>
</div>
<a class="anchor" id="a85d7e2467984a6b9b8b02717f7328de4"></a><!-- doxytag: member="CC3GLMatrix::rotateByY:" ref="a85d7e2467984a6b9b8b02717f7328de4" args="(GLfloat degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotateByY: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this matrix around the Y-axis by the specified number of degrees. </p>
<p>Since this matrix may potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within this matrix. If the existing rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by this matrix, which is almost always not the desired effect.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to this matrix. </p>

</div>
</div>
<a class="anchor" id="a388d3f1cf67a98f8ab557a66e4c3f2c7"></a><!-- doxytag: member="CC3GLMatrix::rotateByZ:" ref="a388d3f1cf67a98f8ab557a66e4c3f2c7" args="(GLfloat degrees)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotateByZ: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates this matrix around the Z-axis by the specified number of degrees. </p>
<p>Since this matrix may potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within this matrix. If the existing rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by this matrix, which is almost always not the desired effect.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to this matrix. </p>

</div>
</div>
<a class="anchor" id="a6bd3bd8024eab258e85b30f14b10211f"></a><!-- doxytag: member="CC3GLMatrix::rotateYXZ:by:" ref="a6bd3bd8024eab258e85b30f14b10211f" args="(GLfloat *aGLMatrix,[by] CC3Vector aRotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotateYXZ:by: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aRotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified matrix by the specified amount. </p>
<p>Each element of the rotation vector represents an Euler angle in degrees, and rotation is performed in YXZ order, which is the OpenGL default.</p>
<p>Since this operation rotates a matrix that potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within the specified matrix. If the matrix rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by the matrix.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to the specified matrix.</p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a0de5a4e324d38376187712742b11604f"></a><!-- doxytag: member="CC3GLMatrix::rotateZYX:by:" ref="a0de5a4e324d38376187712742b11604f" args="(GLfloat *aGLMatrix,[by] CC3Vector aRotation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::rotateZYX:by: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aRotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the specified matrix by the specified amount. </p>
<p>Each element of the rotation vector represents an Euler angle in degrees, and rotation is performed in XYZ order.</p>
<p>Since this operation rotates a matrix that potentially already contains rotations, the new rotation is performed first, followed by the rotation already contained within the specified matrix. If the matrix rotations were performed first, the new rotation would be performed in the rotated coordinate system defined by the matrix.</p>
<p>In mathematical terms, the incoming rotation is converted to matrix form, and is left-multiplied to the specified matrix.</p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a420d0548f6f8475a20a42f3298683484"></a><!-- doxytag: member="CC3GLMatrix::scale:by:" ref="a420d0548f6f8475a20a42f3298683484" args="(GLfloat *aGLMatrix,[by] CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scale:by: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix in three dimensions by the specified scaling vector. </p>
<p>Non-uniform scaling can be achieved by specifying different values for each element of the scaling vector.</p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="af7063a8c67a2a43687ac887a23a38ccb"></a><!-- doxytag: member="CC3GLMatrix::scale:byX:" ref="af7063a8c67a2a43687ac887a23a38ccb" args="(GLfloat *aGLMatrix,[byX] GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scale:byX: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byX] GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix along the X-axis by the specified factor. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="ac5db3545e11a21e38764ef9cc16f752c"></a><!-- doxytag: member="CC3GLMatrix::scale:byY:" ref="ac5db3545e11a21e38764ef9cc16f752c" args="(GLfloat *aGLMatrix,[byY] GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scale:byY: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byY] GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix along the Y-axis by the specified factor. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="aa1288fadee0fee4292db280e6ec7c1a6"></a><!-- doxytag: member="CC3GLMatrix::scale:byZ:" ref="aa1288fadee0fee4292db280e6ec7c1a6" args="(GLfloat *aGLMatrix,[byZ] GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scale:byZ: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byZ] GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix along the Z-axis by the specified factor. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a44c60d64f0a74524ec59830427e3e96e"></a><!-- doxytag: member="CC3GLMatrix::scale:uniformlyBy:" ref="a44c60d64f0a74524ec59830427e3e96e" args="(GLfloat *aGLMatrix,[uniformlyBy] GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scale:uniformlyBy: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[uniformlyBy] GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix uniformly in three dimensions by the specified factor. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a37aaba903ed8be0426fcdb4c228052e2"></a><!-- doxytag: member="CC3GLMatrix::scaleBy:" ref="a37aaba903ed8be0426fcdb4c228052e2" args="(CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scaleBy: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix in three dimensions by the specified scaling vector. </p>
<p>Non-uniform scaling can be achieved by specifying different values for each element of the scaling vector. </p>

</div>
</div>
<a class="anchor" id="ace88e0add8dfed5575e8421ed4b8eb56"></a><!-- doxytag: member="CC3GLMatrix::scaleByX:" ref="ace88e0add8dfed5575e8421ed4b8eb56" args="(GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scaleByX: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix along the X-axis by the specified factor. </p>

</div>
</div>
<a class="anchor" id="a1d160af5bbef8313b10fad53c6b40cde"></a><!-- doxytag: member="CC3GLMatrix::scaleByY:" ref="a1d160af5bbef8313b10fad53c6b40cde" args="(GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scaleByY: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix along the Y-axis by the specified factor. </p>

</div>
</div>
<a class="anchor" id="adaf438e0f5e3413c50f6fc87b55fa94b"></a><!-- doxytag: member="CC3GLMatrix::scaleByZ:" ref="adaf438e0f5e3413c50f6fc87b55fa94b" args="(GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scaleByZ: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix along the Z-axis by the specified factor. </p>

</div>
</div>
<a class="anchor" id="a806f04e72472ab49db9c3104ea77368a"></a><!-- doxytag: member="CC3GLMatrix::scaleUniformlyBy:" ref="a806f04e72472ab49db9c3104ea77368a" args="(GLfloat scaleFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::scaleUniformlyBy: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>scaleFactor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales this matrix uniformly in three dimensions by the specified factor. </p>

</div>
</div>
<a class="anchor" id="a47bb4a2109857ee8915520d1a9178bbb"></a><!-- doxytag: member="CC3GLMatrix::transform:translateBy:rotateBy:scaleBy:" ref="a47bb4a2109857ee8915520d1a9178bbb" args="(GLfloat *aGLMatrix,[translateBy] CC3Vector aTranslation,[rotateBy] CC3Vector aRotation,[scaleBy] CC3Vector aScale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::transform:translateBy:rotateBy:scaleBy: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[translateBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aTranslation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[rotateBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aRotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[scaleBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates, rotates and scales (in that order) the specified matrix by the specified amounts. </p>
<p>Each element of the rotation vector represents an Euler angle in degrees, and rotation is performed in YXZ order, which is the OpenGL default. The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="afc70fb7e4b017c0ccf81cedd6a2e0641"></a><!-- doxytag: member="CC3GLMatrix::transformDirection:" ref="afc70fb7e4b017c0ccf81cedd6a2e0641" args="(CC3Vector aDirection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::transformDirection: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the specified direction vector using this matrix, and returns the transformed direction. </p>
<p>During multiplication, the fourth element of the direction vector is assumed to have a value of zero. This matrix and the original specified direction vector remain unchanged. </p>

</div>
</div>
<a class="anchor" id="acbe6474a29eff1a5b4bb1ca403efb16f"></a><!-- doxytag: member="CC3GLMatrix::transformDirection:withMatrix:" ref="acbe6474a29eff1a5b4bb1ca403efb16f" args="(CC3Vector aDirection,[withMatrix] GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::transformDirection:withMatrix: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withMatrix] GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the specified direction vector using the specified matrix, and returns the transformed direction. </p>
<p>During multiplication, the fourth element of the location vector is assumed to have a value of zero. The matrix and the original specified direction vector remain unchanged. The matrix must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a91f8d25c482b68da9077a383ee31ccad"></a><!-- doxytag: member="CC3GLMatrix::transformHomogeneousVector:" ref="a91f8d25c482b68da9077a383ee31ccad" args="(CC3Vector4 aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> CC3GLMatrix::transformHomogeneousVector: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the specified homogeneous vector using this matrix, and returns the transformed homogeneous vector. </p>
<p>This matrix and the original specified homogeneous vector remain unchanged. </p>

</div>
</div>
<a class="anchor" id="adda956162c85ae5004dfcc4fdaf90a6c"></a><!-- doxytag: member="CC3GLMatrix::transformHomogeneousVector:withMatrix:" ref="adda956162c85ae5004dfcc4fdaf90a6c" args="(CC3Vector4 aVector,[withMatrix] GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a> CC3GLMatrix::transformHomogeneousVector:withMatrix: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector4.html">CC3Vector4</a>&#160;</td>
          <td class="paramname"><em>aVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withMatrix] GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the specified homogeneous vector using the specified matrix, and returns the transformed homogeneous vector. </p>
<p>The matrix and the original specified homogeneous vector remain unchanged. The matrix must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a070e8fafc0dac92e7ff2d0544771f40f"></a><!-- doxytag: member="CC3GLMatrix::transformLocation:" ref="a070e8fafc0dac92e7ff2d0544771f40f" args="(CC3Vector aLocation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::transformLocation: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aLocation</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the specified location vector using this matrix, and returns the transformed location. </p>
<p>During multiplication, the fourth element of the location vector is assumed to have a value of one. This matrix and the original specified location vector remain unchanged. </p>

</div>
</div>
<a class="anchor" id="a0ea2431314fe4861c898d3dff4dbb948"></a><!-- doxytag: member="CC3GLMatrix::transformLocation:withMatrix:" ref="a0ea2431314fe4861c898d3dff4dbb948" args="(CC3Vector aLocation,[withMatrix] GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a> CC3GLMatrix::transformLocation:withMatrix: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[withMatrix] GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the specified location vector using the specified matrix, and returns the transformed location. </p>
<p>During multiplication, the fourth element of the location vector is assumed to have a value of one. The matrix and the original specified location vector remain unchanged. The matrix must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a0ff99eef841b459fd4d09f7f989ef4a8"></a><!-- doxytag: member="CC3GLMatrix::translate:by:" ref="a0ff99eef841b459fd4d09f7f989ef4a8" args="(GLfloat *aGLMatrix,[by] CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translate:by: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[by] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix in three dimensions by the specified translation vector. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a15e2ace10f171c04fbd6c6d2b39f98b4"></a><!-- doxytag: member="CC3GLMatrix::translate:byX:" ref="a15e2ace10f171c04fbd6c6d2b39f98b4" args="(GLfloat *aGLMatrix,[byX] GLfloat distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translate:byX: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byX] GLfloat&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix along the X-axis by the specified amount. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a1525cb082bf9b581905cc977475d1242"></a><!-- doxytag: member="CC3GLMatrix::translate:byY:" ref="a1525cb082bf9b581905cc977475d1242" args="(GLfloat *aGLMatrix,[byY] GLfloat distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translate:byY: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byY] GLfloat&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix along the Y-axis by the specified amount. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a57a3fc704259e966e5019e8b753767a2"></a><!-- doxytag: member="CC3GLMatrix::translate:byZ:" ref="a57a3fc704259e966e5019e8b753767a2" args="(GLfloat *aGLMatrix,[byZ] GLfloat distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translate:byZ: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[byZ] GLfloat&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix along the Z-axis by the specified amount. </p>
<p>The matrix must be standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<a class="anchor" id="a0f5c6b1724592b97b24d0777ea867f93"></a><!-- doxytag: member="CC3GLMatrix::translateBy:" ref="a0f5c6b1724592b97b24d0777ea867f93" args="(CC3Vector aVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translateBy: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>aVector</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix in three dimensions by the specified translation vector. </p>

</div>
</div>
<a class="anchor" id="a895eb121083298cf7c32a680d284f436"></a><!-- doxytag: member="CC3GLMatrix::translateBy:rotateBy:scaleBy:" ref="a895eb121083298cf7c32a680d284f436" args="(CC3Vector translationVector,[rotateBy] CC3Vector rotationVector,[scaleBy] CC3Vector scaleVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translateBy:rotateBy:scaleBy: </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>translationVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[rotateBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>rotationVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[scaleBy] <a class="el" href="struct_c_c3_vector.html">CC3Vector</a>&#160;</td>
          <td class="paramname"><em>scaleVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates, rotates and scales (in that order) this matrix by the specified amounts. </p>
<p>Each element of the rotation vector represents an Euler angle in degrees, and rotation is performed in YXZ order, which is the OpenGL default. </p>

</div>
</div>
<a class="anchor" id="ab7a6fcc39f5894743fcdf8ef5b15272b"></a><!-- doxytag: member="CC3GLMatrix::translateByX:" ref="ab7a6fcc39f5894743fcdf8ef5b15272b" args="(GLfloat distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translateByX: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>distance</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix along the X-axis by the specified amount. </p>

</div>
</div>
<a class="anchor" id="aa3e92638532b0edb07f866a8695240c1"></a><!-- doxytag: member="CC3GLMatrix::translateByY:" ref="aa3e92638532b0edb07f866a8695240c1" args="(GLfloat distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translateByY: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>distance</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix along the Y-axis by the specified amount. </p>

</div>
</div>
<a class="anchor" id="a94cc218bfa5f67b1992b33a9b947d4dc"></a><!-- doxytag: member="CC3GLMatrix::translateByZ:" ref="a94cc218bfa5f67b1992b33a9b947d4dc" args="(GLfloat distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::translateByZ: </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>distance</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Translates this matrix along the Z-axis by the specified amount. </p>

</div>
</div>
<a class="anchor" id="a89f2cc2b10e43e1f8e8efd3801b40128"></a><!-- doxytag: member="CC3GLMatrix::transpose" ref="a89f2cc2b10e43e1f8e8efd3801b40128" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transposes this matrix. </p>
<p>The contents of this matrix are changed. </p>

</div>
</div>
<a class="anchor" id="a0cd39eb8c54e3dcd5b211ad41327a7b1"></a><!-- doxytag: member="CC3GLMatrix::transpose:" ref="a0cd39eb8c54e3dcd5b211ad41327a7b1" args="(GLfloat *aGLMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC3GLMatrix::transpose: </td>
          <td>(</td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>aGLMatrix</em></td><td>)</td>
          <td><code> [static, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transposes the specified matrix. </p>
<p>The contents of the matrix are changed. The matrix must be a standard 4x4 OpenGL matrix in column-major order. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="a25383bc486461a0b2ad8acffe5f76448"></a><!-- doxytag: member="CC3GLMatrix::glMatrix" ref="a25383bc486461a0b2ad8acffe5f76448" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat* CC3GLMatrix::glMatrix<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the underlying array of 16 GLfloats stored in column-major order. </p>
<p>This can be passed directly into the standard OpenGL ES matrix functions. </p>

</div>
</div>
<a class="anchor" id="ae16ba83352ed7b4ff4d6bfed48fd6b30"></a><!-- doxytag: member="CC3GLMatrix::isIdentity" ref="ae16ba83352ed7b4ff4d6bfed48fd6b30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL CC3GLMatrix::isIdentity<code> [read, assign]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Indicates whether this matrix is an identity matrix. </p>
<p>This can be useful for short-circuiting many otherwise consumptive calculations. For example, this class is implemented so that, matrix multiplication is not performed as a raw calculation if one of the matrices is an identity matrix. In addition, transposition and inversion of an identity matrix are no-ops.</p>
<p>This values is set to YES after the matrix is initialized or populated as an identity matrix, or populated by an identity transform. It is set to NO whenever an operation is performed on this matrix that no longer results in it being an identity matrix.</p>
<p>This flag is only set to YES if the matrix is deliberately populated as an identity matrix. It will not be set to YES if an operation results in the contents of this matrix matching those of an identity matrix by accident. </p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="_c_c3_g_l_matrix_8h.html">CC3GLMatrix.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="interface_c_c3_g_l_matrix.html">CC3GLMatrix</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Nov 17 2011 18:52:07 for cocos3d by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5 </li>
   </ul>
 </div>


</body>
</html>
